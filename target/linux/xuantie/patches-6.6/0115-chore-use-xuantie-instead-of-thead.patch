From e753178950d5d633f59d5399d7992b7d08804593 Mon Sep 17 00:00:00 2001
From: Han Gao <gaohan@iscas.ac.cn>
Date: Tue, 2 Jul 2024 19:09:33 +0800
Subject: [PATCH 115/129] chore: use xuantie instead of thead

TH1520 is XuanTie SoC, so use xuantie instead of thead

Signed-off-by: Han Gao <gaohan@iscas.ac.cn>
Signed-off-by: Han Gao <rabenda.cn@gmail.com>
---
 .../bindings/iio/adc/thead,th1520-adc.yaml    |   8 +-
 .../bindings/iio/adc/xuantie,th1520-adc.yaml  |  52 ++
 .../bindings/mmc/snps,dwcmshc-sdhci.yaml      |   2 +-
 .../devicetree/bindings/net/snps,dwmac.yaml   |   2 +-
 .../{thead,dwmac.yaml => xuantie,dwmac.yaml}  |  16 +-
 ...h1520-pwm.yaml => xuantie,th1520-pwm.yaml} |   8 +-
 ...0-reset.yaml => xuantie,th1520-reset.yaml} |  10 +-
 .../xuantie,th1520-event.yaml}                |   8 +-
 ...520-qspi.yaml => xuantie,th1520-qspi.yaml} |   8 +-
 ...h1520-spi.yaml => xuantie,th1520-spi.yaml} |  10 +-
 ...h1520-usb.yaml => xuantie,th1520-usb.yaml} |  10 +-
 ...h1520-wdt.yaml => xuantie,th1520-wdt.yaml} |   4 +-
 .../dts/thead/th1520-lichee-module-4a.dtsi    |  36 +-
 .../boot/dts/thead/th1520-lichee-pi-4a.dts    |   2 +-
 arch/riscv/boot/dts/thead/th1520.dtsi         |  68 +-
 arch/riscv/configs/defconfig                  | 247 -------
 drivers/clk/Kconfig                           |   1 +
 drivers/clk/Makefile                          |   2 +-
 drivers/clk/thead/clk-th1520-fm.c             | 648 ------------------
 drivers/clk/thead/gate/Makefile               |   3 -
 drivers/clk/thead/gate/vosys-gate.c           | 111 ---
 drivers/clk/{thead => xuantie}/Kconfig        |   2 +-
 drivers/clk/{thead => xuantie}/Makefile       |   2 +-
 drivers/clk/xuantie/clk-th1520-fm.c           | 648 ++++++++++++++++++
 drivers/clk/{thead => xuantie}/clk.c          |  20 +-
 drivers/clk/{thead => xuantie}/clk.h          |  34 +-
 drivers/clk/xuantie/gate/Makefile             |   3 +
 .../{thead => xuantie}/gate/audiosys-gate.c   |  54 +-
 .../clk/{thead => xuantie}/gate/clk-gate.h    |   4 +-
 .../clk/{thead => xuantie}/gate/dspsys-gate.c |  52 +-
 .../{thead => xuantie}/gate/miscsys-gate.c    |  52 +-
 .../clk/{thead => xuantie}/gate/visys-gate.c  |  78 +--
 drivers/clk/xuantie/gate/vosys-gate.c         | 111 +++
 .../clk/{thead => xuantie}/gate/vpsys-gate.c  |  40 +-
 .../gate/xuantie-gate.c}                      |  28 +-
 drivers/cpufreq/Kconfig                       |   2 +-
 drivers/firmware/Kconfig                      |   2 +-
 drivers/firmware/Makefile                     |   2 +-
 drivers/firmware/thead/Kconfig                |  23 -
 drivers/firmware/xuantie/Kconfig              |  23 +
 drivers/firmware/{thead => xuantie}/Makefile  |   0
 .../firmware/{thead => xuantie}/th1520_aon.c  |   8 +-
 .../{thead => xuantie}/th1520_aon_pd.c        |   8 +-
 .../{thead => xuantie}/th1520_proc_debug.c    |   0
 drivers/iio/adc/Kconfig                       |   2 +-
 drivers/iio/adc/Makefile                      |   2 +-
 drivers/iio/adc/th1520-adc.c                  |   8 +-
 drivers/iio/adc/th1520-adc.h                  |   4 +-
 drivers/mmc/host/sdhci-of-dwcmshc.c           |   2 +-
 drivers/net/ethernet/stmicro/stmmac/Kconfig   |   2 +-
 drivers/net/ethernet/stmicro/stmmac/Makefile  |   2 +-
 .../stmmac/{dwmac-thead.c => dwmac-xuantie.c} | 123 ++--
 drivers/pwm/Kconfig                           |   4 +-
 drivers/pwm/Makefile                          |   2 +-
 drivers/pwm/pwm-thead.c                       | 269 --------
 drivers/pwm/pwm-xuantie.c                     | 269 ++++++++
 drivers/regulator/Kconfig                     |   2 +-
 drivers/regulator/th1520-aon-regulator.c      |   6 +-
 drivers/reset/reset-th1520.c                  |   2 +-
 drivers/rpmsg/th1520_rpmsg.c                  |   9 +-
 drivers/soc/Kconfig                           |   2 +-
 drivers/soc/Makefile                          |   2 +-
 drivers/soc/{thead => xuantie}/Kconfig        |   2 +-
 drivers/soc/{thead => xuantie}/Makefile       |   0
 drivers/soc/{thead => xuantie}/th1520_event.c |  30 +-
 drivers/usb/dwc3/Kconfig                      |   2 +-
 drivers/usb/dwc3/Makefile                     |   2 +-
 .../usb/dwc3/{dwc3-thead.c => dwc3-xuantie.c} | 120 ++--
 drivers/watchdog/dw_wdt.c                     |   2 +-
 drivers/watchdog/th1520_wdt.c                 |   4 +-
 .../firmware/{thead => xuantie}/rsrc.h        |   0
 ...,th1520-reset.h => xuantie,th1520-reset.h} |   0
 .../linux/firmware/{thead => xuantie}/ipc.h   |   0
 .../{thead => xuantie}/th1520_event.h         |   0
 kernel/panic.c                                |   2 +-
 75 files changed, 1566 insertions(+), 1762 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/iio/adc/xuantie,th1520-adc.yaml
 rename Documentation/devicetree/bindings/net/{thead,dwmac.yaml => xuantie,dwmac.yaml} (81%)
 rename Documentation/devicetree/bindings/pwm/{thead,th1520-pwm.yaml => xuantie,th1520-pwm.yaml} (76%)
 rename Documentation/devicetree/bindings/reset/{thead,th1520-reset.yaml => xuantie,th1520-reset.yaml} (71%)
 rename Documentation/devicetree/bindings/soc/{thead/thead,th1520-event.yaml => xuantie/xuantie,th1520-event.yaml} (78%)
 rename Documentation/devicetree/bindings/spi/{thead,th1520-qspi.yaml => xuantie,th1520-qspi.yaml} (81%)
 rename Documentation/devicetree/bindings/spi/{thead,th1520-spi.yaml => xuantie,th1520-spi.yaml} (80%)
 rename Documentation/devicetree/bindings/usb/{thead,th1520-usb.yaml => xuantie,th1520-usb.yaml} (85%)
 rename Documentation/devicetree/bindings/watchdog/{thead,th1520-wdt.yaml => xuantie,th1520-wdt.yaml} (81%)
 delete mode 100644 arch/riscv/configs/defconfig
 delete mode 100644 drivers/clk/thead/clk-th1520-fm.c
 delete mode 100644 drivers/clk/thead/gate/Makefile
 delete mode 100644 drivers/clk/thead/gate/vosys-gate.c
 rename drivers/clk/{thead => xuantie}/Kconfig (92%)
 rename drivers/clk/{thead => xuantie}/Makefile (80%)
 create mode 100644 drivers/clk/xuantie/clk-th1520-fm.c
 rename drivers/clk/{thead => xuantie}/clk.c (96%)
 rename drivers/clk/{thead => xuantie}/clk.h (67%)
 create mode 100644 drivers/clk/xuantie/gate/Makefile
 rename drivers/clk/{thead => xuantie}/gate/audiosys-gate.c (58%)
 rename drivers/clk/{thead => xuantie}/gate/clk-gate.h (86%)
 rename drivers/clk/{thead => xuantie}/gate/dspsys-gate.c (52%)
 rename drivers/clk/{thead => xuantie}/gate/miscsys-gate.c (59%)
 rename drivers/clk/{thead => xuantie}/gate/visys-gate.c (52%)
 create mode 100644 drivers/clk/xuantie/gate/vosys-gate.c
 rename drivers/clk/{thead => xuantie}/gate/vpsys-gate.c (52%)
 rename drivers/clk/{thead/gate/thead-gate.c => xuantie/gate/xuantie-gate.c} (72%)
 delete mode 100644 drivers/firmware/thead/Kconfig
 create mode 100644 drivers/firmware/xuantie/Kconfig
 rename drivers/firmware/{thead => xuantie}/Makefile (100%)
 rename drivers/firmware/{thead => xuantie}/th1520_aon.c (97%)
 rename drivers/firmware/{thead => xuantie}/th1520_aon_pd.c (97%)
 rename drivers/firmware/{thead => xuantie}/th1520_proc_debug.c (100%)
 rename drivers/net/ethernet/stmicro/stmmac/{dwmac-thead.c => dwmac-xuantie.c} (80%)
 delete mode 100644 drivers/pwm/pwm-thead.c
 create mode 100644 drivers/pwm/pwm-xuantie.c
 rename drivers/soc/{thead => xuantie}/Kconfig (89%)
 rename drivers/soc/{thead => xuantie}/Makefile (100%)
 rename drivers/soc/{thead => xuantie}/th1520_event.c (91%)
 rename drivers/usb/dwc3/{dwc3-thead.c => dwc3-xuantie.c} (55%)
 rename include/dt-bindings/firmware/{thead => xuantie}/rsrc.h (100%)
 rename include/dt-bindings/reset/{thead,th1520-reset.h => xuantie,th1520-reset.h} (100%)
 rename include/linux/firmware/{thead => xuantie}/ipc.h (100%)
 rename include/linux/firmware/{thead => xuantie}/th1520_event.h (100%)

--- a/Documentation/devicetree/bindings/iio/adc/thead,th1520-adc.yaml
+++ b/Documentation/devicetree/bindings/iio/adc/thead,th1520-adc.yaml
@@ -1,10 +1,10 @@
 # SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 %YAML 1.2
 ---
-$id: http://devicetree.org/schemas/iio/adc/thead,th1520-adc.yaml#
+$id: http://devicetree.org/schemas/iio/adc/xuantie,th1520-adc.yaml#
 $schema: http://devicetree.org/meta-schemas/core.yaml#
 
-title: THEAD TH1520 Analog to Digital Converter (ADC)
+title: XuanTie TH1520 Analog to Digital Converter (ADC)
 
 maintainers:
   - Fugang Duan <duanfugang.dfg@linux.alibaba.com>
@@ -15,7 +15,7 @@ description: |
   12-Bit Analog to Digital Converter (ADC) on XuanTie TH1520
 properties:
   compatible:
-    const: thead,th1520
+    const: xuantie,th1520-adc
 
   reg:
     maxItems: 1
@@ -42,7 +42,7 @@ additionalProperties: false
 examples:
   - |
     adc: adc@0xfffff51000 {
-        compatible = "thead,th1520-adc";
+        compatible = "xuantie,th1520-adc";
         reg = <0xff 0xfff51000 0x0 0x1000>;
         interrupts = <61 IRQ_TYPE_LEVEL_HIGH>;
         clocks = <&aonsys_clk>;
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/adc/xuantie,th1520-adc.yaml
@@ -0,0 +1,52 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/iio/adc/xuantie,th1520-adc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie TH1520 Analog to Digital Converter (ADC)
+
+maintainers:
+  - Fugang Duan <duanfugang.dfg@linux.alibaba.com>
+  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
+  - Wei Fu <wefu@redhat.com>
+
+description: |
+  12-Bit Analog to Digital Converter (ADC) on XuanTie TH1520
+properties:
+  compatible:
+    const: xuantie,th1520-adc
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  clock-names:
+    const: adc
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - status
+
+additionalProperties: false
+
+examples:
+  - |
+    adc: adc@0xfffff51000 {
+        compatible = "xuantie,th1520-adc";
+        reg = <0xff 0xfff51000 0x0 0x1000>;
+        interrupts = <61 IRQ_TYPE_LEVEL_HIGH>;
+        clocks = <&aonsys_clk>;
+        clock-names = "adc";
+        /* ADC pin is proprietary,no need to config pinctrl */
+        status = "disabled";
+    };
--- a/Documentation/devicetree/bindings/mmc/snps,dwcmshc-sdhci.yaml
+++ b/Documentation/devicetree/bindings/mmc/snps,dwcmshc-sdhci.yaml
@@ -19,7 +19,7 @@ properties:
       - rockchip,rk3568-dwcmshc
       - rockchip,rk3588-dwcmshc
       - snps,dwcmshc-sdhci
-      - thead,th1520-dwcmshc
+      - xuantie,th1520-dwcmshc
 
   reg:
     maxItems: 1
--- a/Documentation/devicetree/bindings/net/snps,dwmac.yaml
+++ b/Documentation/devicetree/bindings/net/snps,dwmac.yaml
@@ -96,7 +96,7 @@ properties:
         - snps,dwxgmac
         - snps,dwxgmac-2.10
         - starfive,jh7110-dwmac
-        - thead,th1520-dwmac
+        - xuantie,th1520-dwmac
 
   reg:
     minItems: 1
--- a/Documentation/devicetree/bindings/net/thead,dwmac.yaml
+++ /dev/null
@@ -1,77 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/net/thead,dwmac.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: T-HEAD DWMAC Ethernet controller
-
-maintainers:
-  - Jisheng Zhang <jszhang@kernel.org>
-
-select:
-  properties:
-    compatible:
-      contains:
-        enum:
-          - thead,th1520-dwmac
-  required:
-    - compatible
-
-properties:
-  compatible:
-    items:
-      - enum:
-          - thead,th1520-dwmac
-      - const: snps,dwmac-3.70a
-
-  reg:
-    maxItems: 1
-
-  thead,gmacapb:
-    $ref: /schemas/types.yaml#/definitions/phandle
-    description:
-      The phandle to the syscon node that control ethernet
-      interface and timing delay.
-
-required:
-  - compatible
-  - reg
-  - clocks
-  - clock-names
-  - interrupts
-  - interrupt-names
-  - phy-mode
-  - thead,gmacapb
-
-allOf:
-  - $ref: snps,dwmac.yaml#
-
-unevaluatedProperties: false
-
-examples:
-  - |
-    gmac0: ethernet@e7070000 {
-        compatible = "thead,th1520-dwmac", "snps,dwmac-3.70a";
-        reg = <0xe7070000 0x2000>;
-        clocks = <&clk 1>, <&clk 2>;
-        clock-names = "stmmaceth", "pclk";
-        interrupts = <66>;
-        interrupt-names = "macirq";
-        phy-mode = "rgmii-id";
-        snps,fixed-burst;
-        snps,axi-config = <&stmmac_axi_setup>;
-        snps,pbl = <32>;
-        thead,gmacapb = <&gmacapb_syscon>;
-        phy-handle = <&phy0>;
-
-        mdio {
-            #address-cells = <1>;
-            #size-cells = <0>;
-            compatible = "snps,dwmac-mdio";
-
-            phy0: ethernet-phy@0 {
-                reg = <0>;
-            };
-        };
-    };
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/xuantie,dwmac.yaml
@@ -0,0 +1,77 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/net/xuantie,dwmac.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie Th1520 DWMAC Ethernet controller
+
+maintainers:
+  - Jisheng Zhang <jszhang@kernel.org>
+
+select:
+  properties:
+    compatible:
+      contains:
+        enum:
+          - xuantie,th1520-dwmac
+  required:
+    - compatible
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xuantie,th1520-dwmac
+      - const: snps,dwmac-3.70a
+
+  reg:
+    maxItems: 1
+
+  th1520,gmacapb:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description:
+      The phandle to the syscon node that control ethernet
+      interface and timing delay.
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - interrupts
+  - interrupt-names
+  - phy-mode
+  - th1520,gmacapb
+
+allOf:
+  - $ref: snps,dwmac.yaml#
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    gmac0: ethernet@e7070000 {
+        compatible = "xuantie,th1520-dwmac";
+        reg = <0xe7070000 0x2000>;
+        clocks = <&clk 1>, <&clk 2>;
+        clock-names = "stmmaceth", "pclk";
+        interrupts = <66>;
+        interrupt-names = "macirq";
+        phy-mode = "rgmii-id";
+        snps,fixed-burst;
+        snps,axi-config = <&stmmac_axi_setup>;
+        snps,pbl = <32>;
+        th1520,gmacapb = <&gmacapb_syscon>;
+        phy-handle = <&phy0>;
+
+        mdio {
+            #address-cells = <1>;
+            #size-cells = <0>;
+            compatible = "snps,dwmac-mdio";
+
+            phy0: ethernet-phy@0 {
+                reg = <0>;
+            };
+        };
+    };
--- a/Documentation/devicetree/bindings/pwm/thead,th1520-pwm.yaml
+++ /dev/null
@@ -1,44 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/pwm/thead,th1520-pwm.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: T-HEAD TH1520 PWM
-
-maintainers:
-  - Jisheng Zhang <jszhang@kernel.org>
-
-allOf:
-  - $ref: pwm.yaml#
-
-properties:
-  compatible:
-    enum:
-      - thead,th1520-pwm
-
-  reg:
-    maxItems: 1
-
-  clocks:
-    maxItems: 1
-
-  "#pwm-cells":
-    const: 3
-
-required:
-  - compatible
-  - reg
-  - clocks
-
-additionalProperties: false
-
-examples:
-  - |
-
-    pwm@ec01c000 {
-        compatible = "thead,th1520-pwm";
-        reg = <0xec01c000 0x1000>;
-        clocks = <&clk 1>;
-        #pwm-cells = <3>;
-    };
--- /dev/null
+++ b/Documentation/devicetree/bindings/pwm/xuantie,th1520-pwm.yaml
@@ -0,0 +1,44 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/pwm/xuantie,th1520-pwm.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie TH1520 PWM
+
+maintainers:
+  - Jisheng Zhang <jszhang@kernel.org>
+
+allOf:
+  - $ref: pwm.yaml#
+
+properties:
+  compatible:
+    enum:
+      - xuantie,th1520-pwm
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  "#pwm-cells":
+    const: 3
+
+required:
+  - compatible
+  - reg
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+
+    pwm@ec01c000 {
+        compatible = "xuantie,th1520-pwm";
+        reg = <0xec01c000 0x1000>;
+        clocks = <&clk 1>;
+        #pwm-cells = <3>;
+    };
--- a/Documentation/devicetree/bindings/reset/thead,th1520-reset.yaml
+++ /dev/null
@@ -1,45 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/reset/thead,th1520-reset.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: T-HEAD th1520 SoC Reset Controller
-
-maintainers:
-  - Kwanghoon Son <k.son@samsung.com>
-  - Hengqiang Ming <minghq@linux.alibaba.com>
-
-properties:
-  compatible:
-    items:
-      - const: thead,th1520-reset
-      - const: syscon
-
-  reg:
-    maxItems: 1
-
-  '#reset-cells':
-    const: 1
-
-required:
-  - compatible
-  - reg
-  - '#reset-cells'
-
-additionalProperties: false
-
-examples:
-  - |
-    #include <dt-bindings/reset/thead,th1520-reset.h>
-
-    soc {
-        #address-cells = <2>;
-        #size-cells = <2>;
-
-        reset-controller@ffef014000 {
-            compatible = "thead,th1520-reset", "syscon";
-            reg = <0xff 0xef014000 0x0 0x1000>;
-            #reset-cells = <1>;
-        };
-    };
--- /dev/null
+++ b/Documentation/devicetree/bindings/reset/xuantie,th1520-reset.yaml
@@ -0,0 +1,45 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/reset/xuantie,th1520-reset.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie th1520 SoC Reset Controller
+
+maintainers:
+  - Kwanghoon Son <k.son@samsung.com>
+  - Hengqiang Ming <minghq@linux.alibaba.com>
+
+properties:
+  compatible:
+    items:
+      - const: xuantie,th1520-reset
+      - const: syscon
+
+  reg:
+    maxItems: 1
+
+  '#reset-cells':
+    const: 1
+
+required:
+  - compatible
+  - reg
+  - '#reset-cells'
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/reset/xuantie,th1520-reset.h>
+
+    soc {
+        #address-cells = <2>;
+        #size-cells = <2>;
+
+        reset-controller@ffef014000 {
+            compatible = "xuantie,th1520-reset", "syscon";
+            reg = <0xff 0xef014000 0x0 0x1000>;
+            #reset-cells = <1>;
+        };
+    };
--- a/Documentation/devicetree/bindings/soc/thead/thead,th1520-event.yaml
+++ /dev/null
@@ -1,37 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/soc/thead/thead,th1520-event.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: Thead TH1520 SOC Rebootmode Feature
-
-maintainers:
-  - Hao Li <ben.lihao@linux.alibaba.com>
-  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
-
-description:
-  This driver supports check rebootmode feature in th1520 FM platform.
-  When the system reboots, event driver recording the reboot cause to a
-  piece of always-on ram, which is data-hold during the system reboot.
-
-properties:
-  compatible:
-      - items:
-          - const: thead,th1520-event
-
-  aon-iram-regmap:
-    description:
-      always-on ram address range for driver to save rebootmode
-
-required:
-  - compatible
-  - aon-iram-regmap
-
-examples:
-  - |
-    th1520_event: th1520-event {
-        compatible = "thead,th1520-event";
-        aon-iram-regmap = <&aon_iram>;
-        status = "okay";
-    };
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/xuantie/xuantie,th1520-event.yaml
@@ -0,0 +1,37 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/soc/xuantie/xuantie,th1520-event.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie TH1520 SOC Rebootmode Feature
+
+maintainers:
+  - Hao Li <ben.lihao@linux.alibaba.com>
+  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
+
+description:
+  This driver supports check rebootmode feature in th1520 FM platform.
+  When the system reboots, event driver recording the reboot cause to a
+  piece of always-on ram, which is data-hold during the system reboot.
+
+properties:
+  compatible:
+      - items:
+          - const: xuantie,th1520-event
+
+  aon-iram-regmap:
+    description:
+      always-on ram address range for driver to save rebootmode
+
+required:
+  - compatible
+  - aon-iram-regmap
+
+examples:
+  - |
+    th1520_event: th1520-event {
+        compatible = "xuantie,th1520-event";
+        aon-iram-regmap = <&aon_iram>;
+        status = "okay";
+    };
--- a/Documentation/devicetree/bindings/spi/thead,th1520-qspi.yaml
+++ /dev/null
@@ -1,52 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/spi/thead,th1520-spi.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: THEAD TH1520 Quad Serial Peripheral Interface (QSPI)
-
-maintainers:
-  - linghui zeng<linghui.zlh@linux.alibaba.com>
-  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
-properties:
-  compatible:
-    const: thead,th1520
-
-  reg:
-    maxItems: 1
-
-  clocks:
-    maxItems: 1
-
-  clock-names:
-    items:
-      - const: sclk
-      - const: pclk
-
-  interrupts:
-    maxItems: 1
-
-required:
-  - compatible
-  - reg
-  - clocks
-  - clock-names
-  - interrupts
-  - status
-
-unevaluatedProperties: false
-
-examples:
-  - |
-    qspi0: qspi@ffea000000 {
-        compatible = "snps,dw-apb-ssi-quad";
-        reg = <0xff 0xea000000 0x0 0x1000>;
-        interrupts = <52 IRQ_TYPE_LEVEL_HIGH>;
-        clocks = <&clk CLKGEN_QSPI0_SSI_CLK>,
-            <&clk CLKGEN_QSPI0_PCLK>;
-        clock-names = "sclk", "pclk";
-        #address-cells = <1>;
-        #size-cells = <0>;
-        status = "disabled";
-    };
--- /dev/null
+++ b/Documentation/devicetree/bindings/spi/xuantie,th1520-qspi.yaml
@@ -0,0 +1,52 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/spi/xuantie,th1520-spi.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie TH1520 Quad Serial Peripheral Interface (QSPI)
+
+maintainers:
+  - linghui zeng <linghui.zlh@linux.alibaba.com>
+  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
+properties:
+  compatible:
+    const: xuantie,th1520
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  clock-names:
+    items:
+      - const: sclk
+      - const: pclk
+
+  interrupts:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - interrupts
+  - status
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    qspi0: qspi@ffea000000 {
+        compatible = "snps,dw-apb-ssi-quad";
+        reg = <0xff 0xea000000 0x0 0x1000>;
+        interrupts = <52 IRQ_TYPE_LEVEL_HIGH>;
+        clocks = <&clk CLKGEN_QSPI0_SSI_CLK>,
+            <&clk CLKGEN_QSPI0_PCLK>;
+        clock-names = "sclk", "pclk";
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "disabled";
+    };
--- a/Documentation/devicetree/bindings/spi/thead,th1520-spi.yaml
+++ /dev/null
@@ -1,58 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/spi/thead,th1520-spi.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: THEAD TH1520 SPI Controller
-
-description: |
-  The THEAD TH1520 SPI controller is used to communicate with external devices using
-  the Serial Peripheral Interface. It supports full-duplex, half-duplex and
-  simplex synchronous serial communication with external devices. It supports
-  from 4 to 32-bit data size.
-
-maintainers:
-  - linghui zeng<linghui.zlh@linux.alibaba.com>
-  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
-properties:
-  compatible:
-    const: thead,th1520
-
-  reg:
-    maxItems: 1
-
-  clocks:
-    maxItems: 1
-
-  clock-names:
-    items:
-      - const: sclk
-      - const: pclk
-
-  interrupts:
-    maxItems: 1
-
-required:
-  - compatible
-  - reg
-  - clocks
-  - clock-names
-  - interrupts
-  - status
-
-additionalProperties: false
-
-examples:
-  - |
-    spi: spi@ffe700c000 {
-        compatible = "snps,dw-apb-ssi";
-        reg = <0xff 0xe700c000 0x0 0x1000>;
-        interrupts = <54 IRQ_TYPE_LEVEL_HIGH>;
-        clocks = <&clk CLKGEN_SPI_SSI_CLK>,
-            <&clk CLKGEN_SPI_PCLK>;
-        clock-names = "sclk", "pclk";
-        #address-cells = <1>;
-        #size-cells = <0>;
-        status = "disabled";
-    };
--- /dev/null
+++ b/Documentation/devicetree/bindings/spi/xuantie,th1520-spi.yaml
@@ -0,0 +1,58 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/spi/xuantie,th1520-spi.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie TH1520 SPI Controller
+
+description: |
+  The XuanTie TH1520 SPI controller is used to communicate with external devices using
+  the Serial Peripheral Interface. It supports full-duplex, half-duplex and
+  simplex synchronous serial communication with external devices. It supports
+  from 4 to 32-bit data size.
+
+maintainers:
+  - linghui zeng <linghui.zlh@linux.alibaba.com>
+  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
+properties:
+  compatible:
+    const: xuantie,th1520
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  clock-names:
+    items:
+      - const: sclk
+      - const: pclk
+
+  interrupts:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - interrupts
+  - status
+
+additionalProperties: false
+
+examples:
+  - |
+    spi: spi@ffe700c000 {
+        compatible = "snps,dw-apb-ssi";
+        reg = <0xff 0xe700c000 0x0 0x1000>;
+        interrupts = <54 IRQ_TYPE_LEVEL_HIGH>;
+        clocks = <&clk CLKGEN_SPI_SSI_CLK>,
+            <&clk CLKGEN_SPI_PCLK>;
+        clock-names = "sclk", "pclk";
+        #address-cells = <1>;
+        #size-cells = <0>;
+        status = "disabled";
+    };
--- a/Documentation/devicetree/bindings/usb/thead,th1520-usb.yaml
+++ /dev/null
@@ -1,76 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/usb/thead,th1520-usb.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: T-HEAD TH1520 DWC3 USB Controller Glue
-
-maintainers:
-  - Jisheng Zhang <jszhang@kernel.org>
-
-properties:
-  compatible:
-    const: thead,th1520-usb
-
-  reg:
-    maxItems: 1
-
-  clocks:
-    maxItems: 4
-
-  clock-names:
-    items:
-      - const: ref
-      - const: bus_early
-      - const: phy
-      - const: suspend
-
-  ranges: true
-
-  '#address-cells':
-    enum: [ 1, 2 ]
-
-  '#size-cells':
-    enum: [ 1, 2 ]
-
-# Required child node:
-
-patternProperties:
-  "^usb@[0-9a-f]+$":
-    $ref: snps,dwc3.yaml#
-
-required:
-  - compatible
-  - reg
-  - clocks
-  - clock-names
-  - ranges
-
-additionalProperties: false
-
-examples:
-  - |
-		usb: usb@ffec03f000 {
-			compatible = "thead,th1520-usb";
-			usb3-misc-regmap = <&misc_sysreg>;
-			reg = <0xff 0xec03f000 0x0 0x1000>;
-			thead,misc-sysreg = <&misc_sysreg>;
-			clocks = <&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_CLK>,
-					<&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_CTRL_REF_CLK>,
-					<&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_PHY_REF_CLK>,
-					<&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_SUSPEND_CLK>;
-			clock-names = "drd", "ctrl", "phy", "suspend";
-			#address-cells = <2>;
-			#size-cells = <2>;
-			ranges;
-
-			usb_dwc3: usb@ffe7040000 {
-				compatible = "snps,dwc3";
-				reg = <0xff 0xe7040000 0x0 0x10000>;
-				interrupts = <68 IRQ_TYPE_LEVEL_HIGH>;
-				dr_mode = "host";
-				snps,usb3_lpm_capable;
-				status = "disabled";
-			};
-		};
\ No newline at end of file
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/xuantie,th1520-usb.yaml
@@ -0,0 +1,76 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/usb/xuantie,th1520-usb.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie TH1520 DWC3 USB Controller Glue
+
+maintainers:
+  - Jisheng Zhang <jszhang@kernel.org>
+
+properties:
+  compatible:
+    const: xuantie,th1520-usb
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 4
+
+  clock-names:
+    items:
+      - const: ref
+      - const: bus_early
+      - const: phy
+      - const: suspend
+
+  ranges: true
+
+  '#address-cells':
+    enum: [ 1, 2 ]
+
+  '#size-cells':
+    enum: [ 1, 2 ]
+
+# Required child node:
+
+patternProperties:
+  "^usb@[0-9a-f]+$":
+    $ref: snps,dwc3.yaml#
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - ranges
+
+additionalProperties: false
+
+examples:
+  - |
+		usb: usb@ffec03f000 {
+			compatible = "xuantie,th1520-usb";
+			usb3-misc-regmap = <&misc_sysreg>;
+			reg = <0xff 0xec03f000 0x0 0x1000>;
+			xuantie,misc-sysreg = <&misc_sysreg>;
+			clocks = <&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_CLK>,
+					<&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_CTRL_REF_CLK>,
+					<&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_PHY_REF_CLK>,
+					<&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_SUSPEND_CLK>;
+			clock-names = "drd", "ctrl", "phy", "suspend";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+
+			usb_dwc3: usb@ffe7040000 {
+				compatible = "snps,dwc3";
+				reg = <0xff 0xe7040000 0x0 0x10000>;
+				interrupts = <68 IRQ_TYPE_LEVEL_HIGH>;
+				dr_mode = "host";
+				snps,usb3_lpm_capable;
+				status = "disabled";
+			};
+		};
\ No newline at end of file
--- a/Documentation/devicetree/bindings/watchdog/thead,th1520-wdt.yaml
+++ /dev/null
@@ -1,19 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/watchdog/thead,th1520-wdt.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: THEAD PMIC Watchdog for TH1520 SoC
-
-maintainers:
-  - Wei.Liu <lw312886@linux.alibaba.com>
-  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
-
-description:
-  This is the driver for the hardware watchdog on TH1520 product Board.
-  This watchdog simply watches your kernel to make sure it doesn't freeze,
-  and if it does, it reboots your computer after a certain amount of time.
-
-allOf:
-  - $ref: watchdog.yaml#
--- /dev/null
+++ b/Documentation/devicetree/bindings/watchdog/xuantie,th1520-wdt.yaml
@@ -0,0 +1,19 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/watchdog/xuantie,th1520-wdt.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: XuanTie PMIC Watchdog for TH1520 SoC
+
+maintainers:
+  - Wei.Liu <lw312886@linux.alibaba.com>
+  - Xiangyi Zeng <xiangyi.zeng@linux.alibaba.com>
+
+description:
+  This is the driver for the hardware watchdog on TH1520 product Board.
+  This watchdog simply watches your kernel to make sure it doesn't freeze,
+  and if it does, it reboots your computer after a certain amount of time.
+
+allOf:
+  - $ref: watchdog.yaml#
--- a/arch/riscv/boot/dts/thead/th1520-lichee-module-4a.dtsi
+++ b/arch/riscv/boot/dts/thead/th1520-lichee-module-4a.dtsi
@@ -241,7 +241,7 @@
 
 &aon {
 	dvdd_cpu_reg: appcpu_dvdd {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "appcpu_dvdd";
 		regulator-min-microvolt = <300000>;
 		regulator-max-microvolt = <1570000>;
@@ -251,7 +251,7 @@
 	};
 
 	dvddm_cpu_reg: appcpu_dvddm {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "appcpu_dvddm";
 		regulator-min-microvolt = <300000>;
 		regulator-max-microvolt = <1570000>;
@@ -262,7 +262,7 @@
 	};
 
 	soc_dvdd18_aon_reg: soc_dvdd18_aon {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dvdd18_aon";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -270,7 +270,7 @@
 	};
 
 	soc_avdd33_usb3_reg: soc_avdd33_usb3 {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_avdd33_usb3";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -278,7 +278,7 @@
 	};
 
 	soc_dvdd08_aon_reg: soc_dvdd08_aon {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dvdd08_aon";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -286,7 +286,7 @@
 	};
 
 	soc_dvdd08_ddr_reg: soc_dvdd08_ddr {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dvdd08_ddr";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -294,7 +294,7 @@
 	};
 
 	soc_vdd_ddr_1v8_reg: soc_vdd_ddr_1v8 {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_vdd_ddr_1v8";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -302,7 +302,7 @@
 	};
 
 	soc_vdd_ddr_1v1_reg: soc_vdd_ddr_1v1 {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_vdd_ddr_1v1";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -310,7 +310,7 @@
 	};
 
 	soc_vdd_ddr_0v6_reg: soc_vdd_ddr_0v6 {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_vdd_ddr_0v6";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -318,7 +318,7 @@
 	};
 
 	soc_dvdd18_ap_reg: soc_dvdd18_ap {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dvdd18_ap";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -326,7 +326,7 @@
 	};
 
 	soc_dvdd08_ap_reg: soc_dvdd08_ap {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dvdd08_ap";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -334,7 +334,7 @@
 	};
 
 	soc_avdd08_mipi_hdmi_reg: soc_avdd08_mipi_hdmi {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_avdd08_mipi_hdmi";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -342,7 +342,7 @@
 	};
 
 	soc_avdd18_mipi_hdmi_reg: soc_avdd18_mipi_hdmi {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_avdd18_mipi_hdmi";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -350,7 +350,7 @@
 	};
 
 	soc_vdd33_emmc_reg: soc_vdd33_emmc {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dvdd33_emmc";
 		regulator-type = "common";
 		regulator-boot-on;
@@ -358,7 +358,7 @@
 	};
 
 	soc_vdd18_emmc_reg: soc_vdd18_emmc {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dvdd18_emmc";
 		regulator-type = "gpio";
 		regulator-boot-on;
@@ -366,7 +366,7 @@
 	};
 
 	soc_dovdd18_scan_reg: soc_dovdd18_scan {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dovdd18_scan";
 		regulator-type = "common";
 		regulator-min-microvolt = <900000>;
@@ -374,7 +374,7 @@
 	};
 
 	soc_dvdd12_scan_reg: soc_dvdd12_scan {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_dvdd12_scan";
 		regulator-type = "common";
 		regulator-min-microvolt = <900000>;
@@ -382,7 +382,7 @@
 	};
 
 	soc_avdd28_scan_en_reg: soc_avdd28_scan_en {
-		compatible = "thead,th1520-aon-pmic";
+		compatible = "xuantie,th1520-aon-pmic";
 		regulator-name = "soc_avdd28_scan_en";
 		regulator-type = "common";
 		regulator-min-microvolt = <900000>;
--- a/arch/riscv/boot/dts/thead/th1520-lichee-pi-4a.dts
+++ b/arch/riscv/boot/dts/thead/th1520-lichee-pi-4a.dts
@@ -172,7 +172,7 @@
 	};
 
 	mbox_910t_client2: mbox_910t_client2 {
-		compatible = "thead,th1520-mbox-client";
+		compatible = "xuantie,th1520-mbox-client";
 		mbox-names = "906";
 		mboxes = <&mbox_910t 2 0>;
 		audio-mbox-regmap = <&audio_mbox>;
--- a/arch/riscv/boot/dts/thead/th1520.dtsi
+++ b/arch/riscv/boot/dts/thead/th1520.dtsi
@@ -12,8 +12,8 @@
 #include <dt-bindings/clock/th1520-dspsys.h>
 #include <dt-bindings/clock/th1520-audiosys.h>
 #include <dt-bindings/clock/th1520-miscsys.h>
-#include <dt-bindings/reset/thead,th1520-reset.h>
-#include <dt-bindings/firmware/thead/rsrc.h>
+#include <dt-bindings/reset/xuantie,th1520-reset.h>
+#include <dt-bindings/firmware/xuantie/rsrc.h>
 
 / {
 	compatible = "thead,th1520";
@@ -306,13 +306,13 @@
 	};
 
 	aon: aon_subsys {
-		compatible = "thead,th1520-aon";
+		compatible = "xuantie,th1520-aon";
 		mbox-names = "aon";
 		mboxes = <&mbox_910t 1 0>;
 		status = "okay";
 
 		pd: th1520-aon-pd {
-			compatible = "thead,th1520-aon-pd";
+			compatible = "xuantie,th1520-aon-pd";
 			#power-domain-cells = <1>;
 		};
 
@@ -551,7 +551,7 @@
 		};
 
 		gmac0: ethernet@ffe7070000 {
-			compatible = "thead,th1520-dwmac";
+			compatible = "xuantie,th1520-dwmac";
 			reg = <0xff 0xe7070000 0x0 0x2000>;
 			interrupts = <66 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "macirq";
@@ -565,7 +565,7 @@
 			snps,multicast-filter-bins = <64>;
 			snps,perfect-filter-entries = <32>;
 			snps,axi-config = <&stmmac_axi_config>;
-			thead,gmacapb = <&gmac0_apb>;
+			th1520,gmacapb = <&gmac0_apb>;
 			status = "disabled";
 
 			mdio0: mdio {
@@ -576,7 +576,7 @@
 		};
 
 		gmac1: ethernet@ffe7060000 {
-			compatible = "thead,th1520-dwmac";
+			compatible = "xuantie,th1520-dwmac";
 			reg = <0xff 0xe7060000 0x0 0x2000>;
 			interrupts = <67 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "macirq";
@@ -590,7 +590,7 @@
 			snps,multicast-filter-bins = <64>;
 			snps,perfect-filter-entries = <32>;
 			snps,axi-config = <&stmmac_axi_config>;
-			thead,gmacapb = <&gmac1_apb>;
+			th1520,gmacapb = <&gmac1_apb>;
 			status = "disabled";
 
 			mdio1: mdio {
@@ -711,7 +711,7 @@
 		};
 
 		audio_mbox: audio_mbox@0xffefc48000 {
-			compatible = "thead,th1520-audio-mbox-reg", "syscon";
+			compatible = "xuantie,th1520-audio-mbox-reg", "syscon";
 			reg = <0xff 0xefc48000 0x0 0x1000>;
 			status = "okay";
 		};
@@ -761,12 +761,12 @@
 		};
 
 		gmac0_apb: syscon@ffec003000 {
-			compatible = "thead,th1520-gmac-apb", "syscon";
+			compatible = "xuantie,th1520-gmac-apb", "syscon";
 			reg = <0xff 0xec003000 0x0 0x1000>;
 		};
 
 		gmac1_apb: syscon@ffec004000 {
-			compatible = "thead,th1520-gmac-apb", "syscon";
+			compatible = "xuantie,th1520-gmac-apb", "syscon";
 			reg = <0xff 0xec004000 0x0 0x1000>;
 		};
 
@@ -815,22 +815,22 @@
 		};
 
 		pwm: pwm@ffec01c000 {
-			compatible = "thead,th1520-pwm";
+			compatible = "xuantie,th1520-pwm";
 			reg = <0xff 0xec01c000 0x0 0x4000>;
 			#pwm-cells = <3>;
 			clocks = <&osc>;
 		};
 
 		misc_sysreg: misc_sysreg@ffec02c000 {
-			compatible = "thead,th1520-misc-sysreg", "syscon";
+			compatible = "xuantie,th1520-misc-sysreg", "syscon";
 			reg = <0xff 0xec02c000 0x0 0x1000>;
 		};
 
 		usb: usb@ffec03f000 {
-			compatible = "thead,th1520-usb";
+			compatible = "xuantie,th1520-usb";
 			usb3-misc-regmap = <&misc_sysreg>;
 			reg = <0xff 0xec03f000 0x0 0x1000>;
-			thead,misc-sysreg = <&misc_sysreg>;
+			xuantie,misc-sysreg = <&misc_sysreg>;
 			clocks = <&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_CLK>,
 					<&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_CTRL_REF_CLK>,
 					<&miscsys_clk_gate CLKGEN_MISCSYS_USB3_DRD_PHY_REF_CLK>,
@@ -902,7 +902,7 @@
 		};
 
 		emmc: mmc@ffe7080000 {
-			compatible = "thead,th1520-dwcmshc";
+			compatible = "xuantie,th1520-dwcmshc";
 			reg = <0xff 0xe7080000 0x0 0x10000>;
 			interrupts = <62 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&sdhci_clk>;
@@ -911,7 +911,7 @@
 		};
 
 		sdio0: mmc@ffe7090000 {
-			compatible = "thead,th1520-dwcmshc";
+			compatible = "xuantie,th1520-dwcmshc";
 			reg = <0xff 0xe7090000 0x0 0x10000>;
 			interrupts = <64 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&sdhci_clk>;
@@ -920,7 +920,7 @@
 		};
 
 		sdio1: mmc@ffe70a0000 {
-			compatible = "thead,th1520-dwcmshc";
+			compatible = "xuantie,th1520-dwcmshc";
 			reg = <0xff 0xe70a0000 0x0 0x10000>;
 			interrupts = <71 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&sdhci_clk>;
@@ -1095,7 +1095,7 @@
 		};
 
 		adc: adc@0xfffff51000 {
-			compatible = "thead,th1520-adc";
+			compatible = "xuantie,th1520-adc";
 			reg = <0xff 0xfff51000 0x0 0x1000>;
 			interrupts = <61 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&aonsys_clk>;
@@ -1105,7 +1105,7 @@
 		};
 
 		visys_reg: visys-reg@ffe4040000 {
-			compatible = "thead,th1520-visys-reg", "syscon";
+			compatible = "xuantie,th1520-visys-reg", "syscon";
 			reg = <0xff 0xe4040000 0x0 0x1000>;
 			status = "disabled";
 		};
@@ -1237,8 +1237,8 @@
 		};
 
 		aon_suspend_ctrl: aon_suspend_ctrl {
-		        compatible = "thead,th1520-aon-suspend-ctrl";
-		        status = "okay";
+			compatible = "xuantie,th1520-aon-suspend-ctrl";
+			status = "okay";
 		};
 
 		sys_reg: sys-reg@ffef010100 {
@@ -1248,31 +1248,31 @@
 		};
 
 		dspsys_reg: dspsys-reg@ffef040000 {
-			compatible = "thead,th1520-dspsys-reg", "syscon";
+			compatible = "xuantie,th1520-dspsys-reg", "syscon";
 			reg = <0xff 0xef040000 0x0 0x1000>;
 			status = "okay";
 		};
 
 		miscsys_reg: miscsys-reg@ffec02c000 {
-			compatible = "thead,th1520-miscsys-reg", "syscon";
+			compatible = "xuantie,th1520-miscsys-reg", "syscon";
 			reg = <0xff 0xec02c000 0x0 0x1000>;
 			status = "okay";
 		};
  
 		tee_miscsys_reg: tee_miscsys-reg@fffc02d000 {
-			compatible = "thead,th1520-miscsys-reg", "syscon";
+			compatible = "xuantie,th1520-miscsys-reg", "syscon";
 			reg = <0xff 0xfc02d000 0x0 0x1000>;
 			status = "okay";
 		};
 
 		audio_cpr: audio_cpr@ffcb000000 {
-			compatible = "thead,th1520-audio-cpr-reg", "syscon";
+			compatible = "xuantie,th1520-audio-cpr-reg", "syscon";
 			reg = <0xff 0xcb000000 0x0 0x1000>;
 			status = "okay";
 		};
 
 		clk: clock-controller@ffef010000 {
-			compatible = "thead,th1520-fm-ree-clk";
+			compatible = "xuantie,th1520-fm-ree-clk";
 			reg = <0xff 0xef010000 0x0 0x1000>;
 			#clock-cells = <1>;
 			clocks = <&osc_32k>, <&osc>, <&rc_24m>;
@@ -1281,42 +1281,42 @@
 		};
 
 		visys_clk_gate: visys-clk-gate { /* VI_SYSREG_R */
-			compatible = "thead,visys-gate-controller";
+			compatible = "xuantie,visys-gate-controller";
 			visys-regmap = <&visys_reg>;
 			#clock-cells = <1>;
 			status = "okay";
 		};
 
 		vpsys_clk_gate: vpsys-clk-gate@ffecc30000 { /* VP_SYSREG_R */
-			compatible = "thead,vpsys-gate-controller";
+			compatible = "xuantie,vpsys-gate-controller";
 			reg = <0xff 0xecc30000 0x0 0x1000>;
 			#clock-cells = <1>;
 			status = "okay";
 		};
 
 		vosys_clk_gate: vosys-clk-gate@ffef528000 { /* VO_SYSREG_R */
-			compatible = "thead,vosys-gate-controller";
+			compatible = "xuantie,vosys-gate-controller";
 			reg = <0xff 0xef528000 0x0 0x1000>;
 			#clock-cells = <1>;
 			status = "okay";
 		};
 
 		dspsys_clk_gate: dspsys-clk-gate {
-			compatible = "thead,dspsys-gate-controller";
+			compatible = "xuantie,dspsys-gate-controller";
 			dspsys-regmap = <&dspsys_reg>;
 			#clock-cells = <1>;
 			status = "okay";
 		};
 
 		audiosys_clk_gate: audiosys-clk-gate {
-			compatible = "thead,audiosys-gate-controller";
+			compatible = "xuantie,audiosys-gate-controller";
 			audiosys-regmap = <&audio_cpr>;
 			#clock-cells = <1>;
 			status = "okay";
 		};
 
 		miscsys_clk_gate: miscsys-clk-gate {
-			compatible = "thead,miscsys-gate-controller";
+			compatible = "xuantie,miscsys-gate-controller";
 			miscsys-regmap = <&miscsys_reg>;
 			tee-miscsys-regmap = <&tee_miscsys_reg>;
 			#clock-cells = <1>;
@@ -1381,7 +1381,7 @@
 		};
 
 		th1520_event: th1520-event {
-			compatible = "thead,th1520-event";
+			compatible = "xuantie,th1520-event";
 			aon-iram-regmap = <&aon_iram>;
 			status = "okay";
 		};
--- a/arch/riscv/configs/defconfig
+++ /dev/null
@@ -1,247 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_NO_HZ_IDLE=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_BPF_SYSCALL=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_CGROUPS=y
-CONFIG_MEMCG=y
-CONFIG_CGROUP_SCHED=y
-CONFIG_CFS_BANDWIDTH=y
-CONFIG_RT_GROUP_SCHED=y
-CONFIG_CGROUP_PIDS=y
-CONFIG_CGROUP_FREEZER=y
-CONFIG_CGROUP_HUGETLB=y
-CONFIG_CPUSETS=y
-CONFIG_CGROUP_DEVICE=y
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_CGROUP_PERF=y
-CONFIG_CGROUP_BPF=y
-CONFIG_NAMESPACES=y
-CONFIG_USER_NS=y
-CONFIG_CHECKPOINT_RESTORE=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_EXPERT=y
-# CONFIG_SYSFS_SYSCALL is not set
-CONFIG_PROFILING=y
-CONFIG_SOC_MICROCHIP_POLARFIRE=y
-CONFIG_ARCH_RENESAS=y
-CONFIG_ARCH_THEAD=y
-CONFIG_ARCH_XUANTIE=y
-CONFIG_SOC_SIFIVE=y
-CONFIG_SOC_STARFIVE=y
-CONFIG_ARCH_SUNXI=y
-CONFIG_SOC_VIRT=y
-CONFIG_SMP=y
-CONFIG_HOTPLUG_CPU=y
-CONFIG_PM=y
-CONFIG_CPU_IDLE=y
-CONFIG_VIRTUALIZATION=y
-CONFIG_KVM=m
-CONFIG_ACPI=y
-CONFIG_JUMP_LABEL=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_SPARSEMEM_MANUAL=y
-CONFIG_BLK_DEV_THROTTLING=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_XFRM_USER=m
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-CONFIG_INET_ESP=m
-CONFIG_NETFILTER=y
-CONFIG_BRIDGE_NETFILTER=m
-CONFIG_NF_CONNTRACK=m
-CONFIG_NF_CONNTRACK_FTP=m
-CONFIG_NF_CONNTRACK_TFTP=m
-CONFIG_NETFILTER_XT_MARK=m
-CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
-CONFIG_NETFILTER_XT_MATCH_IPVS=m
-CONFIG_IP_VS=m
-CONFIG_IP_VS_PROTO_TCP=y
-CONFIG_IP_VS_PROTO_UDP=y
-CONFIG_IP_VS_RR=m
-CONFIG_IP_VS_NFCT=y
-CONFIG_NF_LOG_ARP=m
-CONFIG_NF_LOG_IPV4=m
-CONFIG_IP_NF_IPTABLES=m
-CONFIG_IP_NF_FILTER=m
-CONFIG_IP_NF_TARGET_REJECT=m
-CONFIG_IP_NF_NAT=m
-CONFIG_IP_NF_TARGET_MASQUERADE=m
-CONFIG_IP_NF_TARGET_REDIRECT=m
-CONFIG_IP_NF_MANGLE=m
-CONFIG_NF_LOG_IPV6=m
-CONFIG_IP6_NF_IPTABLES=m
-CONFIG_IP6_NF_MATCH_IPV6HEADER=m
-CONFIG_IP6_NF_FILTER=m
-CONFIG_IP6_NF_TARGET_REJECT=m
-CONFIG_IP6_NF_MANGLE=m
-CONFIG_BRIDGE=m
-CONFIG_BRIDGE_VLAN_FILTERING=y
-CONFIG_VLAN_8021Q=m
-CONFIG_NET_SCHED=y
-CONFIG_NET_CLS_CGROUP=m
-CONFIG_NETLINK_DIAG=y
-CONFIG_CGROUP_NET_PRIO=y
-CONFIG_NET_9P=y
-CONFIG_NET_9P_VIRTIO=y
-CONFIG_PCI=y
-CONFIG_PCIEPORTBUS=y
-CONFIG_PCI_HOST_GENERIC=y
-CONFIG_PCIE_XILINX=y
-CONFIG_PCIE_FU740=y
-CONFIG_DEVTMPFS=y
-CONFIG_DEVTMPFS_MOUNT=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_VIRTIO_BLK=y
-CONFIG_BLK_DEV_NVME=m
-CONFIG_BLK_DEV_SD=y
-CONFIG_BLK_DEV_SR=y
-CONFIG_SCSI_VIRTIO=y
-CONFIG_ATA=y
-CONFIG_SATA_AHCI=y
-CONFIG_SATA_AHCI_PLATFORM=y
-CONFIG_MD=y
-CONFIG_BLK_DEV_DM=m
-CONFIG_DM_THIN_PROVISIONING=m
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=m
-CONFIG_MACVLAN=m
-CONFIG_IPVLAN=m
-CONFIG_VXLAN=m
-CONFIG_VETH=m
-CONFIG_VIRTIO_NET=y
-CONFIG_MACB=y
-CONFIG_E1000E=y
-CONFIG_R8169=y
-CONFIG_STMMAC_ETH=m
-CONFIG_MICROSEMI_PHY=y
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_KEYBOARD_SUN4I_LRADC=m
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_DW=y
-CONFIG_SERIAL_OF_PLATFORM=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_VIRTIO_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_HW_RANDOM_VIRTIO=y
-CONFIG_I2C_MV64XXX=m
-CONFIG_SPI=y
-CONFIG_SPI_SIFIVE=y
-CONFIG_SPI_SUN6I=y
-# CONFIG_PTP_1588_CLOCK is not set
-CONFIG_GPIO_SIFIVE=y
-CONFIG_WATCHDOG=y
-CONFIG_SUNXI_WATCHDOG=y
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_FIXED_VOLTAGE=y
-CONFIG_DRM=m
-CONFIG_DRM_RADEON=m
-CONFIG_DRM_NOUVEAU=m
-CONFIG_DRM_SUN4I=m
-CONFIG_DRM_VIRTIO_GPU=m
-CONFIG_FB=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_USB=y
-CONFIG_USB_XHCI_HCD=y
-CONFIG_USB_XHCI_PLATFORM=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_HCD_PLATFORM=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_HCD_PLATFORM=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_UAS=y
-CONFIG_USB_MUSB_HDRC=m
-CONFIG_USB_MUSB_SUNXI=m
-CONFIG_NOP_USB_XCEIV=m
-CONFIG_MMC=y
-CONFIG_MMC_SDHCI=y
-CONFIG_MMC_SDHCI_PLTFM=y
-CONFIG_MMC_SDHCI_CADENCE=y
-CONFIG_MMC_SDHCI_OF_DWCMSHC=y
-CONFIG_MMC_SPI=y
-CONFIG_MMC_SUNXI=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SUN6I=y
-CONFIG_DMADEVICES=y
-CONFIG_DMA_SUN6I=m
-CONFIG_DW_AXI_DMAC=y
-CONFIG_VIRTIO_PCI=y
-CONFIG_VIRTIO_BALLOON=y
-CONFIG_VIRTIO_INPUT=y
-CONFIG_VIRTIO_MMIO=y
-CONFIG_SUN8I_DE2_CCU=m
-CONFIG_SUN50I_IOMMU=y
-CONFIG_MAILBOX=y
-CONFIG_RPMSG_CHAR=y
-CONFIG_RPMSG_CTRL=y
-CONFIG_RPMSG_VIRTIO=y
-CONFIG_RPMSG_TH1520=y
-CONFIG_ARCH_R9A07G043=y
-CONFIG_PHY_SUN4I_USB=m
-CONFIG_LIBNVDIMM=y
-CONFIG_NVMEM_SUNXI_SID=y
-CONFIG_EXT4_FS=y
-CONFIG_EXT4_FS_POSIX_ACL=y
-CONFIG_EXT4_FS_SECURITY=y
-CONFIG_BTRFS_FS=m
-CONFIG_BTRFS_FS_POSIX_ACL=y
-CONFIG_AUTOFS_FS=y
-CONFIG_OVERLAY_FS=m
-CONFIG_ISO9660_FS=y
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_HUGETLBFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V4=y
-CONFIG_NFS_V4_1=y
-CONFIG_NFS_V4_2=y
-CONFIG_ROOT_NFS=y
-CONFIG_9P_FS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ISO8859_1=m
-CONFIG_SECURITY=y
-CONFIG_SECURITY_SELINUX=y
-CONFIG_SECURITY_APPARMOR=y
-CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_CRYPTO_USER_API_HASH=y
-CONFIG_CRYPTO_DEV_VIRTIO=y
-CONFIG_PRINTK_TIME=y
-CONFIG_DEBUG_FS=y
-CONFIG_DEBUG_PAGEALLOC=y
-CONFIG_SCHED_STACK_END_CHECK=y
-CONFIG_DEBUG_VM=y
-CONFIG_DEBUG_VM_PGFLAGS=y
-CONFIG_DEBUG_MEMORY_INIT=y
-CONFIG_DEBUG_PER_CPU_MAPS=y
-CONFIG_SOFTLOCKUP_DETECTOR=y
-CONFIG_WQ_WATCHDOG=y
-CONFIG_DEBUG_TIMEKEEPING=y
-CONFIG_DEBUG_RT_MUTEXES=y
-CONFIG_DEBUG_SPINLOCK=y
-CONFIG_DEBUG_MUTEXES=y
-CONFIG_DEBUG_RWSEMS=y
-CONFIG_DEBUG_ATOMIC_SLEEP=y
-CONFIG_DEBUG_LIST=y
-CONFIG_DEBUG_PLIST=y
-CONFIG_DEBUG_SG=y
-# CONFIG_RCU_TRACE is not set
-CONFIG_RCU_EQS_DEBUG=y
-# CONFIG_FTRACE is not set
-# CONFIG_RUNTIME_TESTING_MENU is not set
-CONFIG_MEMTEST=y
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -501,6 +501,7 @@ source "drivers/clk/visconti/Kconfig"
 source "drivers/clk/x86/Kconfig"
 source "drivers/clk/xilinx/Kconfig"
 source "drivers/clk/zynqmp/Kconfig"
+source "drivers/clk/xuantie/Kconfig"
 
 # Kunit test cases
 config CLK_KUNIT_TEST
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -136,4 +136,4 @@ endif
 obj-y					+= xilinx/
 obj-$(CONFIG_ARCH_ZYNQ)			+= zynq/
 obj-$(CONFIG_COMMON_CLK_ZYNQMP)         += zynqmp/
-obj-$(CONFIG_ARCH_XUANTIE)              += thead/
+obj-$(CONFIG_ARCH_XUANTIE)              += xuantie/
--- a/drivers/clk/thead/clk-th1520-fm.c
+++ /dev/null
@@ -1,648 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- */
-
-#include <dt-bindings/clock/th1520-fm-ap-clock.h>
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-
-#include "clk.h"
-
-static struct clk *clks[CLK_END];
-static struct clk_onecell_data clk_data;
-
-/* Th1520 Fullmask */
-static u32 share_cnt_x2h_cpusys_clk_en;
-static u32 share_cnt_dmac_cpusys_clk_en;
-static u32 share_cnt_timer0_clk_en;
-static u32 share_cnt_timer1_clk_en;
-static u32 share_cnt_axi4_cpusys2_clk_en;
-static u32 share_cnt_bmu_c910_clk_en;
-static u32 share_cnt_aon2cpu_a2x_clk_en;
-static u32 share_cnt_chip_dbg_clk_en;
-static u32 share_cnt_x2x_cpusys_clk_en;
-static u32 share_cnt_cfg2tee_x2h_clk_en;
-static u32 share_cnt_cpu2aon_x2h_clk_en;
-static u32 share_cnt_cpu2vp_x2p_clk_en;
-static u32 share_cnt_npu_core_clk_en;
-static u32 share_cnt_cpu2peri_x2h_clk_en;
-static u32 share_cnt_cpu2vi_x2h_clk_en;
-static u32 share_cnt_vpsys_axi_aclk_en;
-static u32 share_cnt_gmac1_clk_en;
-static u32 share_cnt_gmac0_clk_en;
-static u32 share_cnt_perisys_apb3_hclk_en;
-static u32 share_cnt_qspi0_clk_en;
-static u32 share_cnt_gmac_axi_clk_en;
-static u32 share_cnt_gpio0_clk_en;
-static u32 share_cnt_gpio1_clk_en;
-static u32 share_cnt_pwm_clk_en;
-static u32 share_cnt_spi_clk_en;
-static u32 share_cnt_uart0_clk_en;
-static u32 share_cnt_uart2_clk_en;
-static u32 share_cnt_i2c2_clk_en;
-static u32 share_cnt_i2c3_clk_en;
-static u32 share_cnt_peri_i2s_clk_en;
-static u32 share_cnt_qspi1_clk_en;
-static u32 share_cnt_uart1_clk_en;
-static u32 share_cnt_uart3_clk_en;
-static u32 share_cnt_uart4_clk_en;
-static u32 share_cnt_uart5_clk_en;
-static u32 share_cnt_i2c0_clk_en;
-static u32 share_cnt_i2c1_clk_en;
-static u32 share_cnt_i2c4_clk_en;
-static u32 share_cnt_i2c5_clk_en;
-static u32 share_cnt_gpio2_clk_en;
-static u32 share_cnt_gpio3_clk_en;
-static u32 share_cnt_vosys_axi_aclk_en;
-
-/* Th1520 Fullmask PLL Bypass */
-static const char * const cpu_pll0_bypass_sels[] = {"cpu_pll0_foutpostdiv", "osc_24m", };
-static const char * const cpu_pll1_bypass_sels[] = {"cpu_pll1_foutpostdiv", "osc_24m", };
-static const char * const gmac_pll_bypass_sels[] = {"gmac_pll_foutpostdiv", "osc_24m", };
-static const char * const video_pll_bypass_sels[] = {"video_pll_foutpostdiv", "osc_24m", };
-static const char * const tee_pll_bypass_sels[] = {"tee_pll_foutpostdiv", "osc_24m"};
-static const char * const dpu0_pll_bypass_sels[] = {"dpu0_pll_foutpostdiv", "osc_24m"};
-static const char * const dpu1_pll_bypass_sels[] = {"dpu1_pll_foutpostdiv", "osc_24m"};
-
-/* th1520 fullmask mux */
-static const char * const ahb2_cpusys_hclk_sels[] = {"ahb2_cpusys_hclk_out_div", "osc_24m"};
-static const char * const c910_cclk_i0_sels[] = {"cpu_pll0_foutpostdiv", "osc_24m"};
-static const char * const c910_cclk_sels[] = {"c910_cclk_i0", "cpu_pll1_foutpostdiv"};
-static const char * const cfg_axi_aclk_sels[] = {"cfg_axi_aclk_out_div", "osc_24m"};
-static const char * const teesys_hclk_sels[] = {"teesys_i1_hclk", "teesys_i0_hclk"};
-static const char * const perisys_ahb_hclk_sels[] = {"perisys_ahb_hclk_out_div", "osc_24m"};
-static const char * const clk_out_1_sels[] = {"osc_24m", "clk_out_1_out_div"};
-static const char * const clk_out_2_sels[] = {"osc_24m", "clk_out_2_out_div"};
-static const char * const clk_out_3_sels[] = {"osc_24m", "clk_out_3_out_div"};
-static const char * const clk_out_4_sels[] = {"osc_24m", "clk_out_4_out_div"};
-static const char * const peri_i2s_src_clk_sels[] = {"clkgen_peri_i2s_src_clk_0", "clkgen_peri_i2s_src_clk_1"};
-static const char * const npu_cclk_sels[] = {"gmac_pll_foutpostdiv", "npu_cclk_out_div"};
-static const char * const cfg_apb_pclk_sels[] = {"cfg_apb_pclk_out_div", "osc_24m"};
-static const char * const uart_sclk_sels[] = {"clk_100m", "osc_24m"};
-
-static const struct th1520_pll_rate_table th1520_cpupll_tbl[] = {
-	TH1520_PLL_RATE(2616000000U, 2616000000U, 1, 109, 0, 1, 1),
-	TH1520_PLL_RATE(2592000000U, 2592000000U, 1, 108, 0, 1, 1),
-	TH1520_PLL_RATE(2568000000U, 2568000000U, 1, 107, 0, 1, 1),
-	TH1520_PLL_RATE(2544000000U, 2544000000U, 1, 106, 0, 1, 1),
-	TH1520_PLL_RATE(2520000000U, 2520000000U, 1, 105, 0, 1, 1),
-	TH1520_PLL_RATE(2496000000U, 2496000000U, 1, 104, 0, 1, 1),
-	TH1520_PLL_RATE(2472000000U, 2472000000U, 1, 103, 0, 1, 1),
-	TH1520_PLL_RATE(2448000000U, 2448000000U, 1, 102, 0, 1, 1),
-	TH1520_PLL_RATE(2424000000U, 2424000000U, 1, 101, 0, 1, 1),
-	TH1520_PLL_RATE(2400000000U, 2400000000U, 1, 100, 0, 1, 1),
-	TH1520_PLL_RATE(2376000000U, 2376000000U, 1, 99,  0, 1, 1),
-	TH1520_PLL_RATE(2352000000U, 2352000000U, 1, 98,  0, 1, 1),
-	TH1520_PLL_RATE(2328000000U, 2328000000U, 1, 97,  0, 1, 1),
-	TH1520_PLL_RATE(2304000000U, 2304000000U, 1, 96,  0, 1, 1),
-	TH1520_PLL_RATE(2280000000U, 2280000000U, 1, 95,  0, 1, 1),
-	TH1520_PLL_RATE(2256000000U, 2256000000U, 1, 94,  0, 1, 1),
-	TH1520_PLL_RATE(2232000000U, 2232000000U, 1, 93,  0, 1, 1),
-	TH1520_PLL_RATE(2208000000U, 2208000000U, 1, 92,  0, 1, 1),
-	TH1520_PLL_RATE(2184000000U, 2184000000U, 1, 91,  0, 1, 1),
-	TH1520_PLL_RATE(2160000000U, 2160000000U, 1, 90,  0, 1, 1),
-	TH1520_PLL_RATE(2136000000U, 2136000000U, 1, 89,  0, 1, 1),
-	TH1520_PLL_RATE(2112000000U, 2112000000U, 1, 88,  0, 1, 1),
-	TH1520_PLL_RATE(2088000000U, 2088000000U, 1, 87,  0, 1, 1),
-	TH1520_PLL_RATE(2064000000U, 2064000000U, 1, 86,  0, 1, 1),
-	TH1520_PLL_RATE(2040000000U, 2040000000U, 1, 85,  0, 1, 1),
-	TH1520_PLL_RATE(2016000000U, 2016000000U, 1, 84,  0, 1, 1),
-	TH1520_PLL_RATE(1992000000U, 1992000000U, 1, 83,  0, 1, 1),
-	TH1520_PLL_RATE(1968000000U, 1968000000U, 1, 82,  0, 1, 1),
-	TH1520_PLL_RATE(1944000000U, 1944000000U, 1, 81,  0, 1, 1),
-	TH1520_PLL_RATE(1920000000U, 1920000000U, 1, 80,  0, 1, 1),
-	TH1520_PLL_RATE(1896000000U, 1896000000U, 1, 79,  0, 1, 1),
-	TH1520_PLL_RATE(1872000000U, 1872000000U, 1, 78,  0, 1, 1),
-	TH1520_PLL_RATE(1848000000U, 1848000000U, 1, 77,  0, 1, 1),
-	TH1520_PLL_RATE(1824000000U, 1824000000U, 1, 76,  0, 1, 1),
-	TH1520_PLL_RATE(1800000000U, 1800000000U, 1, 75,  0, 1, 1),
-	TH1520_PLL_RATE(1776000000U, 1776000000U, 1, 74,  0, 1, 1),
-	TH1520_PLL_RATE(1752000000U, 1752000000U, 1, 73,  0, 1, 1),
-	TH1520_PLL_RATE(1728000000U, 1728000000U, 1, 72,  0, 1, 1),
-	TH1520_PLL_RATE(1704000000U, 1704000000U, 1, 71,  0, 1, 1),
-	TH1520_PLL_RATE(1680000000U, 1680000000U, 1, 70,  0, 1, 1),
-	TH1520_PLL_RATE(1656000000U, 1656000000U, 1, 69,  0, 1, 1),
-	TH1520_PLL_RATE(1632000000U, 1632000000U, 1, 68,  0, 1, 1),
-	TH1520_PLL_RATE(1608000000U, 1608000000U, 1, 67,  0, 1, 1),
-	TH1520_PLL_RATE(1584000000U, 1584000000U, 1, 66,  0, 1, 1),
-	TH1520_PLL_RATE(1560000000U, 1560000000U, 1, 65,  0, 1, 1),
-	TH1520_PLL_RATE(1536000000U, 1536000000U, 1, 64,  0, 1, 1),
-	TH1520_PLL_RATE(1512000000U, 1512000000U, 1, 63,  0, 1, 1),
-	TH1520_PLL_RATE(3000000000U, 1500000000U, 1, 125, 0, 2, 1),
-	TH1520_PLL_RATE(2976000000U, 1488000000U, 1, 124, 0, 2, 1),
-	TH1520_PLL_RATE(2952000000U, 1476000000U, 1, 123, 0, 2, 1),
-	TH1520_PLL_RATE(2928000000U, 1464000000U, 1, 122, 0, 2, 1),
-	TH1520_PLL_RATE(2904000000U, 1452000000U, 1, 121, 0, 2, 1),
-	TH1520_PLL_RATE(2880000000U, 1440000000U, 1, 120, 0, 2, 1),
-	TH1520_PLL_RATE(2856000000U, 1428000000U, 1, 119, 0, 2, 1),
-	TH1520_PLL_RATE(2832000000U, 1416000000U, 1, 118, 0, 2, 1),
-	TH1520_PLL_RATE(2808000000U, 1404000000U, 1, 117, 0, 2, 1),
-	TH1520_PLL_RATE(2784000000U, 1392000000U, 1, 116, 0, 2, 1),
-	TH1520_PLL_RATE(2760000000U, 1380000000U, 1, 115, 0, 2, 1),
-	TH1520_PLL_RATE(2736000000U, 1368000000U, 1, 114, 0, 2, 1),
-	TH1520_PLL_RATE(2712000000U, 1356000000U, 1, 113, 0, 2, 1),
-	TH1520_PLL_RATE(2688000000U, 1344000000U, 1, 112, 0, 2, 1),
-	TH1520_PLL_RATE(2664000000U, 1332000000U, 1, 111, 0, 2, 1),
-	TH1520_PLL_RATE(2640000000U, 1320000000U, 1, 110, 0, 2, 1),
-	TH1520_PLL_RATE(2616000000U, 1308000000U, 1, 109, 0, 2, 1),
-	TH1520_PLL_RATE(2592000000U, 1296000000U, 1, 108, 0, 2, 1),
-	TH1520_PLL_RATE(2568000000U, 1284000000U, 1, 107, 0, 2, 1),
-	TH1520_PLL_RATE(2544000000U, 1272000000U, 1, 106, 0, 2, 1),
-	TH1520_PLL_RATE(2520000000U, 1260000000U, 1, 105, 0, 2, 1),
-	TH1520_PLL_RATE(2496000000U, 1248000000U, 1, 104, 0, 2, 1),
-	TH1520_PLL_RATE(2472000000U, 1236000000U, 1, 103, 0, 2, 1),
-	TH1520_PLL_RATE(2448000000U, 1224000000U, 1, 102, 0, 2, 1),
-	TH1520_PLL_RATE(2424000000U, 1212000000U, 1, 101, 0, 2, 1),
-	TH1520_PLL_RATE(2400000000U, 1200000000U, 1, 100, 0, 2, 1),
-	TH1520_PLL_RATE(2376000000U, 1188000000U, 1, 99,  0, 2, 1),
-	TH1520_PLL_RATE(2352000000U, 1176000000U, 1, 98,  0, 2, 1),
-	TH1520_PLL_RATE(2328000000U, 1164000000U, 1, 97,  0, 2, 1),
-	TH1520_PLL_RATE(2304000000U, 1152000000U, 1, 96,  0, 2, 1),
-	TH1520_PLL_RATE(2280000000U, 1140000000U, 1, 95,  0, 2, 1),
-	TH1520_PLL_RATE(2256000000U, 1128000000U, 1, 94,  0, 2, 1),
-	TH1520_PLL_RATE(2232000000U, 1116000000U, 1, 93,  0, 2, 1),
-	TH1520_PLL_RATE(2208000000U, 1104000000U, 1, 92,  0, 2, 1),
-	TH1520_PLL_RATE(2184000000U, 1092000000U, 1, 91,  0, 2, 1),
-	TH1520_PLL_RATE(2160000000U, 1080000000U, 1, 90,  0, 2, 1),
-	TH1520_PLL_RATE(2136000000U, 1068000000U, 1, 89,  0, 2, 1),
-	TH1520_PLL_RATE(2112000000U, 1056000000U, 1, 88,  0, 2, 1),
-	TH1520_PLL_RATE(2088000000U, 1044000000U, 1, 87,  0, 2, 1),
-	TH1520_PLL_RATE(2064000000U, 1032000000U, 1, 86,  0, 2, 1),
-	TH1520_PLL_RATE(2040000000U, 1020000000U, 1, 85,  0, 2, 1),
-	TH1520_PLL_RATE(2016000000U, 1008000000U, 1, 84,  0, 2, 1),
-	TH1520_PLL_RATE(3000000000U, 1000000000U, 1, 125, 0, 3, 1),
-	TH1520_PLL_RATE(2976000000U, 992000000U,  1, 124, 0, 3, 1),
-	TH1520_PLL_RATE(2952000000U, 984000000U,  1, 123, 0, 3, 1),
-	TH1520_PLL_RATE(2928000000U, 976000000U,  1, 122, 0, 3, 1),
-	TH1520_PLL_RATE(2904000000U, 968000000U,  1, 121, 0, 3, 1),
-	TH1520_PLL_RATE(2880000000U, 960000000U,  1, 120, 0, 3, 1),
-	TH1520_PLL_RATE(2856000000U, 952000000U,  1, 119, 0, 3, 1),
-	TH1520_PLL_RATE(2832000000U, 944000000U,  1, 118, 0, 3, 1),
-	TH1520_PLL_RATE(2808000000U, 936000000U,  1, 117, 0, 3, 1),
-	TH1520_PLL_RATE(2784000000U, 928000000U,  1, 116, 0, 3, 1),
-	TH1520_PLL_RATE(2760000000U, 920000000U,  1, 115, 0, 3, 1),
-	TH1520_PLL_RATE(2736000000U, 912000000U,  1, 114, 0, 3, 1),
-	TH1520_PLL_RATE(2712000000U, 904000000U,  1, 113, 0, 3, 1),
-	TH1520_PLL_RATE(1800000000U, 900000000U,  1, 75,  0, 2, 1),
-	TH1520_PLL_RATE(2688000000U, 896000000U,  1, 112, 0, 3, 1),
-	TH1520_PLL_RATE(2664000000U, 888000000U,  1, 111, 0, 3, 1),
-	TH1520_PLL_RATE(2640000000U, 880000000U,  1, 110, 0, 3, 1),
-	TH1520_PLL_RATE(2616000000U, 872000000U,  1, 109, 0, 3, 1),
-	TH1520_PLL_RATE(2592000000U, 864000000U,  1, 108, 0, 3, 1),
-	TH1520_PLL_RATE(2568000000U, 856000000U,  1, 107, 0, 3, 1),
-	TH1520_PLL_RATE(2544000000U, 848000000U,  1, 106, 0, 3, 1),
-	TH1520_PLL_RATE(2520000000U, 840000000U,  1, 105, 0, 3, 1),
-	TH1520_PLL_RATE(2496000000U, 832000000U,  1, 104, 0, 3, 1),
-	TH1520_PLL_RATE(2472000000U, 824000000U,  1, 103, 0, 3, 1),
-	TH1520_PLL_RATE(2448000000U, 816000000U,  1, 102, 0, 3, 1),
-	TH1520_PLL_RATE(2424000000U, 808000000U,  1, 101, 0, 3, 1),
-	TH1520_PLL_RATE(2400000000U, 800000000U,  1, 100, 0, 3, 1),
-	TH1520_PLL_RATE(2376000000U, 792000000U,  1, 99,  0, 3, 1),
-	TH1520_PLL_RATE(2352000000U, 784000000U,  1, 98,  0, 3, 1),
-	TH1520_PLL_RATE(2328000000U, 776000000U,  1, 97,  0, 3, 1),
-	TH1520_PLL_RATE(2304000000U, 768000000U,  1, 96,  0, 3, 1),
-	TH1520_PLL_RATE(2280000000U, 760000000U,  1, 95,  0, 3, 1),
-	TH1520_PLL_RATE(2256000000U, 752000000U,  1, 94,  0, 3, 1),
-	TH1520_PLL_RATE(2232000000U, 744000000U,  1, 93,  0, 3, 1),
-	TH1520_PLL_RATE(2208000000U, 736000000U,  1, 92,  0, 3, 1),
-	TH1520_PLL_RATE(2184000000U, 728000000U,  1, 91,  0, 3, 1),
-	TH1520_PLL_RATE(2160000000U, 720000000U,  1, 90,  0, 3, 1),
-	TH1520_PLL_RATE(2136000000U, 712000000U,  1, 89,  0, 3, 1),
-	TH1520_PLL_RATE(2808000000U, 702000000U,  1, 117, 0, 4, 1),
-	TH1520_PLL_RATE(2760000000U, 690000000U,  1, 115, 0, 4, 1),
-	TH1520_PLL_RATE(2712000000U, 678000000U,  1, 113, 0, 4, 1),
-	TH1520_PLL_RATE(2664000000U, 666000000U,  1, 111, 0, 4, 1),
-	TH1520_PLL_RATE(2616000000U, 654000000U,  1, 109, 0, 4, 1),
-	TH1520_PLL_RATE(2568000000U, 642000000U,  1, 107, 0, 4, 1),
-	TH1520_PLL_RATE(2520000000U, 630000000U,  1, 105, 0, 4, 1),
-	TH1520_PLL_RATE(2472000000U, 618000000U,  1, 103, 0, 4, 1),
-	TH1520_PLL_RATE(2424000000U, 606000000U,  1, 101, 0, 4, 1),
-	TH1520_PLL_RATE(3000000000U, 600000000U,  1, 125, 0, 5, 1),
-	TH1520_PLL_RATE(2952000000U, 590400000U,  1, 123, 0, 5, 1),
-	TH1520_PLL_RATE(2904000000U, 580800000U,  1, 121, 0, 5, 1),
-	TH1520_PLL_RATE(2856000000U, 571200000U,  1, 119, 0, 5, 1),
-	TH1520_PLL_RATE(2808000000U, 561600000U,  1, 117, 0, 5, 1),
-	TH1520_PLL_RATE(2760000000U, 552000000U,  1, 115, 0, 5, 1),
-	TH1520_PLL_RATE(2712000000U, 542400000U,  1, 113, 0, 5, 1),
-	TH1520_PLL_RATE(2664000000U, 532800000U,  1, 111, 0, 5, 1),
-	TH1520_PLL_RATE(2616000000U, 523200000U,  1, 109, 0, 5, 1),
-	TH1520_PLL_RATE(2568000000U, 513600000U,  1, 107, 0, 5, 1),
-	TH1520_PLL_RATE(2520000000U, 504000000U,  1, 105, 0, 5, 1),
-	TH1520_PLL_RATE(3000000000U, 500000000U,  1, 125, 0, 6, 1),
-	TH1520_PLL_RATE(2952000000U, 492000000U,  1, 123, 0, 6, 1),
-	TH1520_PLL_RATE(2904000000U, 484000000U,  1, 121, 0, 6, 1),
-	TH1520_PLL_RATE(2856000000U, 476000000U,  1, 119, 0, 6, 1),
-	TH1520_PLL_RATE(2808000000U, 468000000U,  1, 117, 0, 6, 1),
-	TH1520_PLL_RATE(2760000000U, 460000000U,  1, 115, 0, 6, 1),
-	TH1520_PLL_RATE(2712000000U, 452000000U,  1, 113, 0, 6, 1),
-	TH1520_PLL_RATE(2664000000U, 444000000U,  1, 111, 0, 6, 1),
-	TH1520_PLL_RATE(2616000000U, 436000000U,  1, 109, 0, 6, 1),
-	TH1520_PLL_RATE(2568000000U, 428000000U,  1, 107, 0, 6, 1),
-	TH1520_PLL_RATE(2520000000U, 420000000U,  1, 105, 0, 6, 1),
-	TH1520_PLL_RATE(2472000000U, 412000000U,  1, 103, 0, 6, 1),
-	TH1520_PLL_RATE(2400000000U, 400000000U,  1, 100, 0, 3, 2),
-	TH1520_PLL_RATE(2352000000U, 392000000U,  1, 98,  0, 3, 2),
-	TH1520_PLL_RATE(2304000000U, 384000000U,  1, 96,  0, 3, 2),
-	TH1520_PLL_RATE(2256000000U, 376000000U,  1, 94,  0, 3, 2),
-	TH1520_PLL_RATE(2208000000U, 368000000U,  1, 92,  0, 3, 2),
-	TH1520_PLL_RATE(2160000000U, 360000000U,  1, 90,  0, 3, 2),
-	TH1520_PLL_RATE(2112000000U, 352000000U,  1, 88,  0, 3, 2),
-	TH1520_PLL_RATE(2064000000U, 344000000U,  1, 86,  0, 3, 2),
-	TH1520_PLL_RATE(2016000000U, 336000000U,  1, 84,  0, 3, 2),
-	TH1520_PLL_RATE(1968000000U, 328000000U,  1, 82,  0, 3, 2),
-	TH1520_PLL_RATE(1920000000U, 320000000U,  1, 80,  0, 3, 2),
-	TH1520_PLL_RATE(1872000000U, 312000000U,  1, 78,  0, 3, 2),
-	TH1520_PLL_RATE(1824000000U, 304000000U,  1, 76,  0, 3, 2),
-	TH1520_PLL_RATE(3000000000U, 300000000U,  1, 125, 0, 5, 2),
-	TH1520_PLL_RATE(2880000000U, 288000000U,  1, 120, 0, 5, 2),
-	TH1520_PLL_RATE(2760000000U, 276000000U,  1, 115, 0, 5, 2),
-	TH1520_PLL_RATE(2640000000U, 264000000U,  1, 110, 0, 5, 2),
-	TH1520_PLL_RATE(2520000000U, 252000000U,  1, 105, 0, 5, 2),
-	TH1520_PLL_RATE(2400000000U, 240000000U,  1, 100, 0, 5, 2),
-	TH1520_PLL_RATE(2280000000U, 228000000U,  1, 95,  0, 5, 2),
-	TH1520_PLL_RATE(2160000000U, 216000000U,  1, 90,  0, 5, 2),
-	TH1520_PLL_RATE(2040000000U, 204000000U,  1, 85,  0, 5, 2),
-	TH1520_PLL_RATE(3000000000U, 200000000U,  1, 125, 0, 5, 3),
-	TH1520_PLL_RATE(2880000000U, 192000000U,  1, 120, 0, 5, 3),
-	TH1520_PLL_RATE(2760000000U, 184000000U,  1, 115, 0, 5, 3),
-	TH1520_PLL_RATE(2640000000U, 176000000U,  1, 110, 0, 5, 3),
-	TH1520_PLL_RATE(2520000000U, 168000000U,  1, 105, 0, 5, 3),
-	TH1520_PLL_RATE(2400000000U, 160000000U,  1, 100, 0, 5, 3),
-	TH1520_PLL_RATE(2280000000U, 152000000U,  1, 95,  0, 5, 3),
-	TH1520_PLL_RATE(2160000000U, 144000000U,  1, 90,  0, 5, 3),
-	TH1520_PLL_RATE(2040000000U, 136000000U,  1, 85,  0, 5, 3),
-	TH1520_PLL_RATE(1920000000U, 128000000U,  1, 80,  0, 5, 3),
-	TH1520_PLL_RATE(3000000000U, 125000000U,  1, 125, 0, 6, 4),
-	TH1520_PLL_RATE(2760000000U, 115000000U,  1, 115, 0, 6, 4),
-	TH1520_PLL_RATE(2520000000U, 105000000U,  1, 105, 0, 6, 4),
-	TH1520_PLL_RATE(2280000000U, 95000000U,   1, 95,  0, 6, 4),
-	TH1520_PLL_RATE(2040000000U, 85000000U,   1, 85,  0, 6, 4),
-	TH1520_PLL_RATE(1800000000U, 75000000U,   1, 75,  0, 6, 4),
-	TH1520_PLL_RATE(1560000000U, 65000000U,   1, 65,  0, 6, 4),
-	TH1520_PLL_RATE(1320000000U, 55000000U,   1, 55,  0, 6, 4),
-};
-
-static const struct th1520_pll_rate_table th1520_dpupll_tbl[] = {
-	TH1520_PLL_RATE(2376000000U, 1188000000U, 1, 99, 0, 2, 1),
-	TH1520_PLL_RATE(1980000000U, 990000000U, 2, 165, 0, 2, 1),
-	TH1520_PLL_RATE(2970000000U, 742500000U, 4, 495, 0, 4, 1),
-	TH1520_PLL_RATE(2304000000U, 1152000000U, 1, 96, 0, 2, 1),
-	TH1520_PLL_RATE(1512000000U, 504000000U, 1, 63, 0, 3, 1),
-	TH1520_PLL_RATE(1512000000U, 503500000U, 1, 63, 0, 3, 1),
-	TH1520_PLL_RATE(2898000000U, 483000000U, 4, 483, 0, 6, 1),
-	TH1520_PLL_RATE(2592000000U, 648000000U, 1, 108, 0, 4, 1),
-	TH1520_PLL_RATE(2772000000U, 924000000U, 2, 231, 0, 3, 1),
-	TH1520_PLL_RATE(2856000000U, 476000000U, 1, 119, 0, 6, 1),
-	TH1520_PLL_RATE(2130000000U, 355000000U, 4, 355, 0, 6, 1),
-	TH1520_PLL_RATE(3192000000U, 456000000U, 1, 133, 0, 7, 1),
-	TH1520_PLL_RATE(2730000000U, 390000000U, 4, 455, 0, 7, 1),
-	TH1520_PLL_RATE(1680000000U, 240000000U, 1, 70, 0, 7, 1),
-	TH1520_PLL_RATE(2832000000U, 708000000U, 1, 118, 0, 4, 1),
-	TH1520_PLL_RATE(1026000000U, 342000000U, 4, 171, 0, 3, 1),
-	TH1520_PLL_RATE(1260000000U, 630000000U, 4, 210, 0, 2, 1),
-};
-
-static struct th1520_pll_clk th1520_cpu_pll0div = {
-	.out_type = TH1520_PLL_DIV,
-	.clk_type = TH1520_CPU_PLL0,
-	.rate_table = th1520_cpupll_tbl,
-	.rate_count = ARRAY_SIZE(th1520_cpupll_tbl),
-};
-
-static struct th1520_pll_clk th1520_cpu_pll1div = {
-	.out_type = TH1520_PLL_DIV,
-	.clk_type = TH1520_CPU_PLL1,
-	.rate_table = th1520_cpupll_tbl,
-	.rate_count = ARRAY_SIZE(th1520_cpupll_tbl),
-};
-
-static struct th1520_pll_clk th1520_dpu0_plldiv = {
-	.out_type = TH1520_PLL_DIV,
-	.clk_type = TH1520_DPU0_PLL,
-	.rate_table = th1520_dpupll_tbl,
-	.rate_count = ARRAY_SIZE(th1520_dpupll_tbl),
-};
-
-static struct th1520_pll_clk th1520_dpu1_plldiv = {
-	.out_type = TH1520_PLL_DIV,
-	.clk_type = TH1520_DPU1_PLL,
-	.rate_table = th1520_dpupll_tbl,
-	.rate_count = ARRAY_SIZE(th1520_dpupll_tbl),
-};
-
-static int th1520_clocks_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	void __iomem *ap_base;
-	int ret;
-	const bool *teesys = of_device_get_match_data(dev);
-
-	pr_info("th1520_clocks_probe !!! start !\n");
-
-	/* Clock source */
-	clks[CLK_DUMMY] = thead_clk_fixed("dummy", 0);
-	clks[OSC_32K] = of_clk_get_by_name(np, "osc_32k");
-	clks[OSC_24M] = of_clk_get_by_name(np, "osc_24m");
-	clks[RC_24M] = of_clk_get_by_name(np, "rc_24m");
-
-	np = dev->of_node;
-	ap_base = devm_platform_ioremap_resource(pdev, 0);
-	if (WARN_ON(IS_ERR(ap_base))) {
-		ret = PTR_ERR(ap_base);
-		goto unregister_clks;
-	}
-
-	/* Th1520 Fullmask AP PLL clocks */
-	clks[CPU_PLL0_FOUTPOSTDIV] = thead_th1520_pll("cpu_pll0_foutpostdiv", "osc_24m", ap_base, &th1520_cpu_pll0div);
-	clks[CPU_PLL1_FOUTPOSTDIV] = thead_th1520_pll("cpu_pll1_foutpostdiv", "osc_24m", ap_base, &th1520_cpu_pll1div);
-
-	clks[DPU0_PLL_FOUTPOSTDIV] = thead_th1520_pll("dpu0_pll_foutpostdiv", "osc_24m", ap_base, &th1520_dpu0_plldiv);
-	clks[DPU1_PLL_FOUTPOSTDIV] = thead_th1520_pll("dpu1_pll_foutpostdiv", "osc_24m", ap_base, &th1520_dpu1_plldiv);
-
-	/* Th1520 Fullmask AP Fixed PLL */
-	clks[GMAC_PLL_FOUTPOSTDIV] = thead_clk_fixed("gmac_pll_foutpostdiv", 1000000000);
-	clks[VIDEO_PLL_FOUTPOSTDIV] = thead_clk_fixed("video_pll_foutpostdiv", 792000000);
-	clks[VIDEO_PLL_FOUTVCO] = thead_clk_fixed("video_pll_foutvco", 2376000000);
-	clks[TEE_PLL_FOUTPOSTDIV] = thead_clk_fixed("tee_pll_foutpostdiv", 792000000);
-	clks[CLKGEN_PERI_I2S_SRC_CLK_0] = thead_clk_fixed("clkgen_peri_i2s_src_clk_0", 294912000);	//from audio_pll_foutpostdiv
-	clks[CLKGEN_PERI_I2S_SRC_CLK_1] = thead_clk_fixed("clkgen_peri_i2s_src_clk_1", 135475200);	//from sys_pll_foutpostdiv
-	clks[CLKGEN_C910_BUS_CLK_NO_ICG] = thead_clk_fixed("clkgen_c910_bus_clk_no_icg", 750000000);
-	clks[AONSYS_BUS_CLK] = thead_clk_fixed("aonsys_hclk", 101606400);	//from sys_pll, maybe change ?
-
-	/* Th1520 Fullmask AP MUX */
-	clks[CPU_PLL0_BYPASS] = thead_th1520_clk_mux_flags("cpu_pll0_bypass", ap_base + 0x4, 30, 1, cpu_pll0_bypass_sels, ARRAY_SIZE(cpu_pll0_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[CPU_PLL1_BYPASS] = thead_th1520_clk_mux_flags("cpu_pll1_bypass", ap_base + 0x14, 30, 1, cpu_pll1_bypass_sels, ARRAY_SIZE(cpu_pll1_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[GMAC_PLL_BYPASS] = thead_th1520_clk_mux_flags("gmac_pll_bypass", ap_base + 0x24, 30, 1, gmac_pll_bypass_sels, ARRAY_SIZE(gmac_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[VIDEO_PLL_BYPASS] = thead_th1520_clk_mux_flags("video_pll_bypass", ap_base + 0x34, 30, 1, video_pll_bypass_sels, ARRAY_SIZE(video_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[TEE_PLL_BYPASS] = thead_th1520_clk_mux_flags("tee_pll_bypass", ap_base + 0x64, 30, 1, tee_pll_bypass_sels, ARRAY_SIZE(tee_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[DPU0_PLL_BYPASS] = thead_th1520_clk_mux_flags("dpu0_pll_bypass", ap_base + 0x44, 30, 1, dpu0_pll_bypass_sels, ARRAY_SIZE(dpu0_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[DPU1_PLL_BYPASS] = thead_th1520_clk_mux_flags("dpu1_pll_bypass", ap_base + 0x54, 30, 1, dpu1_pll_bypass_sels, ARRAY_SIZE(dpu1_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-
-	clks[AHB2_CPUSYS_HCLK] = thead_th1520_clk_mux_flags("ahb2_cpusys_hclk", ap_base + 0x120, 5, 1, ahb2_cpusys_hclk_sels, ARRAY_SIZE(ahb2_cpusys_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[C910_CCLK_I0] = thead_th1520_clk_mux_flags("c910_cclk_i0", ap_base + 0x100, 1, 1, c910_cclk_i0_sels, ARRAY_SIZE(c910_cclk_i0_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[C910_CCLK] = thead_th1520_clk_mux_flags("c910_cclk", ap_base + 0x100, 0, 1, c910_cclk_sels, ARRAY_SIZE(c910_cclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[CFG_AXI_ACLK] = thead_th1520_clk_mux_flags("cfg_axi_aclk", ap_base + 0x138, 5, 1, cfg_axi_aclk_sels, ARRAY_SIZE(cfg_axi_aclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-
-	if (teesys)
-		clks[TEESYS_HCLK] = thead_th1520_clk_mux_flags("teesys_hclk", ap_base + 0x1cc, 13, 1, teesys_hclk_sels, ARRAY_SIZE(teesys_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT); //just for teesys!!!
-
-	clks[PERISYS_AHB_HCLK] = thead_th1520_clk_mux_flags("perisys_ahb_hclk", ap_base + 0x140, 5, 1, perisys_ahb_hclk_sels, ARRAY_SIZE(perisys_ahb_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[CLK_OUT_1] = thead_th1520_clk_mux_flags("clk_out_1", ap_base + 0x1b4, 4, 1, clk_out_1_sels, ARRAY_SIZE(clk_out_1_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[CLK_OUT_2] = thead_th1520_clk_mux_flags("clk_out_2", ap_base + 0x1b8, 4, 1, clk_out_2_sels, ARRAY_SIZE(clk_out_2_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[CLK_OUT_3] = thead_th1520_clk_mux_flags("clk_out_3", ap_base + 0x1bc, 4, 1, clk_out_3_sels, ARRAY_SIZE(clk_out_3_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[CLK_OUT_4] = thead_th1520_clk_mux_flags("clk_out_4", ap_base + 0x1c0, 4, 1, clk_out_4_sels, ARRAY_SIZE(clk_out_4_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[PERI_I2S_SRC_CLK] = thead_th1520_clk_mux_flags("peri_i2s_src_clk", ap_base + 0x1f0, 0, 1, peri_i2s_src_clk_sels, ARRAY_SIZE(peri_i2s_src_clk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[NPU_CCLK] = thead_th1520_clk_mux_flags("npu_cclk", ap_base + 0x1c8, 6, 1, npu_cclk_sels, ARRAY_SIZE(npu_cclk_sels), CLK_SET_RATE_PARENT);
-	clks[CFG_APB_PCLK] = thead_th1520_clk_mux_flags("cfg_apb_pclk", ap_base + 0x1c4, 7, 1, cfg_apb_pclk_sels, ARRAY_SIZE(cfg_apb_pclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-	clks[UART_SCLK] = thead_th1520_clk_mux_flags("uart_sclk", ap_base + 0x210, 0, 1, uart_sclk_sels, ARRAY_SIZE(uart_sclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
-
-	/* Th1520 Fullmask AP Divider */
-	clks[AHB2_CPUSYS_HCLK_OUT_DIV] = thead_clk_th1520_divider("ahb2_cpusys_hclk_out_div", "gmac_pll_fout1ph0", ap_base + 0x120, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
-	clks[APB3_CPUSYS_PCLK] = thead_clk_th1520_divider("apb3_cpusys_pclk", "ahb2_cpusys_hclk", ap_base + 0x130, 0, 3, 3, MUX_TYPE_CDE, 1, 7);
-	clks[AXI4_CPUSYS2_ACLK] = thead_clk_th1520_divider("axi4_cpusys2_aclk", "gmac_pll_foutpostdiv", ap_base + 0x134, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
-	clks[CFG_AXI_ACLK_OUT_DIV] = thead_clk_th1520_divider("cfg_axi_aclk_out_div", "video_pll_foutpostdiv", ap_base + 0x138, 0, 4, 4, MUX_TYPE_DIV, 2, 15);
-
-	if (teesys) {
-		clks[TEESYS_I0_HCLK] = thead_clk_th1520_divider("teesys_i0_hclk", "tee_pll_foutpostdiv", ap_base + 0x1cc, 0, 4, 4, MUX_TYPE_DIV, 2, 15); //just for teesys!!!
-		clks[TEESYS_I1_HCLK] = thead_clk_th1520_divider("teesys_i1_hclk", "video_pll_foutpostdiv", ap_base + 0x1cc, 8, 4, 12, MUX_TYPE_DIV, 2, 15); //just for teesys!!!
-	}
-
-	clks[PERISYS_AHB_HCLK_OUT_DIV] = thead_clk_th1520_divider("perisys_ahb_hclk_out_div", "gmac_pll_fout1ph0", ap_base + 0x140, 0, 4, 4, MUX_TYPE_DIV, 2, 7);
-	clks[PERISYS_APB_PCLK] = thead_clk_th1520_divider("perisys_apb_pclk", "perisys_ahb_hclk", ap_base + 0x150, 0, 3, 3, MUX_TYPE_CDE, 3, 7);
-	clks[PERI2SYS_APB_PCLK] = thead_clk_th1520_divider("peri2sys_apb_pclk", "gmac_pll_fout4", ap_base + 0x150, 4, 3, 8, MUX_TYPE_DIV, 2, 7);
-	clks[CLK_OUT_1_OUT_DIV] = thead_clk_th1520_divider("clk_out_1_out_div", "osc_24m", ap_base + 0x1b4, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
-	clks[CLK_OUT_2_OUT_DIV] = thead_clk_th1520_divider("clk_out_2_out_div", "osc_24m", ap_base + 0x1b8, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
-	clks[CLK_OUT_3_OUT_DIV] = thead_clk_th1520_divider("clk_out_3_out_div", "osc_24m", ap_base + 0x1bc, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
-	clks[CLK_OUT_4_OUT_DIV] = thead_clk_th1520_divider("clk_out_4_out_div", "osc_24m", ap_base + 0x1c0, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
-	clks[VOSYS_ACLK_M] = thead_clk_th1520_divider("vosys_aclk_m", "video_pll_foutvco", ap_base + 0x1dc, 0, 4, 4, MUX_TYPE_DIV, 3, 15);
-	clks[NPU_CCLK_OUT_DIV] = thead_clk_th1520_divider("npu_cclk_out_div", "video_pll_foutvco", ap_base + 0x1c8, 0, 3, 3, MUX_TYPE_DIV, 3, 7);
-	clks[CFG_APB_PCLK_OUT_DIV] = thead_clk_th1520_divider("cfg_apb_pclk_out_div", "gmac_pll_foutpostdiv", ap_base + 0x1c4, 0, 4, 4, MUX_TYPE_DIV, 4, 15);
-	clks[VISYS_ACLK_M] = thead_clk_th1520_divider("visys_aclk_m", "video_pll_foutvco", ap_base + 0x1d0, 16, 4, 20, MUX_TYPE_DIV, 3, 15);
-	clks[VISYS_AHB_HCLK] = thead_clk_th1520_divider("visys_ahb_hclk", "video_pll_foutvco", ap_base + 0x1d0, 0, 4, 4, MUX_TYPE_DIV, 6, 15);
-	clks[VPSYS_APB_PCLK] = thead_clk_th1520_divider("vpsys_apb_pclk", "gmac_pll_fout1ph0", ap_base + 0x1e0, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
-	clks[VPSYS_AXI_ACLK] = thead_clk_th1520_divider("vpsys_axi_aclk", "video_pll_foutvco", ap_base + 0x1e0, 8, 4, 12, MUX_TYPE_DIV, 3, 15);
-	clks[VENC_CCLK] = thead_clk_th1520_divider_closest("venc_cclk", "gmac_pll_foutpostdiv", ap_base + 0x1e4, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
-	clks[DPU0_PLL_DIV_CLK] = thead_clk_th1520_divider("dpu0_pll_div_clk", "dpu0_pll_foutpostdiv", ap_base + 0x1e8, 0, 8, 8, MUX_TYPE_DIV, 2, 214);
-	clks[DPU1_PLL_DIV_CLK] = thead_clk_th1520_divider("dpu1_pll_div_clk", "dpu1_pll_foutpostdiv", ap_base + 0x1ec, 0, 8, 8, MUX_TYPE_DIV, 2, 214);
-
-	/* Th1520 Fullmask PLL FOUT */
-	clks[GMAC_PLL_FOUT1PH0] = thead_th1520_clk_fixed_factor("gmac_pll_fout1ph0", "gmac_pll_bypass", 1, 2);
-	clks[GMAC_PLL_FOUT4] = thead_th1520_clk_fixed_factor("gmac_pll_fout4", "gmac_pll_bypass", 1, 8);
-	clks[VIDEO_PLL_FOUT1PH0] = thead_th1520_clk_fixed_factor("video_pll_fout1ph0", "video_pll_bypass", 1, 2);
-	clks[VIDEO_PLL_FOUT4] = thead_th1520_clk_fixed_factor("video_pll_fout4", "video_pll_bypass", 1, 8);
-	clks[TEE_PLL_FOUT4] = thead_th1520_clk_fixed_factor("tee_pll_fout4", "tee_pll_bypass", 1, 8);
-	clks[CPU_PLL0_FOUT4] = thead_th1520_clk_fixed_factor("cpu_pll0_fout4", "cpu_pll0_bypass", 1, 8);
-	clks[CPU_PLL1_FOUT4] = thead_th1520_clk_fixed_factor("cpu_pll1_fout4", "cpu_pll1_bypass", 1, 8);
-	clks[DPU0_PLL_FOUT4] = thead_th1520_clk_fixed_factor("dpu0_pll_fout4", "dpu0_pll_bypass", 1, 8);
-	clks[DPU1_PLL_FOUT4] = thead_th1520_clk_fixed_factor("dpu1_pll_fout4", "dpu1_pll_bypass", 1, 8);
-
-	/* Th1520 Fullmask Fixed Factor */
-	clks[C910_OSC_CLK] = thead_th1520_clk_fixed_factor("c910_osc_clk", "osc_24m", 1, 1);
-	clks[QSPI_SSI_CLK] = thead_th1520_clk_fixed_factor("qspi_ssi_clk", "video_pll_foutpostdiv", 1, 1);		/* Note: no mux to select, use default value */
-	clks[QSPI0_SSI_CLK] = thead_th1520_clk_fixed_factor("qspi0_ssi_clk", "qspi_ssi_clk", 1, 1);
-	clks[QSPI1_SSI_CLK] = thead_th1520_clk_fixed_factor("qspi1_ssi_clk", "video_pll_fout1ph0", 1, 1);
-	clks[SPI_SSI_CLK] = thead_th1520_clk_fixed_factor("spi_ssi_clk", "video_pll_fout1ph0", 1, 1);
-	clks[EMMC_SDIO_REF_CLK] = thead_th1520_clk_fixed_factor("emmc_sdio_ref_clk", "video_pll_foutpostdiv", 1, 4);	/* Note: base clk is div 4 to 198M*/
-	clks[PWM_CCLK] = thead_th1520_clk_fixed_factor("pwm_cclk", "osc_24m", 1, 1);
-	clks[CHIP_DBG_CCLK] = thead_th1520_clk_fixed_factor("chip_dbg_cclk", "osc_24m", 1, 1);
-	clks[GMAC_CCLK] = thead_th1520_clk_fixed_factor("gmac_cclk", "gmac_pll_fout1ph0", 1, 1);
-	clks[GPIO0_DBCLK] = thead_th1520_clk_fixed_factor("gpio0_dbclk", "pad_rtc_clk", 1, 1);
-	clks[GPIO1_DBCLK] = thead_th1520_clk_fixed_factor("gpio1_dbclk", "pad_rtc_clk", 1, 1);
-	clks[GPIO2_DBCLK] = thead_th1520_clk_fixed_factor("gpio2_dbclk", "pad_rtc_clk", 1, 1);
-	clks[GPIO3_DBCLK] = thead_th1520_clk_fixed_factor("gpio3_dbclk", "pad_rtc_clk", 1, 1);
-	clks[CLK_100M] = thead_th1520_clk_fixed_factor("clk_100m", "gmac_pll_foutpostdiv", 1, 10);
-	clks[I2C_IC_CLK] = thead_th1520_clk_fixed_factor("i2c_ic_clk", "clk_100m", 1, 2);
-	clks[TIMER_CCLK] = thead_th1520_clk_fixed_factor("timer_cclk", "osc_24m", 1, 1);
-	clks[AXI4_CPUSYS1_ACLK] = thead_th1520_clk_fixed_factor("axi4_cpusys1_aclk", "clkgen_c910_bus_clk_no_icg", 1, 1);
-	clks[CPU_BUS_DFTCLK] = thead_th1520_clk_fixed_factor("cpu_bus_dftclk", "cpu_pll0_foutpostdiv", 1, 2);
-	clks[CPU_PLL0_TEST_CLK] = thead_th1520_clk_fixed_factor("cpu_pll0_test_clk", "cpu_pll0_fout4", 1, 8);
-	clks[CPU_PLL1_TEST_CLK] = thead_th1520_clk_fixed_factor("cpu_pll1_test_clk", "cpu_pll1_fout4", 1, 8);
-	clks[DPU0_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("dpu0_pll_test_clk", "dpu0_pll_fout4", 1, 8);
-	clks[DPU1_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("dpu1_pll_test_clk", "dpu1_pll_fout4", 1, 8);
-	clks[GMAC_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("gmac_pll_test_clk", "gmac_pll_fout4", 1, 8);
-	clks[VIDEO_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("video_pll_test_clk", "video_pll_fout4", 1, 8);
-	clks[TEE_PLL_TEST_CLK] = thead_th1520_clk_fixed_factor("tee_pll_test_clk", "tee_pll_fout4", 1, 8);
-	clks[AONSYS_BUS_CLK] = thead_th1520_clk_fixed_factor("aonsys_bus_clk", "aonsys_hclk", 1, 1);
-
-	/* Th1520 Fullmask Clock Gate */
-	clks[CLKGEN_AHB2_CPUSYS_HCLK] = thead_clk_th1520_gate("clkgen_ahb2_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x120, 6);
-	clks[CLKGEN_APB3_CPUSYS_HCLK] = thead_clk_th1520_gate("clkgen_apb3_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x130, 4);
-	clks[CLKGEN_C910_BROM_HCLK] = thead_clk_th1520_gate("clkgen_c910_brom_hclk", "ahb2_cpusys_hclk", ap_base + 0x100, 4);
-	clks[CLKGEN_SPINLOCK_HCLK] = thead_clk_th1520_gate("clkgen_spinlock_hclk", "ahb2_cpusys_hclk", ap_base + 0x208, 10);
-	clks[CLKGEN_MBOX0_PCLK] = thead_clk_th1520_gate("clkgen_mbox0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 7);
-	clks[CLKGEN_MBOX1_PCLK] = thead_clk_th1520_gate("clkgen_mbox1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 6);
-	clks[CLKGEN_MBOX2_PCLK] = thead_clk_th1520_gate("clkgen_mbox2_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 5);
-	clks[CLKGEN_MBOX3_PCLK] = thead_clk_th1520_gate("clkgen_mbox3_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 4);
-	clks[CLKGEN_WDT0_PCLK] = thead_clk_th1520_gate("clkgen_wdt0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 3);
-	clks[CLKGEN_WDT1_PCLK] = thead_clk_th1520_gate("clkgen_wdt1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 2);
-
-	if (teesys)
-		clks[CLKGEN_MISCSYS_TEE_CCLK] = thead_clk_th1520_gate("clkgen_miscsys_tee_cclk", "teesys_hclk", ap_base + 0x1cc, 25); //just for teesys!!!
-
-	clks[CLKGEN_SRAM_AXI_ACLK_2] = thead_clk_th1520_gate("clkgen_sram_axi_aclk_2", "axi4_cpusys1_aclk", ap_base + 0x20c, 2);
-	clks[CLKGEN_PERISYS_AHB_HCLK] = thead_clk_th1520_gate("clkgen_perisys_ahb_hclk", "perisys_ahb_hclk", ap_base + 0x140, 6);
-	clks[CLKGEN_PERISYS_APB1_HCLK] = thead_clk_th1520_gate("clkgen_perisys_apb1_hclk", "perisys_ahb_hclk", ap_base + 0x150, 9);
-	clks[CLKGEN_PERISYS_APB2_HCLK] = thead_clk_th1520_gate("clkgen_perisys_apb2_hclk", "perisys_ahb_hclk", ap_base + 0x150, 10);
-	clks[CLKGEN_PERISYS_APB4_HCLK] = thead_clk_th1520_gate("clkgen_perisys_apb4_hclk", "perisys_ahb_hclk", ap_base + 0x150, 12);
-	clks[CLKGEN_PADCTRL0_APSYS_PCLK] = thead_clk_th1520_gate("clkgen_padctrl0_apsys_pclk", "perisys_ahb_hclk", ap_base + 0x204, 22);
-	clks[CLKGEN_DSMART_PCLK] = thead_clk_th1520_gate("clkgen_dsmart_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 23);
-	clks[CLKGEN_PADCTRL1_APSYS_PCLK] = thead_clk_th1520_gate("clkgen_padctrl1_apsys_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 24);
-	clks[CLKGEN_CLK_OUT_1_CLK] = thead_clk_th1520_gate("clkgen_clk_out_1_clk", "clk_out_1", ap_base + 0x1b4, 5);
-	clks[CLKGEN_CLK_OUT_2_CLK] = thead_clk_th1520_gate("clkgen_clk_out_2_clk", "clk_out_2", ap_base + 0x1b8, 5);
-	clks[CLKGEN_CLK_OUT_3_CLK] = thead_clk_th1520_gate("clkgen_clk_out_3_clk", "clk_out_3", ap_base + 0x1bc, 5);
-	clks[CLKGEN_CLK_OUT_4_CLK] = thead_clk_th1520_gate("clkgen_clk_out_4_clk", "clk_out_4", ap_base + 0x1c0, 5);
-	clks[CLKGEN_NPUSYS_AXI_ACLK] = thead_clk_th1520_gate("clkgen_npusys_axi_aclk", "npu_cclk", ap_base + 0x1c8, 5);
-	clks[CLKGEN_SRAM_AXI_ACLK_0] = thead_clk_th1520_gate("clkgen_sram_axi_aclk_0", "npu_cclk", ap_base + 0x20c, 4);
-	clks[CLKGEN_APB_CPU2CFG_HCLK] = thead_clk_th1520_gate("clkgen_apb_cpu2cfg_hclk", "cfg_apb_pclk", ap_base + 0x1c4, 5);
-	clks[CLKGEN_SRAM_AXI_ACLK_1] = thead_clk_th1520_gate("clkgen_sram_axi_aclk_1", "visys_aclk_m", ap_base + 0x20c, 3);
-	clks[CLKGEN_SRAM_AXI_ACLK_3] = thead_clk_th1520_gate("clkgen_sram_axi_aclk_3", "vpsys_axi_aclk", ap_base + 0x20c, 1);
-	clks[CLKGEN_VPSYS_VENC_CCLK] = thead_clk_th1520_gate("clkgen_vpsys_venc_cclk", "venc_cclk", ap_base + 0x1e4, 5);
-	clks[CLKGEN_EMMC_SDIO_REF_CLK] = thead_clk_th1520_gate("clkgen_emmc_sdio_ref_clk", "emmc_sdio_ref_clk", ap_base + 0x204, 30);
-
-	clks[CLKGEN_X2H_CPUSYS_MHCLK] = thead_clk_th1520_gate_shared("clkgen_x2h_cpusys_mhclk", "ahb2_cpusys_hclk", ap_base + 0x120, 7, &share_cnt_x2h_cpusys_clk_en);
-	clks[CLKGEN_X2H_CPUSYS_ACLK] = thead_clk_th1520_gate_shared("clkgen_x2h_cpusys_aclk", "cfg_axi_aclk", ap_base + 0x120, 7, &share_cnt_x2h_cpusys_clk_en);
-	clks[CLKGEN_DMAC_CPUSYS_HCLK] = thead_clk_th1520_gate_shared("clkgen_dmac_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
-	clks[CLKGEN_IOPMP_DMAC_CPUSYS_PCLK] = thead_clk_th1520_gate_shared("clkgen_iopmp_dmac_cpusys_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
-	clks[CLKGEN_DMAC_CPUSYS_ACLK] = thead_clk_th1520_gate_shared("clkgen_dmac_cpusys_aclk", "axi4_cpusys2_aclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
-	clks[CLKGEN_TIMER0_PCLK] = thead_clk_th1520_gate_shared("clkgen_timer0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 1, &share_cnt_timer0_clk_en);
-	clks[CLKGEN_TIMER0_CCLK] = thead_clk_th1520_gate_shared("clkgen_timer0_cclk", "timer_cclk", ap_base + 0x208, 1, &share_cnt_timer0_clk_en);
-	clks[CLKGEN_TIMER1_PCLK] = thead_clk_th1520_gate_shared("clkgen_timer1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 0, &share_cnt_timer1_clk_en);
-	clks[CLKGEN_TIMER1_CCLK] = thead_clk_th1520_gate_shared("clkgen_timer1_cclk", "timer_cclk", ap_base + 0x208, 0, &share_cnt_timer1_clk_en);
-	clks[CLKGEN_AXI4_CPUSYS2_PCLK] = thead_clk_th1520_gate_shared("clkgen_axi4_cpusys2_pclk", "apb3_cpusys_pclk", ap_base + 0x134, 5, &share_cnt_axi4_cpusys2_clk_en);
-	clks[CLKGEN_AXI4_CPUSYS2_ACLK] = thead_clk_th1520_gate_shared("clkgen_axi4_cpusys2_aclk", "axi4_cpusys2_aclk", ap_base + 0x134, 5, &share_cnt_axi4_cpusys2_clk_en);
-	clks[CLKGEN_BMU_C910_PCLK] = thead_clk_th1520_gate_shared("clkgen_bmu_c910_pclk", "apb3_cpusys_pclk", ap_base + 0x100, 5, &share_cnt_bmu_c910_clk_en);
-	clks[CLKGEN_BMU_C910_ACLK] = thead_clk_th1520_gate_shared("clkgen_bmu_c910_aclk", "axi4_cpusys1_aclk", ap_base + 0x100, 5, &share_cnt_bmu_c910_clk_en);
-	clks[CLKGEN_IOPMP_AON_PCLK] = thead_clk_th1520_gate_shared("clkgen_iopmp_aon_pclk", "apb3_cpusys_pclk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
-	clks[CLKGEN_AON2CPU_A2X_ACLK] = thead_clk_th1520_gate_shared("clkgen_aon2cpu_a2x_aclk", "axi4_cpusys2_aclk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
-	clks[CLKGEN_AON2CPU_A2X_HCLK] = thead_clk_th1520_gate_shared("clkgen_aon2cpu_a2x_hclk", "aonsys_bus_clk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
-	clks[CLKGEN_IOPMP_CHIP_DBG_PCLK] = thead_clk_th1520_gate_shared("clkgen_iopmp_chip_dbg_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
-	clks[CLKGEN_CHIP_DBG_ACLK] = thead_clk_th1520_gate_shared("clkgen_chip_dbg_aclk", "axi4_cpusys2_aclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
-	clks[CLKGEN_CHIP_DBG_CCLK] = thead_clk_th1520_gate_shared("clkgen_chip_dbg_cclk", "chip_dbg_cclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
-	clks[CLKGEN_X2X_CPUSYS_ACLK_M] = thead_clk_th1520_gate_shared("clkgen_x2x_cpusys_aclk_m", "axi4_cpusys2_aclk", ap_base + 0x134, 7, &share_cnt_x2x_cpusys_clk_en);
-	clks[CLKGEN_X2X_CPUSYS_ACLK_S] = thead_clk_th1520_gate_shared("clkgen_x2x_cpusys_aclk_s", "axi4_cpusys1_aclk", ap_base + 0x134, 7, &share_cnt_x2x_cpusys_clk_en);
-	clks[CLKGEN_CPU2PERI_X2H_ACLK] = thead_clk_th1520_gate_shared("clkgen_cpu2peri_x2h_aclk", "axi4_cpusys1_aclk", ap_base + 0x140, 9, &share_cnt_cpu2peri_x2h_clk_en);
-	clks[CLKGEN_CPU2PERI_X2H_MHCLK] = thead_clk_th1520_gate_shared("clkgen_cpu2peri_x2h_mhclk", "perisys_ahb_hclk", ap_base + 0x140, 9, &share_cnt_cpu2peri_x2h_clk_en);
-	clks[CLKGEN_CPU2VI_X2H_ACLK] = thead_clk_th1520_gate_shared("clkgen_cpu2vi_x2h_aclk", "axi4_cpusys1_aclk", ap_base + 0x1d0, 21, &share_cnt_cpu2vi_x2h_clk_en);
-	clks[CLKGEN_CPU2VI_X2H_MHCLK] = thead_clk_th1520_gate_shared("clkgen_cpu2vi_x2h_mhclk", "visys_ahb_hclk", ap_base + 0x1d0, 21, &share_cnt_cpu2vi_x2h_clk_en);
-	clks[CLKGEN_CFG2TEE_X2H_ACLK] = thead_clk_th1520_gate_shared("clkgen_cfg2tee_x2h_aclk", "cfg_axi_aclk", ap_base + 0x1cc, 24, &share_cnt_cfg2tee_x2h_clk_en); // just for teesys!!!
-	clks[CLKGEN_CFG2TEE_X2H_MHCLK] = thead_clk_th1520_gate_shared("clkgen_cfg2tee_x2h_mhclk", "teesys_hclk", ap_base + 0x1cc, 24, &share_cnt_cfg2tee_x2h_clk_en); // just for teesys!!!
-	clks[CLKGEN_CPU2AON_X2H_ACLK] = thead_clk_th1520_gate_shared("clkgen_cpu2aon_x2h_aclk", "cfg_axi_aclk", ap_base + 0x138, 8, &share_cnt_cpu2aon_x2h_clk_en);
-	clks[CLKGEN_CPU2AON_X2H_MHCLK] = thead_clk_th1520_gate_shared("clkgen_cpu2aon_x2h_mhclk", "aonsys_bus_clk", ap_base + 0x138, 8, &share_cnt_cpu2aon_x2h_clk_en);
-	clks[CLKGEN_CPU2VP_X2P_ACLK] = thead_clk_th1520_gate_shared("clkgen_cpu2vp_x2p_aclk", "cfg_axi_aclk", ap_base + 0x1e0, 13, &share_cnt_cpu2vp_x2p_clk_en);
-	clks[CLKGEN_CPU2VP_X2P_PCLK] = thead_clk_th1520_gate_shared("clkgen_cpu2vp_x2p_pclk", "vpsys_apb_pclk", ap_base + 0x1e0, 13, &share_cnt_cpu2vp_x2p_clk_en);
-	clks[CLKGEN_TOP_AXI4S_ACLK] = thead_clk_th1520_gate_shared("clkgen_top_axi4s_aclk", "cfg_axi_aclk", ap_base + 0x1c8, 4, &share_cnt_npu_core_clk_en);
-	clks[CLKGEN_TOP_APB_SX_PCLK] = thead_clk_th1520_gate_shared("clkgen_top_apb_sx_pclk", "cfg_apb_pclk", ap_base + 0x1c8, 4, &share_cnt_npu_core_clk_en);
-	clks[CLKGEN_MISC2VP_X2X_ACLK_M] = thead_clk_th1520_gate_shared("clkgen_misc2vp_x2x_aclk_m", "perisys_ahb_hclk", ap_base + 0x1e0, 15, &share_cnt_vpsys_axi_aclk_en);
-	clks[CLKGEN_VPSYS_ACLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_aclk", "vpsys_axi_aclk", ap_base + 0x1e0, 15, &share_cnt_vpsys_axi_aclk_en);
-	clks[CLKGEN_GMAC1_HCLK] = thead_clk_th1520_gate_shared("clkgen_gmac1_hclk", "perisys_ahb_hclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
-	clks[CLKGEN_GMAC1_PCLK] = thead_clk_th1520_gate_shared("clkgen_gmac1_pclk", "perisys_ahb_hclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
-	clks[CLKGEN_GMAC1_CCLK] = thead_clk_th1520_gate_shared("clkgen_gmac1_cclk", "gmac_cclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
-	clks[CLKGEN_GMAC0_HCLK] = thead_clk_th1520_gate_shared("clkgen_gmac0_hclk", "perisys_ahb_hclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
-	clks[CLKGEN_GMAC0_PCLK] = thead_clk_th1520_gate_shared("clkgen_gmac0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
-	clks[CLKGEN_GMAC0_CCLK] = thead_clk_th1520_gate_shared("clkgen_gmac0_cclk", "gmac_cclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
-	clks[CLKGEN_PERI2PERI1_APB_HCLK] = thead_clk_th1520_gate_shared("clkgen_peri2peri1_apb_hclk", "perisys_ahb_hclk", ap_base + 0x150, 11, &share_cnt_perisys_apb3_hclk_en);
-	clks[CLKGEN_PERI2PERI1_APB_PCLK] = thead_clk_th1520_gate_shared("clkgen_peri2peri1_apb_pclk", "peri2sys_apb_pclk", ap_base + 0x150, 11, &share_cnt_perisys_apb3_hclk_en);
-	clks[CLKGEN_QSPI0_PCLK] = thead_clk_th1520_gate_shared("clkgen_qspi0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 17, &share_cnt_qspi0_clk_en);
-	clks[CLKGEN_QSPI0_SSI_CLK] = thead_clk_th1520_gate_shared("clkgen_qspi0_ssi_clk", "qspi0_ssi_clk", ap_base + 0x204, 17, &share_cnt_qspi0_clk_en);
-	clks[CLKGEN_GMAC_AXI_ACLK] = thead_clk_th1520_gate_shared("clkgen_gmac_axi_aclk", "perisys_ahb_hclk", ap_base + 0x204, 21, &share_cnt_gmac_axi_clk_en);
-	clks[CLKGEN_GMAC_AXI_PCLK] = thead_clk_th1520_gate_shared("clkgen_gmac_axi_pclk", "perisys_ahb_hclk", ap_base + 0x204, 21, &share_cnt_gmac_axi_clk_en);
-	clks[CLKGEN_GPIO0_PCLK] = thead_clk_th1520_gate_shared("clkgen_gpio0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 8, &share_cnt_gpio0_clk_en);
-	clks[CLKGEN_GPIO0_DBCLK] = thead_clk_th1520_gate_shared("clkgen_gpio0_dbclk", "gpio0_dbclk", ap_base + 0x204, 8, &share_cnt_gpio0_clk_en);
-	clks[CLKGEN_GPIO1_PCLK] = thead_clk_th1520_gate_shared("clkgen_gpio1_pclk", "perisys_ahb_hclk", ap_base + 0x204, 7, &share_cnt_gpio0_clk_en);
-	clks[CLKGEN_GPIO1_DBCLK] = thead_clk_th1520_gate_shared("clkgen_gpio1_dbclk", "gpio1_dbclk", ap_base + 0x204, 7, &share_cnt_gpio1_clk_en);
-	clks[CLKGEN_PWM_PCLK] = thead_clk_th1520_gate_shared("clkgen_pwm_pclk", "perisys_apb_pclk", ap_base + 0x204, 18, &share_cnt_pwm_clk_en);
-	clks[CLKGEN_PWM_CCLK] = thead_clk_th1520_gate_shared("clkgen_pwm_cclk", "pwm_cclk", ap_base + 0x204, 18, &share_cnt_pwm_clk_en);
-	clks[CLKGEN_SPI_PCLK] = thead_clk_th1520_gate_shared("clkgen_spi_pclk", "perisys_apb_pclk", ap_base + 0x204, 15, &share_cnt_spi_clk_en);
-	clks[CLKGEN_SPI_SSI_CLK] = thead_clk_th1520_gate_shared("clkgen_spi_ssi_clk", "spi_ssi_clk", ap_base + 0x204, 15, &share_cnt_spi_clk_en);
-	clks[CLKGEN_UART0_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart0_pclk", "perisys_apb_pclk", ap_base + 0x204, 14, &share_cnt_uart0_clk_en);
-	clks[CLKGEN_UART0_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart0_sclk", "uart_sclk", ap_base + 0x204, 14, &share_cnt_uart0_clk_en);
-	clks[CLKGEN_UART2_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart2_pclk", "perisys_apb_pclk", ap_base + 0x204, 12, &share_cnt_uart2_clk_en);
-	clks[CLKGEN_UART2_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart2_sclk", "uart_sclk", ap_base + 0x204, 12, &share_cnt_uart2_clk_en);
-	clks[CLKGEN_I2C2_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c2_pclk", "perisys_apb_pclk", ap_base + 0x204, 3, &share_cnt_i2c2_clk_en);
-	clks[CLKGEN_I2C2_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c2_ic_clk", "i2c_ic_clk", ap_base + 0x204, 3, &share_cnt_i2c2_clk_en);
-	clks[CLKGEN_I2C3_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c3_pclk", "perisys_apb_pclk", ap_base + 0x204, 2, &share_cnt_i2c3_clk_en);
-	clks[CLKGEN_I2C3_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c3_ic_clk", "i2c_ic_clk", ap_base + 0x204, 2, &share_cnt_i2c3_clk_en);
-	clks[CLKGEN_I2S_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2s_pclk", "perisys_apb_pclk", ap_base + 0x1f0, 1, &share_cnt_peri_i2s_clk_en);
-	clks[CLKGEN_I2S_SRC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2s_src_clk", "peri_i2s_src_clk", ap_base + 0x1f0, 1, &share_cnt_peri_i2s_clk_en);
-	clks[CLKGEN_QSPI1_PCLK] = thead_clk_th1520_gate_shared("clkgen_qspi1_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 16, &share_cnt_qspi1_clk_en);
-	clks[CLKGEN_QSPI1_SSI_CLK] = thead_clk_th1520_gate_shared("clkgen_qspi1_ssi_clk", "qspi1_ssi_clk", ap_base + 0x204, 16, &share_cnt_qspi1_clk_en);
-	clks[CLKGEN_UART1_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart1_pclk", "per2sys_apb_pclk", ap_base + 0x204, 13, &share_cnt_uart1_clk_en);
-	clks[CLKGEN_UART1_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart1_sclk", "uart_sclk", ap_base + 0x204, 13, &share_cnt_uart1_clk_en);
-	clks[CLKGEN_UART3_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart3_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 11, &share_cnt_uart3_clk_en);
-	clks[CLKGEN_UART3_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart3_sclk", "uart_sclk", ap_base + 0x204, 11, &share_cnt_uart3_clk_en);
-	clks[CLKGEN_UART4_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart4_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 10, &share_cnt_uart4_clk_en);
-	clks[CLKGEN_UART4_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart4_sclk", "uart_sclk", ap_base + 0x204, 10, &share_cnt_uart4_clk_en);
-	clks[CLKGEN_UART5_PCLK] = thead_clk_th1520_gate_shared("clkgen_uart5_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 9, &share_cnt_uart5_clk_en);
-	clks[CLKGEN_UART5_SCLK] = thead_clk_th1520_gate_shared("clkgen_uart5_sclk", "uart_sclk", ap_base + 0x204, 9, &share_cnt_uart5_clk_en);
-	clks[CLKGEN_I2C0_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c0_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 5, &share_cnt_i2c0_clk_en);
-	clks[CLKGEN_I2C0_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c0_ic_clk", "i2c_ic_clk", ap_base + 0x204, 5, &share_cnt_i2c0_clk_en);
-	clks[CLKGEN_I2C1_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c1_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 4, &share_cnt_i2c1_clk_en);
-	clks[CLKGEN_I2C1_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c1_ic_clk", "i2c_ic_clk", ap_base + 0x204, 4, &share_cnt_i2c1_clk_en);
-	clks[CLKGEN_I2C4_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c4_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 1, &share_cnt_i2c4_clk_en);
-	clks[CLKGEN_I2C4_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c4_ic_clk", "i2c_ic_clk", ap_base + 0x204, 1, &share_cnt_i2c4_clk_en);
-	clks[CLKGEN_I2C5_PCLK] = thead_clk_th1520_gate_shared("clkgen_i2c5_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 0, &share_cnt_i2c5_clk_en);
-	clks[CLKGEN_I2C5_IC_CLK] = thead_clk_th1520_gate_shared("clkgen_i2c5_ic_clk", "i2c_ic_clk", ap_base + 0x204, 0, &share_cnt_i2c5_clk_en);
-	clks[CLKGEN_GPIO2_PCLK] = thead_clk_th1520_gate_shared("clkgen_gpio2_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en);
-	clks[CLKGEN_GPIO2_DBCLK] = thead_clk_th1520_gate_shared("clkgen_gpio2_dbclk", "gpio2_dbclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en);
-	clks[CLKGEN_GPIO3_PCLK] = thead_clk_th1520_gate_shared("clkgen_gpio3_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en); //!!! gpio3 pclk is controlled by gpio2_clk_en
-	clks[CLKGEN_GPIO3_DBCLK] = thead_clk_th1520_gate_shared("clkgen_gpio3_dbclk", "gpio3_dbclk", ap_base + 0x204, 20, &share_cnt_gpio3_clk_en);
-	clks[CLKGEN_VOSYS_AXI_ACLK] = thead_clk_th1520_gate_shared("clkgen_vosys_axi_aclk", "vosys_aclk_m", ap_base + 0x1dc, 5, &share_cnt_vosys_axi_aclk_en);
-	clks[CLKGEN_VOSYS_X2X_ACLK_S] = thead_clk_th1520_gate_shared("clkgen_vosys_x2x_aclk_s", "npu_cclk", ap_base + 0x1dc, 5, &share_cnt_vosys_axi_aclk_en);
-
-	clk_data.clks = clks;
-	clk_data.clk_num = ARRAY_SIZE(clks);
-
-	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
-	if (ret < 0) {
-		dev_err(dev, "failed to register clks for th1520\n");
-		goto unregister_clks;
-	}
-
-#ifndef FPGA_EMU
-	/* HW defalut */
-	clk_set_parent(clks[C910_CCLK], clks[CPU_PLL1_FOUTPOSTDIV]);
-#else
-	clk_set_parent(clks[C910_CCLK_I0], clks[OSC_24M]);
-	clk_set_parent(clks[C910_CCLK], clks[C910_CCLK_I0]);
-#endif
-	dev_info(dev, "succeed to register th1520 fullmask clock driver\n");
-
-	return 0;
-
-unregister_clks:
-	thead_unregister_clocks(clks, ARRAY_SIZE(clks));
-	return ret;
-}
-
-const bool tee_sys_flag;
-
-static const struct of_device_id th1520_clk_of_match[] = {
-	{ .compatible = "thead,th1520-fm-ree-clk" },
-	{ .compatible = "thead,th1520-fm-tee-clk", .data = &tee_sys_flag,},
-	{ /* Sentinel */ },
-};
-MODULE_DEVICE_TABLE(of, th1520_clk_of_match);
-
-static struct platform_driver th1520_clk_driver = {
-	.probe = th1520_clocks_probe,
-	.driver = {
-		.name = "th1520-fm-clk",
-		.of_match_table = of_match_ptr(th1520_clk_of_match),
-	},
-};
-
-module_platform_driver(th1520_clk_driver);
-MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead Th1520 Fullmask clock driver");
-MODULE_LICENSE("GPL v2");
--- a/drivers/clk/thead/gate/Makefile
+++ /dev/null
@@ -1,3 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-obj-$(CONFIG_CLK_TH1520_FM) += thead-gate.o visys-gate.o vpsys-gate.o vosys-gate.o dspsys-gate.o audiosys-gate.o miscsys-gate.o
--- a/drivers/clk/thead/gate/vosys-gate.c
+++ /dev/null
@@ -1,111 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-
-#include <dt-bindings/clock/th1520-fm-ap-clock.h>
-#include <dt-bindings/clock/th1520-vosys.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include "../clk.h"
-
-static struct clk *gates[TH1520_CLKGEN_VOSYS_CLK_END];
-static struct clk_onecell_data clk_gate_data;
-
-static int thead_vosys_clk_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	void __iomem *gate_base;
-	int ret;
-
-	gate_base = devm_platform_ioremap_resource(pdev, 0);
-	if (WARN_ON(IS_ERR(gate_base)))
-		return PTR_ERR(gate_base);
-
-	/* we assume that the gate clock is a root clock  */
-	gates[TH1520_CLKGEN_AXI4_VO_PCLK] = thead_clk_th1520_gate("clkgen_axi4_vo_pclk", NULL,
-								gate_base + 0x50, 22);
-	gates[TH1520_CLKGEN_IOPMP_VOSYS_DPU_PCLK] = thead_clk_th1520_gate("clkgen_iopmp_dpu_pclk", NULL,
-								gate_base + 0x50, 23);
-	gates[TH1520_CLKGEN_IOPMP_VOSYS_DPU1_PCLK] = thead_clk_th1520_gate("clkgen_iopmp_dpu1_pclk", NULL,
-								gate_base + 0x50, 24);
-	gates[TH1520_CLKGEN_IOPMP_VOSYS_GPU_PCLK] = thead_clk_th1520_gate("clkgen_iopmp_gpu_pclk", NULL,
-								gate_base + 0x50, 25);
-	gates[TH1520_CLKGEN_HDMI_PCLK] = thead_clk_th1520_gate("clkgen_hdmi_pclk", NULL, gate_base + 0x50, 11);
-	gates[TH1520_CLKGEN_MIPIDSI0_PCLK] = thead_clk_th1520_gate("clkgen_mipidsi0_pclk", NULL,
-								  gate_base + 0x50, 13);
-	gates[TH1520_CLKGEN_MIPIDSI1_PCLK] = thead_clk_th1520_gate("clkgen_mipidsi1_pclk", NULL,
-								  gate_base + 0x50, 14);
-	gates[TH1520_CLKGEN_AXI4_VO_ACLK] = thead_clk_th1520_gate("clkgen_axi4_vo_aclk", NULL,
-								  gate_base + 0x50, 0);
-	gates[TH1520_CLKGEN_IOPMP_GPU_ACLK] = thead_clk_th1520_gate("clkgen_iopmp_gpu_aclk", NULL,
-								  gate_base + 0x50, 29);
-	gates[TH1520_CLKGEN_IOPMP_DPU_ACLK] = thead_clk_th1520_gate("clkgen_iopmp_dpu_aclk", NULL,
-								  gate_base + 0x50, 28);
-	gates[TH1520_CLKGEN_IOPMP_DPU1_ACLK] = thead_clk_th1520_gate("clkgen_iopmp_dpu1_aclk", NULL,
-								  gate_base + 0x50, 27);
-	gates[TH1520_CLKGEN_X2H_DPU_ACLK] = thead_clk_th1520_gate("clkgen_x2h_dpu_aclk", NULL, gate_base + 0x50, 21);
-	gates[TH1520_CLKGEN_X2H_DPU1_ACLK] = thead_clk_th1520_gate("clkgen_x2h_dpu1_aclk", NULL, gate_base + 0x50, 20);
-	gates[TH1520_CLKGEN_MIPIDSI0_PIXCLK] = thead_clk_th1520_gate("clkgen_mipidsi0_pixclk", NULL, gate_base + 0x50, 30);
-	gates[TH1520_CLKGEN_HDMI_PIXCLK] = thead_clk_th1520_gate("clkgen_hdmi_pixclk", NULL, gate_base + 0x54, 0);
-	gates[TH1520_CLKGEN_MIPIDSI1_PIXCLK] = thead_clk_th1520_gate("clkgen_mipidsi1_pixclk", NULL, gate_base + 0x50, 31);
-	gates[TH1520_CLKGEN_HDMI_SFR_CLK] = thead_clk_th1520_gate("clkgen_hdmi_sfr_clk", NULL, gate_base + 0x50, 10);
-	gates[TH1520_CLKGEN_HDMI_CEC_CLK] = thead_clk_th1520_gate("clkgen_hdmi_cec_cclk", NULL, gate_base + 0x50, 12);
-	gates[TH1520_CLKGEN_HDMI_I2S_CLK] = thead_clk_th1520_gate("clkgen_hdmi_i2s_clk", NULL, gate_base + 0x50, 19);
-	gates[TH1520_CLKGEN_MIPIDSI0_CFG_CLK] = thead_clk_th1520_gate("clkgen_mipidsi0_cfg_clk", NULL, gate_base + 0x50, 15);
-	gates[TH1520_CLKGEN_MIPIDSI1_CFG_CLK] = thead_clk_th1520_gate("clkgen_mipidsi1_cfg_clk", NULL, gate_base + 0x50, 16);
-	gates[TH1520_CLKGEN_MIPIDSI0_REFCLK] = thead_clk_th1520_gate("clkgen_mipidsi0_refclk", NULL, gate_base + 0x50, 17);
-	gates[TH1520_CLKGEN_MIPIDSI1_REFCLK] = thead_clk_th1520_gate("clkgen_mipidsi1_refclk", NULL, gate_base + 0x50, 18);
-	gates[TH1520_CLKGEN_GPU_CORE_CLK] = thead_clk_th1520_gate("clkgen_gpu_core_clk", "vosys_aclk_m", gate_base + 0x50, 3);
-	gates[TH1520_CLKGEN_GPU_CFG_ACLK] = thead_clk_th1520_gate("clkgen_gpu_cfg_aclk", NULL, gate_base + 0x50, 4);
-	gates[TH1520_CLKGEN_DPU_HCLK] = thead_clk_th1520_gate("clkgen_dpu_hclk", NULL, gate_base + 0x50, 7);
-	gates[TH1520_CLKGEN_DPU_ACLK] = thead_clk_th1520_gate("clkgen_dpu_aclk", NULL, gate_base + 0x50, 8);
-	gates[TH1520_CLKGEN_DPU_CCLK] = thead_clk_th1520_gate("clkgen_dpu_cclk", NULL, gate_base + 0x50, 9);
-	gates[TH1520_CLKGEN_DPU_PIXCLK0] = thead_clk_th1520_gate("clkgen_dpu_pixclk0", NULL, gate_base + 0x50, 5);
-	gates[TH1520_CLKGEN_DPU_PIXCLK1] = thead_clk_th1520_gate("clkgen_dpu_pixclk1", NULL, gate_base + 0x50, 6);
-
-	clk_gate_data.clks = gates;
-	clk_gate_data.clk_num = ARRAY_SIZE(gates);
-
-	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
-	if (ret < 0) {
-		dev_err(dev, "failed to register gate clks for th1520 vosys\n");
-		goto unregister_clks;
-	}
-
-	dev_info(dev, "succeed to register vosys gate clock provider\n");
-
-	return 0;
-
-unregister_clks:
-	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
-	return ret;
-}
-
-static const struct of_device_id vosys_clk_gate_of_match[] = {
-	{ .compatible = "thead,vosys-gate-controller" },
-	{ /* sentinel */ },
-};
-MODULE_DEVICE_TABLE(of, vosys_clk_gate_of_match);
-
-static struct platform_driver thead_vosys_clk_driver = {
-	.probe = thead_vosys_clk_probe,
-	.driver = {
-		.name = "vosys-clk-gate-provider",
-		.of_match_table = of_match_ptr(vosys_clk_gate_of_match),
-	},
-};
-
-module_platform_driver(thead_vosys_clk_driver);
-MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead Th1520 Fullmask vosys clock gate provider");
-MODULE_LICENSE("GPL v2");
--- a/drivers/clk/thead/Kconfig
+++ /dev/null
@@ -1,12 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-config THEAD_CLK
-	bool
-	def_bool ARCH_XUANTIE
-
-config CLK_TH1520_FM
-	bool "XuanTie Th1520 Fullmask Clock Driver"
-	depends on ARCH_XUANTIE
-	default n
-	help
-	    Build the driver for th1520 fullmask Clock Driver
--- /dev/null
+++ b/drivers/clk/xuantie/Kconfig
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0
+
+config XUANTIE_CLK
+	bool
+	def_bool ARCH_XUANTIE
+
+config CLK_TH1520_FM
+	bool "XuanTie Th1520 Fullmask Clock Driver"
+	depends on ARCH_XUANTIE
+	default n
+	help
+	    Build the driver for th1520 fullmask Clock Driver
--- a/drivers/clk/thead/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-obj-$(CONFIG_THEAD_CLK) += \
-	clk.o
-
-obj-$(CONFIG_CLK_TH1520_FM)  += clk-th1520-fm.o
-obj-$(CONFIG_CLK_TH1520_FM)  += gate/
--- /dev/null
+++ b/drivers/clk/xuantie/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_XUANTIE_CLK) += \
+	clk.o
+
+obj-$(CONFIG_CLK_TH1520_FM)  += clk-th1520-fm.o
+obj-$(CONFIG_CLK_TH1520_FM)  += gate/
--- /dev/null
+++ b/drivers/clk/xuantie/clk-th1520-fm.c
@@ -0,0 +1,648 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+
+#include "clk.h"
+
+static struct clk *clks[CLK_END];
+static struct clk_onecell_data clk_data;
+
+/* Th1520 Fullmask */
+static u32 share_cnt_x2h_cpusys_clk_en;
+static u32 share_cnt_dmac_cpusys_clk_en;
+static u32 share_cnt_timer0_clk_en;
+static u32 share_cnt_timer1_clk_en;
+static u32 share_cnt_axi4_cpusys2_clk_en;
+static u32 share_cnt_bmu_c910_clk_en;
+static u32 share_cnt_aon2cpu_a2x_clk_en;
+static u32 share_cnt_chip_dbg_clk_en;
+static u32 share_cnt_x2x_cpusys_clk_en;
+static u32 share_cnt_cfg2tee_x2h_clk_en;
+static u32 share_cnt_cpu2aon_x2h_clk_en;
+static u32 share_cnt_cpu2vp_x2p_clk_en;
+static u32 share_cnt_npu_core_clk_en;
+static u32 share_cnt_cpu2peri_x2h_clk_en;
+static u32 share_cnt_cpu2vi_x2h_clk_en;
+static u32 share_cnt_vpsys_axi_aclk_en;
+static u32 share_cnt_gmac1_clk_en;
+static u32 share_cnt_gmac0_clk_en;
+static u32 share_cnt_perisys_apb3_hclk_en;
+static u32 share_cnt_qspi0_clk_en;
+static u32 share_cnt_gmac_axi_clk_en;
+static u32 share_cnt_gpio0_clk_en;
+static u32 share_cnt_gpio1_clk_en;
+static u32 share_cnt_pwm_clk_en;
+static u32 share_cnt_spi_clk_en;
+static u32 share_cnt_uart0_clk_en;
+static u32 share_cnt_uart2_clk_en;
+static u32 share_cnt_i2c2_clk_en;
+static u32 share_cnt_i2c3_clk_en;
+static u32 share_cnt_peri_i2s_clk_en;
+static u32 share_cnt_qspi1_clk_en;
+static u32 share_cnt_uart1_clk_en;
+static u32 share_cnt_uart3_clk_en;
+static u32 share_cnt_uart4_clk_en;
+static u32 share_cnt_uart5_clk_en;
+static u32 share_cnt_i2c0_clk_en;
+static u32 share_cnt_i2c1_clk_en;
+static u32 share_cnt_i2c4_clk_en;
+static u32 share_cnt_i2c5_clk_en;
+static u32 share_cnt_gpio2_clk_en;
+static u32 share_cnt_gpio3_clk_en;
+static u32 share_cnt_vosys_axi_aclk_en;
+
+/* Th1520 Fullmask PLL Bypass */
+static const char * const cpu_pll0_bypass_sels[] = {"cpu_pll0_foutpostdiv", "osc_24m", };
+static const char * const cpu_pll1_bypass_sels[] = {"cpu_pll1_foutpostdiv", "osc_24m", };
+static const char * const gmac_pll_bypass_sels[] = {"gmac_pll_foutpostdiv", "osc_24m", };
+static const char * const video_pll_bypass_sels[] = {"video_pll_foutpostdiv", "osc_24m", };
+static const char * const tee_pll_bypass_sels[] = {"tee_pll_foutpostdiv", "osc_24m"};
+static const char * const dpu0_pll_bypass_sels[] = {"dpu0_pll_foutpostdiv", "osc_24m"};
+static const char * const dpu1_pll_bypass_sels[] = {"dpu1_pll_foutpostdiv", "osc_24m"};
+
+/* th1520 fullmask mux */
+static const char * const ahb2_cpusys_hclk_sels[] = {"ahb2_cpusys_hclk_out_div", "osc_24m"};
+static const char * const c910_cclk_i0_sels[] = {"cpu_pll0_foutpostdiv", "osc_24m"};
+static const char * const c910_cclk_sels[] = {"c910_cclk_i0", "cpu_pll1_foutpostdiv"};
+static const char * const cfg_axi_aclk_sels[] = {"cfg_axi_aclk_out_div", "osc_24m"};
+static const char * const teesys_hclk_sels[] = {"teesys_i1_hclk", "teesys_i0_hclk"};
+static const char * const perisys_ahb_hclk_sels[] = {"perisys_ahb_hclk_out_div", "osc_24m"};
+static const char * const clk_out_1_sels[] = {"osc_24m", "clk_out_1_out_div"};
+static const char * const clk_out_2_sels[] = {"osc_24m", "clk_out_2_out_div"};
+static const char * const clk_out_3_sels[] = {"osc_24m", "clk_out_3_out_div"};
+static const char * const clk_out_4_sels[] = {"osc_24m", "clk_out_4_out_div"};
+static const char * const peri_i2s_src_clk_sels[] = {"clkgen_peri_i2s_src_clk_0", "clkgen_peri_i2s_src_clk_1"};
+static const char * const npu_cclk_sels[] = {"gmac_pll_foutpostdiv", "npu_cclk_out_div"};
+static const char * const cfg_apb_pclk_sels[] = {"cfg_apb_pclk_out_div", "osc_24m"};
+static const char * const uart_sclk_sels[] = {"clk_100m", "osc_24m"};
+
+static const struct th1520_pll_rate_table th1520_cpupll_tbl[] = {
+	TH1520_PLL_RATE(2616000000U, 2616000000U, 1, 109, 0, 1, 1),
+	TH1520_PLL_RATE(2592000000U, 2592000000U, 1, 108, 0, 1, 1),
+	TH1520_PLL_RATE(2568000000U, 2568000000U, 1, 107, 0, 1, 1),
+	TH1520_PLL_RATE(2544000000U, 2544000000U, 1, 106, 0, 1, 1),
+	TH1520_PLL_RATE(2520000000U, 2520000000U, 1, 105, 0, 1, 1),
+	TH1520_PLL_RATE(2496000000U, 2496000000U, 1, 104, 0, 1, 1),
+	TH1520_PLL_RATE(2472000000U, 2472000000U, 1, 103, 0, 1, 1),
+	TH1520_PLL_RATE(2448000000U, 2448000000U, 1, 102, 0, 1, 1),
+	TH1520_PLL_RATE(2424000000U, 2424000000U, 1, 101, 0, 1, 1),
+	TH1520_PLL_RATE(2400000000U, 2400000000U, 1, 100, 0, 1, 1),
+	TH1520_PLL_RATE(2376000000U, 2376000000U, 1, 99,  0, 1, 1),
+	TH1520_PLL_RATE(2352000000U, 2352000000U, 1, 98,  0, 1, 1),
+	TH1520_PLL_RATE(2328000000U, 2328000000U, 1, 97,  0, 1, 1),
+	TH1520_PLL_RATE(2304000000U, 2304000000U, 1, 96,  0, 1, 1),
+	TH1520_PLL_RATE(2280000000U, 2280000000U, 1, 95,  0, 1, 1),
+	TH1520_PLL_RATE(2256000000U, 2256000000U, 1, 94,  0, 1, 1),
+	TH1520_PLL_RATE(2232000000U, 2232000000U, 1, 93,  0, 1, 1),
+	TH1520_PLL_RATE(2208000000U, 2208000000U, 1, 92,  0, 1, 1),
+	TH1520_PLL_RATE(2184000000U, 2184000000U, 1, 91,  0, 1, 1),
+	TH1520_PLL_RATE(2160000000U, 2160000000U, 1, 90,  0, 1, 1),
+	TH1520_PLL_RATE(2136000000U, 2136000000U, 1, 89,  0, 1, 1),
+	TH1520_PLL_RATE(2112000000U, 2112000000U, 1, 88,  0, 1, 1),
+	TH1520_PLL_RATE(2088000000U, 2088000000U, 1, 87,  0, 1, 1),
+	TH1520_PLL_RATE(2064000000U, 2064000000U, 1, 86,  0, 1, 1),
+	TH1520_PLL_RATE(2040000000U, 2040000000U, 1, 85,  0, 1, 1),
+	TH1520_PLL_RATE(2016000000U, 2016000000U, 1, 84,  0, 1, 1),
+	TH1520_PLL_RATE(1992000000U, 1992000000U, 1, 83,  0, 1, 1),
+	TH1520_PLL_RATE(1968000000U, 1968000000U, 1, 82,  0, 1, 1),
+	TH1520_PLL_RATE(1944000000U, 1944000000U, 1, 81,  0, 1, 1),
+	TH1520_PLL_RATE(1920000000U, 1920000000U, 1, 80,  0, 1, 1),
+	TH1520_PLL_RATE(1896000000U, 1896000000U, 1, 79,  0, 1, 1),
+	TH1520_PLL_RATE(1872000000U, 1872000000U, 1, 78,  0, 1, 1),
+	TH1520_PLL_RATE(1848000000U, 1848000000U, 1, 77,  0, 1, 1),
+	TH1520_PLL_RATE(1824000000U, 1824000000U, 1, 76,  0, 1, 1),
+	TH1520_PLL_RATE(1800000000U, 1800000000U, 1, 75,  0, 1, 1),
+	TH1520_PLL_RATE(1776000000U, 1776000000U, 1, 74,  0, 1, 1),
+	TH1520_PLL_RATE(1752000000U, 1752000000U, 1, 73,  0, 1, 1),
+	TH1520_PLL_RATE(1728000000U, 1728000000U, 1, 72,  0, 1, 1),
+	TH1520_PLL_RATE(1704000000U, 1704000000U, 1, 71,  0, 1, 1),
+	TH1520_PLL_RATE(1680000000U, 1680000000U, 1, 70,  0, 1, 1),
+	TH1520_PLL_RATE(1656000000U, 1656000000U, 1, 69,  0, 1, 1),
+	TH1520_PLL_RATE(1632000000U, 1632000000U, 1, 68,  0, 1, 1),
+	TH1520_PLL_RATE(1608000000U, 1608000000U, 1, 67,  0, 1, 1),
+	TH1520_PLL_RATE(1584000000U, 1584000000U, 1, 66,  0, 1, 1),
+	TH1520_PLL_RATE(1560000000U, 1560000000U, 1, 65,  0, 1, 1),
+	TH1520_PLL_RATE(1536000000U, 1536000000U, 1, 64,  0, 1, 1),
+	TH1520_PLL_RATE(1512000000U, 1512000000U, 1, 63,  0, 1, 1),
+	TH1520_PLL_RATE(3000000000U, 1500000000U, 1, 125, 0, 2, 1),
+	TH1520_PLL_RATE(2976000000U, 1488000000U, 1, 124, 0, 2, 1),
+	TH1520_PLL_RATE(2952000000U, 1476000000U, 1, 123, 0, 2, 1),
+	TH1520_PLL_RATE(2928000000U, 1464000000U, 1, 122, 0, 2, 1),
+	TH1520_PLL_RATE(2904000000U, 1452000000U, 1, 121, 0, 2, 1),
+	TH1520_PLL_RATE(2880000000U, 1440000000U, 1, 120, 0, 2, 1),
+	TH1520_PLL_RATE(2856000000U, 1428000000U, 1, 119, 0, 2, 1),
+	TH1520_PLL_RATE(2832000000U, 1416000000U, 1, 118, 0, 2, 1),
+	TH1520_PLL_RATE(2808000000U, 1404000000U, 1, 117, 0, 2, 1),
+	TH1520_PLL_RATE(2784000000U, 1392000000U, 1, 116, 0, 2, 1),
+	TH1520_PLL_RATE(2760000000U, 1380000000U, 1, 115, 0, 2, 1),
+	TH1520_PLL_RATE(2736000000U, 1368000000U, 1, 114, 0, 2, 1),
+	TH1520_PLL_RATE(2712000000U, 1356000000U, 1, 113, 0, 2, 1),
+	TH1520_PLL_RATE(2688000000U, 1344000000U, 1, 112, 0, 2, 1),
+	TH1520_PLL_RATE(2664000000U, 1332000000U, 1, 111, 0, 2, 1),
+	TH1520_PLL_RATE(2640000000U, 1320000000U, 1, 110, 0, 2, 1),
+	TH1520_PLL_RATE(2616000000U, 1308000000U, 1, 109, 0, 2, 1),
+	TH1520_PLL_RATE(2592000000U, 1296000000U, 1, 108, 0, 2, 1),
+	TH1520_PLL_RATE(2568000000U, 1284000000U, 1, 107, 0, 2, 1),
+	TH1520_PLL_RATE(2544000000U, 1272000000U, 1, 106, 0, 2, 1),
+	TH1520_PLL_RATE(2520000000U, 1260000000U, 1, 105, 0, 2, 1),
+	TH1520_PLL_RATE(2496000000U, 1248000000U, 1, 104, 0, 2, 1),
+	TH1520_PLL_RATE(2472000000U, 1236000000U, 1, 103, 0, 2, 1),
+	TH1520_PLL_RATE(2448000000U, 1224000000U, 1, 102, 0, 2, 1),
+	TH1520_PLL_RATE(2424000000U, 1212000000U, 1, 101, 0, 2, 1),
+	TH1520_PLL_RATE(2400000000U, 1200000000U, 1, 100, 0, 2, 1),
+	TH1520_PLL_RATE(2376000000U, 1188000000U, 1, 99,  0, 2, 1),
+	TH1520_PLL_RATE(2352000000U, 1176000000U, 1, 98,  0, 2, 1),
+	TH1520_PLL_RATE(2328000000U, 1164000000U, 1, 97,  0, 2, 1),
+	TH1520_PLL_RATE(2304000000U, 1152000000U, 1, 96,  0, 2, 1),
+	TH1520_PLL_RATE(2280000000U, 1140000000U, 1, 95,  0, 2, 1),
+	TH1520_PLL_RATE(2256000000U, 1128000000U, 1, 94,  0, 2, 1),
+	TH1520_PLL_RATE(2232000000U, 1116000000U, 1, 93,  0, 2, 1),
+	TH1520_PLL_RATE(2208000000U, 1104000000U, 1, 92,  0, 2, 1),
+	TH1520_PLL_RATE(2184000000U, 1092000000U, 1, 91,  0, 2, 1),
+	TH1520_PLL_RATE(2160000000U, 1080000000U, 1, 90,  0, 2, 1),
+	TH1520_PLL_RATE(2136000000U, 1068000000U, 1, 89,  0, 2, 1),
+	TH1520_PLL_RATE(2112000000U, 1056000000U, 1, 88,  0, 2, 1),
+	TH1520_PLL_RATE(2088000000U, 1044000000U, 1, 87,  0, 2, 1),
+	TH1520_PLL_RATE(2064000000U, 1032000000U, 1, 86,  0, 2, 1),
+	TH1520_PLL_RATE(2040000000U, 1020000000U, 1, 85,  0, 2, 1),
+	TH1520_PLL_RATE(2016000000U, 1008000000U, 1, 84,  0, 2, 1),
+	TH1520_PLL_RATE(3000000000U, 1000000000U, 1, 125, 0, 3, 1),
+	TH1520_PLL_RATE(2976000000U, 992000000U,  1, 124, 0, 3, 1),
+	TH1520_PLL_RATE(2952000000U, 984000000U,  1, 123, 0, 3, 1),
+	TH1520_PLL_RATE(2928000000U, 976000000U,  1, 122, 0, 3, 1),
+	TH1520_PLL_RATE(2904000000U, 968000000U,  1, 121, 0, 3, 1),
+	TH1520_PLL_RATE(2880000000U, 960000000U,  1, 120, 0, 3, 1),
+	TH1520_PLL_RATE(2856000000U, 952000000U,  1, 119, 0, 3, 1),
+	TH1520_PLL_RATE(2832000000U, 944000000U,  1, 118, 0, 3, 1),
+	TH1520_PLL_RATE(2808000000U, 936000000U,  1, 117, 0, 3, 1),
+	TH1520_PLL_RATE(2784000000U, 928000000U,  1, 116, 0, 3, 1),
+	TH1520_PLL_RATE(2760000000U, 920000000U,  1, 115, 0, 3, 1),
+	TH1520_PLL_RATE(2736000000U, 912000000U,  1, 114, 0, 3, 1),
+	TH1520_PLL_RATE(2712000000U, 904000000U,  1, 113, 0, 3, 1),
+	TH1520_PLL_RATE(1800000000U, 900000000U,  1, 75,  0, 2, 1),
+	TH1520_PLL_RATE(2688000000U, 896000000U,  1, 112, 0, 3, 1),
+	TH1520_PLL_RATE(2664000000U, 888000000U,  1, 111, 0, 3, 1),
+	TH1520_PLL_RATE(2640000000U, 880000000U,  1, 110, 0, 3, 1),
+	TH1520_PLL_RATE(2616000000U, 872000000U,  1, 109, 0, 3, 1),
+	TH1520_PLL_RATE(2592000000U, 864000000U,  1, 108, 0, 3, 1),
+	TH1520_PLL_RATE(2568000000U, 856000000U,  1, 107, 0, 3, 1),
+	TH1520_PLL_RATE(2544000000U, 848000000U,  1, 106, 0, 3, 1),
+	TH1520_PLL_RATE(2520000000U, 840000000U,  1, 105, 0, 3, 1),
+	TH1520_PLL_RATE(2496000000U, 832000000U,  1, 104, 0, 3, 1),
+	TH1520_PLL_RATE(2472000000U, 824000000U,  1, 103, 0, 3, 1),
+	TH1520_PLL_RATE(2448000000U, 816000000U,  1, 102, 0, 3, 1),
+	TH1520_PLL_RATE(2424000000U, 808000000U,  1, 101, 0, 3, 1),
+	TH1520_PLL_RATE(2400000000U, 800000000U,  1, 100, 0, 3, 1),
+	TH1520_PLL_RATE(2376000000U, 792000000U,  1, 99,  0, 3, 1),
+	TH1520_PLL_RATE(2352000000U, 784000000U,  1, 98,  0, 3, 1),
+	TH1520_PLL_RATE(2328000000U, 776000000U,  1, 97,  0, 3, 1),
+	TH1520_PLL_RATE(2304000000U, 768000000U,  1, 96,  0, 3, 1),
+	TH1520_PLL_RATE(2280000000U, 760000000U,  1, 95,  0, 3, 1),
+	TH1520_PLL_RATE(2256000000U, 752000000U,  1, 94,  0, 3, 1),
+	TH1520_PLL_RATE(2232000000U, 744000000U,  1, 93,  0, 3, 1),
+	TH1520_PLL_RATE(2208000000U, 736000000U,  1, 92,  0, 3, 1),
+	TH1520_PLL_RATE(2184000000U, 728000000U,  1, 91,  0, 3, 1),
+	TH1520_PLL_RATE(2160000000U, 720000000U,  1, 90,  0, 3, 1),
+	TH1520_PLL_RATE(2136000000U, 712000000U,  1, 89,  0, 3, 1),
+	TH1520_PLL_RATE(2808000000U, 702000000U,  1, 117, 0, 4, 1),
+	TH1520_PLL_RATE(2760000000U, 690000000U,  1, 115, 0, 4, 1),
+	TH1520_PLL_RATE(2712000000U, 678000000U,  1, 113, 0, 4, 1),
+	TH1520_PLL_RATE(2664000000U, 666000000U,  1, 111, 0, 4, 1),
+	TH1520_PLL_RATE(2616000000U, 654000000U,  1, 109, 0, 4, 1),
+	TH1520_PLL_RATE(2568000000U, 642000000U,  1, 107, 0, 4, 1),
+	TH1520_PLL_RATE(2520000000U, 630000000U,  1, 105, 0, 4, 1),
+	TH1520_PLL_RATE(2472000000U, 618000000U,  1, 103, 0, 4, 1),
+	TH1520_PLL_RATE(2424000000U, 606000000U,  1, 101, 0, 4, 1),
+	TH1520_PLL_RATE(3000000000U, 600000000U,  1, 125, 0, 5, 1),
+	TH1520_PLL_RATE(2952000000U, 590400000U,  1, 123, 0, 5, 1),
+	TH1520_PLL_RATE(2904000000U, 580800000U,  1, 121, 0, 5, 1),
+	TH1520_PLL_RATE(2856000000U, 571200000U,  1, 119, 0, 5, 1),
+	TH1520_PLL_RATE(2808000000U, 561600000U,  1, 117, 0, 5, 1),
+	TH1520_PLL_RATE(2760000000U, 552000000U,  1, 115, 0, 5, 1),
+	TH1520_PLL_RATE(2712000000U, 542400000U,  1, 113, 0, 5, 1),
+	TH1520_PLL_RATE(2664000000U, 532800000U,  1, 111, 0, 5, 1),
+	TH1520_PLL_RATE(2616000000U, 523200000U,  1, 109, 0, 5, 1),
+	TH1520_PLL_RATE(2568000000U, 513600000U,  1, 107, 0, 5, 1),
+	TH1520_PLL_RATE(2520000000U, 504000000U,  1, 105, 0, 5, 1),
+	TH1520_PLL_RATE(3000000000U, 500000000U,  1, 125, 0, 6, 1),
+	TH1520_PLL_RATE(2952000000U, 492000000U,  1, 123, 0, 6, 1),
+	TH1520_PLL_RATE(2904000000U, 484000000U,  1, 121, 0, 6, 1),
+	TH1520_PLL_RATE(2856000000U, 476000000U,  1, 119, 0, 6, 1),
+	TH1520_PLL_RATE(2808000000U, 468000000U,  1, 117, 0, 6, 1),
+	TH1520_PLL_RATE(2760000000U, 460000000U,  1, 115, 0, 6, 1),
+	TH1520_PLL_RATE(2712000000U, 452000000U,  1, 113, 0, 6, 1),
+	TH1520_PLL_RATE(2664000000U, 444000000U,  1, 111, 0, 6, 1),
+	TH1520_PLL_RATE(2616000000U, 436000000U,  1, 109, 0, 6, 1),
+	TH1520_PLL_RATE(2568000000U, 428000000U,  1, 107, 0, 6, 1),
+	TH1520_PLL_RATE(2520000000U, 420000000U,  1, 105, 0, 6, 1),
+	TH1520_PLL_RATE(2472000000U, 412000000U,  1, 103, 0, 6, 1),
+	TH1520_PLL_RATE(2400000000U, 400000000U,  1, 100, 0, 3, 2),
+	TH1520_PLL_RATE(2352000000U, 392000000U,  1, 98,  0, 3, 2),
+	TH1520_PLL_RATE(2304000000U, 384000000U,  1, 96,  0, 3, 2),
+	TH1520_PLL_RATE(2256000000U, 376000000U,  1, 94,  0, 3, 2),
+	TH1520_PLL_RATE(2208000000U, 368000000U,  1, 92,  0, 3, 2),
+	TH1520_PLL_RATE(2160000000U, 360000000U,  1, 90,  0, 3, 2),
+	TH1520_PLL_RATE(2112000000U, 352000000U,  1, 88,  0, 3, 2),
+	TH1520_PLL_RATE(2064000000U, 344000000U,  1, 86,  0, 3, 2),
+	TH1520_PLL_RATE(2016000000U, 336000000U,  1, 84,  0, 3, 2),
+	TH1520_PLL_RATE(1968000000U, 328000000U,  1, 82,  0, 3, 2),
+	TH1520_PLL_RATE(1920000000U, 320000000U,  1, 80,  0, 3, 2),
+	TH1520_PLL_RATE(1872000000U, 312000000U,  1, 78,  0, 3, 2),
+	TH1520_PLL_RATE(1824000000U, 304000000U,  1, 76,  0, 3, 2),
+	TH1520_PLL_RATE(3000000000U, 300000000U,  1, 125, 0, 5, 2),
+	TH1520_PLL_RATE(2880000000U, 288000000U,  1, 120, 0, 5, 2),
+	TH1520_PLL_RATE(2760000000U, 276000000U,  1, 115, 0, 5, 2),
+	TH1520_PLL_RATE(2640000000U, 264000000U,  1, 110, 0, 5, 2),
+	TH1520_PLL_RATE(2520000000U, 252000000U,  1, 105, 0, 5, 2),
+	TH1520_PLL_RATE(2400000000U, 240000000U,  1, 100, 0, 5, 2),
+	TH1520_PLL_RATE(2280000000U, 228000000U,  1, 95,  0, 5, 2),
+	TH1520_PLL_RATE(2160000000U, 216000000U,  1, 90,  0, 5, 2),
+	TH1520_PLL_RATE(2040000000U, 204000000U,  1, 85,  0, 5, 2),
+	TH1520_PLL_RATE(3000000000U, 200000000U,  1, 125, 0, 5, 3),
+	TH1520_PLL_RATE(2880000000U, 192000000U,  1, 120, 0, 5, 3),
+	TH1520_PLL_RATE(2760000000U, 184000000U,  1, 115, 0, 5, 3),
+	TH1520_PLL_RATE(2640000000U, 176000000U,  1, 110, 0, 5, 3),
+	TH1520_PLL_RATE(2520000000U, 168000000U,  1, 105, 0, 5, 3),
+	TH1520_PLL_RATE(2400000000U, 160000000U,  1, 100, 0, 5, 3),
+	TH1520_PLL_RATE(2280000000U, 152000000U,  1, 95,  0, 5, 3),
+	TH1520_PLL_RATE(2160000000U, 144000000U,  1, 90,  0, 5, 3),
+	TH1520_PLL_RATE(2040000000U, 136000000U,  1, 85,  0, 5, 3),
+	TH1520_PLL_RATE(1920000000U, 128000000U,  1, 80,  0, 5, 3),
+	TH1520_PLL_RATE(3000000000U, 125000000U,  1, 125, 0, 6, 4),
+	TH1520_PLL_RATE(2760000000U, 115000000U,  1, 115, 0, 6, 4),
+	TH1520_PLL_RATE(2520000000U, 105000000U,  1, 105, 0, 6, 4),
+	TH1520_PLL_RATE(2280000000U, 95000000U,   1, 95,  0, 6, 4),
+	TH1520_PLL_RATE(2040000000U, 85000000U,   1, 85,  0, 6, 4),
+	TH1520_PLL_RATE(1800000000U, 75000000U,   1, 75,  0, 6, 4),
+	TH1520_PLL_RATE(1560000000U, 65000000U,   1, 65,  0, 6, 4),
+	TH1520_PLL_RATE(1320000000U, 55000000U,   1, 55,  0, 6, 4),
+};
+
+static const struct th1520_pll_rate_table th1520_dpupll_tbl[] = {
+	TH1520_PLL_RATE(2376000000U, 1188000000U, 1, 99, 0, 2, 1),
+	TH1520_PLL_RATE(1980000000U, 990000000U, 2, 165, 0, 2, 1),
+	TH1520_PLL_RATE(2970000000U, 742500000U, 4, 495, 0, 4, 1),
+	TH1520_PLL_RATE(2304000000U, 1152000000U, 1, 96, 0, 2, 1),
+	TH1520_PLL_RATE(1512000000U, 504000000U, 1, 63, 0, 3, 1),
+	TH1520_PLL_RATE(1512000000U, 503500000U, 1, 63, 0, 3, 1),
+	TH1520_PLL_RATE(2898000000U, 483000000U, 4, 483, 0, 6, 1),
+	TH1520_PLL_RATE(2592000000U, 648000000U, 1, 108, 0, 4, 1),
+	TH1520_PLL_RATE(2772000000U, 924000000U, 2, 231, 0, 3, 1),
+	TH1520_PLL_RATE(2856000000U, 476000000U, 1, 119, 0, 6, 1),
+	TH1520_PLL_RATE(2130000000U, 355000000U, 4, 355, 0, 6, 1),
+	TH1520_PLL_RATE(3192000000U, 456000000U, 1, 133, 0, 7, 1),
+	TH1520_PLL_RATE(2730000000U, 390000000U, 4, 455, 0, 7, 1),
+	TH1520_PLL_RATE(1680000000U, 240000000U, 1, 70, 0, 7, 1),
+	TH1520_PLL_RATE(2832000000U, 708000000U, 1, 118, 0, 4, 1),
+	TH1520_PLL_RATE(1026000000U, 342000000U, 4, 171, 0, 3, 1),
+	TH1520_PLL_RATE(1260000000U, 630000000U, 4, 210, 0, 2, 1),
+};
+
+static struct th1520_pll_clk th1520_cpu_pll0div = {
+	.out_type = TH1520_PLL_DIV,
+	.clk_type = TH1520_CPU_PLL0,
+	.rate_table = th1520_cpupll_tbl,
+	.rate_count = ARRAY_SIZE(th1520_cpupll_tbl),
+};
+
+static struct th1520_pll_clk th1520_cpu_pll1div = {
+	.out_type = TH1520_PLL_DIV,
+	.clk_type = TH1520_CPU_PLL1,
+	.rate_table = th1520_cpupll_tbl,
+	.rate_count = ARRAY_SIZE(th1520_cpupll_tbl),
+};
+
+static struct th1520_pll_clk th1520_dpu0_plldiv = {
+	.out_type = TH1520_PLL_DIV,
+	.clk_type = TH1520_DPU0_PLL,
+	.rate_table = th1520_dpupll_tbl,
+	.rate_count = ARRAY_SIZE(th1520_dpupll_tbl),
+};
+
+static struct th1520_pll_clk th1520_dpu1_plldiv = {
+	.out_type = TH1520_PLL_DIV,
+	.clk_type = TH1520_DPU1_PLL,
+	.rate_table = th1520_dpupll_tbl,
+	.rate_count = ARRAY_SIZE(th1520_dpupll_tbl),
+};
+
+static int th1520_clocks_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	void __iomem *ap_base;
+	int ret;
+	const bool *teesys = of_device_get_match_data(dev);
+
+	pr_info("%s !!! start !\n", __func__);
+
+	/* Clock source */
+	clks[CLK_DUMMY] = xuantie_clk_fixed("dummy", 0);
+	clks[OSC_32K] = of_clk_get_by_name(np, "osc_32k");
+	clks[OSC_24M] = of_clk_get_by_name(np, "osc_24m");
+	clks[RC_24M] = of_clk_get_by_name(np, "rc_24m");
+
+	np = dev->of_node;
+	ap_base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(ap_base))) {
+		ret = PTR_ERR(ap_base);
+		goto unregister_clks;
+	}
+
+	/* Th1520 Fullmask AP PLL clocks */
+	clks[CPU_PLL0_FOUTPOSTDIV] = xuantie_th1520_pll("cpu_pll0_foutpostdiv", "osc_24m", ap_base, &th1520_cpu_pll0div);
+	clks[CPU_PLL1_FOUTPOSTDIV] = xuantie_th1520_pll("cpu_pll1_foutpostdiv", "osc_24m", ap_base, &th1520_cpu_pll1div);
+
+	clks[DPU0_PLL_FOUTPOSTDIV] = xuantie_th1520_pll("dpu0_pll_foutpostdiv", "osc_24m", ap_base, &th1520_dpu0_plldiv);
+	clks[DPU1_PLL_FOUTPOSTDIV] = xuantie_th1520_pll("dpu1_pll_foutpostdiv", "osc_24m", ap_base, &th1520_dpu1_plldiv);
+
+	/* Th1520 Fullmask AP Fixed PLL */
+	clks[GMAC_PLL_FOUTPOSTDIV] = xuantie_clk_fixed("gmac_pll_foutpostdiv", 1000000000);
+	clks[VIDEO_PLL_FOUTPOSTDIV] = xuantie_clk_fixed("video_pll_foutpostdiv", 792000000);
+	clks[VIDEO_PLL_FOUTVCO] = xuantie_clk_fixed("video_pll_foutvco", 2376000000);
+	clks[TEE_PLL_FOUTPOSTDIV] = xuantie_clk_fixed("tee_pll_foutpostdiv", 792000000);
+	clks[CLKGEN_PERI_I2S_SRC_CLK_0] = xuantie_clk_fixed("clkgen_peri_i2s_src_clk_0", 294912000);	//from audio_pll_foutpostdiv
+	clks[CLKGEN_PERI_I2S_SRC_CLK_1] = xuantie_clk_fixed("clkgen_peri_i2s_src_clk_1", 135475200);	//from sys_pll_foutpostdiv
+	clks[CLKGEN_C910_BUS_CLK_NO_ICG] = xuantie_clk_fixed("clkgen_c910_bus_clk_no_icg", 750000000);
+	clks[AONSYS_BUS_CLK] = xuantie_clk_fixed("aonsys_hclk", 101606400);	//from sys_pll, maybe change ?
+
+	/* Th1520 Fullmask AP MUX */
+	clks[CPU_PLL0_BYPASS] = xuantie_th1520_clk_mux_flags("cpu_pll0_bypass", ap_base + 0x4, 30, 1, cpu_pll0_bypass_sels, ARRAY_SIZE(cpu_pll0_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CPU_PLL1_BYPASS] = xuantie_th1520_clk_mux_flags("cpu_pll1_bypass", ap_base + 0x14, 30, 1, cpu_pll1_bypass_sels, ARRAY_SIZE(cpu_pll1_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[GMAC_PLL_BYPASS] = xuantie_th1520_clk_mux_flags("gmac_pll_bypass", ap_base + 0x24, 30, 1, gmac_pll_bypass_sels, ARRAY_SIZE(gmac_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[VIDEO_PLL_BYPASS] = xuantie_th1520_clk_mux_flags("video_pll_bypass", ap_base + 0x34, 30, 1, video_pll_bypass_sels, ARRAY_SIZE(video_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[TEE_PLL_BYPASS] = xuantie_th1520_clk_mux_flags("tee_pll_bypass", ap_base + 0x64, 30, 1, tee_pll_bypass_sels, ARRAY_SIZE(tee_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[DPU0_PLL_BYPASS] = xuantie_th1520_clk_mux_flags("dpu0_pll_bypass", ap_base + 0x44, 30, 1, dpu0_pll_bypass_sels, ARRAY_SIZE(dpu0_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[DPU1_PLL_BYPASS] = xuantie_th1520_clk_mux_flags("dpu1_pll_bypass", ap_base + 0x54, 30, 1, dpu1_pll_bypass_sels, ARRAY_SIZE(dpu1_pll_bypass_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+
+	clks[AHB2_CPUSYS_HCLK] = xuantie_th1520_clk_mux_flags("ahb2_cpusys_hclk", ap_base + 0x120, 5, 1, ahb2_cpusys_hclk_sels, ARRAY_SIZE(ahb2_cpusys_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[C910_CCLK_I0] = xuantie_th1520_clk_mux_flags("c910_cclk_i0", ap_base + 0x100, 1, 1, c910_cclk_i0_sels, ARRAY_SIZE(c910_cclk_i0_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[C910_CCLK] = xuantie_th1520_clk_mux_flags("c910_cclk", ap_base + 0x100, 0, 1, c910_cclk_sels, ARRAY_SIZE(c910_cclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CFG_AXI_ACLK] = xuantie_th1520_clk_mux_flags("cfg_axi_aclk", ap_base + 0x138, 5, 1, cfg_axi_aclk_sels, ARRAY_SIZE(cfg_axi_aclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+
+	if (teesys)
+		clks[TEESYS_HCLK] = xuantie_th1520_clk_mux_flags("teesys_hclk", ap_base + 0x1cc, 13, 1, teesys_hclk_sels, ARRAY_SIZE(teesys_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT); //just for teesys!!!
+
+	clks[PERISYS_AHB_HCLK] = xuantie_th1520_clk_mux_flags("perisys_ahb_hclk", ap_base + 0x140, 5, 1, perisys_ahb_hclk_sels, ARRAY_SIZE(perisys_ahb_hclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CLK_OUT_1] = xuantie_th1520_clk_mux_flags("clk_out_1", ap_base + 0x1b4, 4, 1, clk_out_1_sels, ARRAY_SIZE(clk_out_1_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CLK_OUT_2] = xuantie_th1520_clk_mux_flags("clk_out_2", ap_base + 0x1b8, 4, 1, clk_out_2_sels, ARRAY_SIZE(clk_out_2_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CLK_OUT_3] = xuantie_th1520_clk_mux_flags("clk_out_3", ap_base + 0x1bc, 4, 1, clk_out_3_sels, ARRAY_SIZE(clk_out_3_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[CLK_OUT_4] = xuantie_th1520_clk_mux_flags("clk_out_4", ap_base + 0x1c0, 4, 1, clk_out_4_sels, ARRAY_SIZE(clk_out_4_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[PERI_I2S_SRC_CLK] = xuantie_th1520_clk_mux_flags("peri_i2s_src_clk", ap_base + 0x1f0, 0, 1, peri_i2s_src_clk_sels, ARRAY_SIZE(peri_i2s_src_clk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[NPU_CCLK] = xuantie_th1520_clk_mux_flags("npu_cclk", ap_base + 0x1c8, 6, 1, npu_cclk_sels, ARRAY_SIZE(npu_cclk_sels), CLK_SET_RATE_PARENT);
+	clks[CFG_APB_PCLK] = xuantie_th1520_clk_mux_flags("cfg_apb_pclk", ap_base + 0x1c4, 7, 1, cfg_apb_pclk_sels, ARRAY_SIZE(cfg_apb_pclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+	clks[UART_SCLK] = xuantie_th1520_clk_mux_flags("uart_sclk", ap_base + 0x210, 0, 1, uart_sclk_sels, ARRAY_SIZE(uart_sclk_sels), CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT);
+
+	/* Th1520 Fullmask AP Divider */
+	clks[AHB2_CPUSYS_HCLK_OUT_DIV] = xuantie_clk_th1520_divider("ahb2_cpusys_hclk_out_div", "gmac_pll_fout1ph0", ap_base + 0x120, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
+	clks[APB3_CPUSYS_PCLK] = xuantie_clk_th1520_divider("apb3_cpusys_pclk", "ahb2_cpusys_hclk", ap_base + 0x130, 0, 3, 3, MUX_TYPE_CDE, 1, 7);
+	clks[AXI4_CPUSYS2_ACLK] = xuantie_clk_th1520_divider("axi4_cpusys2_aclk", "gmac_pll_foutpostdiv", ap_base + 0x134, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
+	clks[CFG_AXI_ACLK_OUT_DIV] = xuantie_clk_th1520_divider("cfg_axi_aclk_out_div", "video_pll_foutpostdiv", ap_base + 0x138, 0, 4, 4, MUX_TYPE_DIV, 2, 15);
+
+	if (teesys) {
+		clks[TEESYS_I0_HCLK] = xuantie_clk_th1520_divider("teesys_i0_hclk", "tee_pll_foutpostdiv", ap_base + 0x1cc, 0, 4, 4, MUX_TYPE_DIV, 2, 15); //just for teesys!!!
+		clks[TEESYS_I1_HCLK] = xuantie_clk_th1520_divider("teesys_i1_hclk", "video_pll_foutpostdiv", ap_base + 0x1cc, 8, 4, 12, MUX_TYPE_DIV, 2, 15); //just for teesys!!!
+	}
+
+	clks[PERISYS_AHB_HCLK_OUT_DIV] = xuantie_clk_th1520_divider("perisys_ahb_hclk_out_div", "gmac_pll_fout1ph0", ap_base + 0x140, 0, 4, 4, MUX_TYPE_DIV, 2, 7);
+	clks[PERISYS_APB_PCLK] = xuantie_clk_th1520_divider("perisys_apb_pclk", "perisys_ahb_hclk", ap_base + 0x150, 0, 3, 3, MUX_TYPE_CDE, 3, 7);
+	clks[PERI2SYS_APB_PCLK] = xuantie_clk_th1520_divider("peri2sys_apb_pclk", "gmac_pll_fout4", ap_base + 0x150, 4, 3, 8, MUX_TYPE_DIV, 2, 7);
+	clks[CLK_OUT_1_OUT_DIV] = xuantie_clk_th1520_divider("clk_out_1_out_div", "osc_24m", ap_base + 0x1b4, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
+	clks[CLK_OUT_2_OUT_DIV] = xuantie_clk_th1520_divider("clk_out_2_out_div", "osc_24m", ap_base + 0x1b8, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
+	clks[CLK_OUT_3_OUT_DIV] = xuantie_clk_th1520_divider("clk_out_3_out_div", "osc_24m", ap_base + 0x1bc, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
+	clks[CLK_OUT_4_OUT_DIV] = xuantie_clk_th1520_divider("clk_out_4_out_div", "osc_24m", ap_base + 0x1c0, 0, 3, 3, MUX_TYPE_DIV, 2, 4);
+	clks[VOSYS_ACLK_M] = xuantie_clk_th1520_divider("vosys_aclk_m", "video_pll_foutvco", ap_base + 0x1dc, 0, 4, 4, MUX_TYPE_DIV, 3, 15);
+	clks[NPU_CCLK_OUT_DIV] = xuantie_clk_th1520_divider("npu_cclk_out_div", "video_pll_foutvco", ap_base + 0x1c8, 0, 3, 3, MUX_TYPE_DIV, 3, 7);
+	clks[CFG_APB_PCLK_OUT_DIV] = xuantie_clk_th1520_divider("cfg_apb_pclk_out_div", "gmac_pll_foutpostdiv", ap_base + 0x1c4, 0, 4, 4, MUX_TYPE_DIV, 4, 15);
+	clks[VISYS_ACLK_M] = xuantie_clk_th1520_divider("visys_aclk_m", "video_pll_foutvco", ap_base + 0x1d0, 16, 4, 20, MUX_TYPE_DIV, 3, 15);
+	clks[VISYS_AHB_HCLK] = xuantie_clk_th1520_divider("visys_ahb_hclk", "video_pll_foutvco", ap_base + 0x1d0, 0, 4, 4, MUX_TYPE_DIV, 6, 15);
+	clks[VPSYS_APB_PCLK] = xuantie_clk_th1520_divider("vpsys_apb_pclk", "gmac_pll_fout1ph0", ap_base + 0x1e0, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
+	clks[VPSYS_AXI_ACLK] = xuantie_clk_th1520_divider("vpsys_axi_aclk", "video_pll_foutvco", ap_base + 0x1e0, 8, 4, 12, MUX_TYPE_DIV, 3, 15);
+	clks[VENC_CCLK] = xuantie_clk_th1520_divider_closest("venc_cclk", "gmac_pll_foutpostdiv", ap_base + 0x1e4, 0, 3, 4, MUX_TYPE_DIV, 2, 7);
+	clks[DPU0_PLL_DIV_CLK] = xuantie_clk_th1520_divider("dpu0_pll_div_clk", "dpu0_pll_foutpostdiv", ap_base + 0x1e8, 0, 8, 8, MUX_TYPE_DIV, 2, 214);
+	clks[DPU1_PLL_DIV_CLK] = xuantie_clk_th1520_divider("dpu1_pll_div_clk", "dpu1_pll_foutpostdiv", ap_base + 0x1ec, 0, 8, 8, MUX_TYPE_DIV, 2, 214);
+
+	/* Th1520 Fullmask PLL FOUT */
+	clks[GMAC_PLL_FOUT1PH0] = xuantie_th1520_clk_fixed_factor("gmac_pll_fout1ph0", "gmac_pll_bypass", 1, 2);
+	clks[GMAC_PLL_FOUT4] = xuantie_th1520_clk_fixed_factor("gmac_pll_fout4", "gmac_pll_bypass", 1, 8);
+	clks[VIDEO_PLL_FOUT1PH0] = xuantie_th1520_clk_fixed_factor("video_pll_fout1ph0", "video_pll_bypass", 1, 2);
+	clks[VIDEO_PLL_FOUT4] = xuantie_th1520_clk_fixed_factor("video_pll_fout4", "video_pll_bypass", 1, 8);
+	clks[TEE_PLL_FOUT4] = xuantie_th1520_clk_fixed_factor("tee_pll_fout4", "tee_pll_bypass", 1, 8);
+	clks[CPU_PLL0_FOUT4] = xuantie_th1520_clk_fixed_factor("cpu_pll0_fout4", "cpu_pll0_bypass", 1, 8);
+	clks[CPU_PLL1_FOUT4] = xuantie_th1520_clk_fixed_factor("cpu_pll1_fout4", "cpu_pll1_bypass", 1, 8);
+	clks[DPU0_PLL_FOUT4] = xuantie_th1520_clk_fixed_factor("dpu0_pll_fout4", "dpu0_pll_bypass", 1, 8);
+	clks[DPU1_PLL_FOUT4] = xuantie_th1520_clk_fixed_factor("dpu1_pll_fout4", "dpu1_pll_bypass", 1, 8);
+
+	/* Th1520 Fullmask Fixed Factor */
+	clks[C910_OSC_CLK] = xuantie_th1520_clk_fixed_factor("c910_osc_clk", "osc_24m", 1, 1);
+	clks[QSPI_SSI_CLK] = xuantie_th1520_clk_fixed_factor("qspi_ssi_clk", "video_pll_foutpostdiv", 1, 1);		/* Note: no mux to select, use default value */
+	clks[QSPI0_SSI_CLK] = xuantie_th1520_clk_fixed_factor("qspi0_ssi_clk", "qspi_ssi_clk", 1, 1);
+	clks[QSPI1_SSI_CLK] = xuantie_th1520_clk_fixed_factor("qspi1_ssi_clk", "video_pll_fout1ph0", 1, 1);
+	clks[SPI_SSI_CLK] = xuantie_th1520_clk_fixed_factor("spi_ssi_clk", "video_pll_fout1ph0", 1, 1);
+	clks[EMMC_SDIO_REF_CLK] = xuantie_th1520_clk_fixed_factor("emmc_sdio_ref_clk", "video_pll_foutpostdiv", 1, 4);	/* Note: base clk is div 4 to 198M*/
+	clks[PWM_CCLK] = xuantie_th1520_clk_fixed_factor("pwm_cclk", "osc_24m", 1, 1);
+	clks[CHIP_DBG_CCLK] = xuantie_th1520_clk_fixed_factor("chip_dbg_cclk", "osc_24m", 1, 1);
+	clks[GMAC_CCLK] = xuantie_th1520_clk_fixed_factor("gmac_cclk", "gmac_pll_fout1ph0", 1, 1);
+	clks[GPIO0_DBCLK] = xuantie_th1520_clk_fixed_factor("gpio0_dbclk", "pad_rtc_clk", 1, 1);
+	clks[GPIO1_DBCLK] = xuantie_th1520_clk_fixed_factor("gpio1_dbclk", "pad_rtc_clk", 1, 1);
+	clks[GPIO2_DBCLK] = xuantie_th1520_clk_fixed_factor("gpio2_dbclk", "pad_rtc_clk", 1, 1);
+	clks[GPIO3_DBCLK] = xuantie_th1520_clk_fixed_factor("gpio3_dbclk", "pad_rtc_clk", 1, 1);
+	clks[CLK_100M] = xuantie_th1520_clk_fixed_factor("clk_100m", "gmac_pll_foutpostdiv", 1, 10);
+	clks[I2C_IC_CLK] = xuantie_th1520_clk_fixed_factor("i2c_ic_clk", "clk_100m", 1, 2);
+	clks[TIMER_CCLK] = xuantie_th1520_clk_fixed_factor("timer_cclk", "osc_24m", 1, 1);
+	clks[AXI4_CPUSYS1_ACLK] = xuantie_th1520_clk_fixed_factor("axi4_cpusys1_aclk", "clkgen_c910_bus_clk_no_icg", 1, 1);
+	clks[CPU_BUS_DFTCLK] = xuantie_th1520_clk_fixed_factor("cpu_bus_dftclk", "cpu_pll0_foutpostdiv", 1, 2);
+	clks[CPU_PLL0_TEST_CLK] = xuantie_th1520_clk_fixed_factor("cpu_pll0_test_clk", "cpu_pll0_fout4", 1, 8);
+	clks[CPU_PLL1_TEST_CLK] = xuantie_th1520_clk_fixed_factor("cpu_pll1_test_clk", "cpu_pll1_fout4", 1, 8);
+	clks[DPU0_PLL_TEST_CLK] = xuantie_th1520_clk_fixed_factor("dpu0_pll_test_clk", "dpu0_pll_fout4", 1, 8);
+	clks[DPU1_PLL_TEST_CLK] = xuantie_th1520_clk_fixed_factor("dpu1_pll_test_clk", "dpu1_pll_fout4", 1, 8);
+	clks[GMAC_PLL_TEST_CLK] = xuantie_th1520_clk_fixed_factor("gmac_pll_test_clk", "gmac_pll_fout4", 1, 8);
+	clks[VIDEO_PLL_TEST_CLK] = xuantie_th1520_clk_fixed_factor("video_pll_test_clk", "video_pll_fout4", 1, 8);
+	clks[TEE_PLL_TEST_CLK] = xuantie_th1520_clk_fixed_factor("tee_pll_test_clk", "tee_pll_fout4", 1, 8);
+	clks[AONSYS_BUS_CLK] = xuantie_th1520_clk_fixed_factor("aonsys_bus_clk", "aonsys_hclk", 1, 1);
+
+	/* Th1520 Fullmask Clock Gate */
+	clks[CLKGEN_AHB2_CPUSYS_HCLK] = xuantie_clk_th1520_gate("clkgen_ahb2_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x120, 6);
+	clks[CLKGEN_APB3_CPUSYS_HCLK] = xuantie_clk_th1520_gate("clkgen_apb3_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x130, 4);
+	clks[CLKGEN_C910_BROM_HCLK] = xuantie_clk_th1520_gate("clkgen_c910_brom_hclk", "ahb2_cpusys_hclk", ap_base + 0x100, 4);
+	clks[CLKGEN_SPINLOCK_HCLK] = xuantie_clk_th1520_gate("clkgen_spinlock_hclk", "ahb2_cpusys_hclk", ap_base + 0x208, 10);
+	clks[CLKGEN_MBOX0_PCLK] = xuantie_clk_th1520_gate("clkgen_mbox0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 7);
+	clks[CLKGEN_MBOX1_PCLK] = xuantie_clk_th1520_gate("clkgen_mbox1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 6);
+	clks[CLKGEN_MBOX2_PCLK] = xuantie_clk_th1520_gate("clkgen_mbox2_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 5);
+	clks[CLKGEN_MBOX3_PCLK] = xuantie_clk_th1520_gate("clkgen_mbox3_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 4);
+	clks[CLKGEN_WDT0_PCLK] = xuantie_clk_th1520_gate("clkgen_wdt0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 3);
+	clks[CLKGEN_WDT1_PCLK] = xuantie_clk_th1520_gate("clkgen_wdt1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 2);
+
+	if (teesys)
+		clks[CLKGEN_MISCSYS_TEE_CCLK] = xuantie_clk_th1520_gate("clkgen_miscsys_tee_cclk", "teesys_hclk", ap_base + 0x1cc, 25); //just for teesys!!!
+
+	clks[CLKGEN_SRAM_AXI_ACLK_2] = xuantie_clk_th1520_gate("clkgen_sram_axi_aclk_2", "axi4_cpusys1_aclk", ap_base + 0x20c, 2);
+	clks[CLKGEN_PERISYS_AHB_HCLK] = xuantie_clk_th1520_gate("clkgen_perisys_ahb_hclk", "perisys_ahb_hclk", ap_base + 0x140, 6);
+	clks[CLKGEN_PERISYS_APB1_HCLK] = xuantie_clk_th1520_gate("clkgen_perisys_apb1_hclk", "perisys_ahb_hclk", ap_base + 0x150, 9);
+	clks[CLKGEN_PERISYS_APB2_HCLK] = xuantie_clk_th1520_gate("clkgen_perisys_apb2_hclk", "perisys_ahb_hclk", ap_base + 0x150, 10);
+	clks[CLKGEN_PERISYS_APB4_HCLK] = xuantie_clk_th1520_gate("clkgen_perisys_apb4_hclk", "perisys_ahb_hclk", ap_base + 0x150, 12);
+	clks[CLKGEN_PADCTRL0_APSYS_PCLK] = xuantie_clk_th1520_gate("clkgen_padctrl0_apsys_pclk", "perisys_ahb_hclk", ap_base + 0x204, 22);
+	clks[CLKGEN_DSMART_PCLK] = xuantie_clk_th1520_gate("clkgen_dsmart_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 23);
+	clks[CLKGEN_PADCTRL1_APSYS_PCLK] = xuantie_clk_th1520_gate("clkgen_padctrl1_apsys_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 24);
+	clks[CLKGEN_CLK_OUT_1_CLK] = xuantie_clk_th1520_gate("clkgen_clk_out_1_clk", "clk_out_1", ap_base + 0x1b4, 5);
+	clks[CLKGEN_CLK_OUT_2_CLK] = xuantie_clk_th1520_gate("clkgen_clk_out_2_clk", "clk_out_2", ap_base + 0x1b8, 5);
+	clks[CLKGEN_CLK_OUT_3_CLK] = xuantie_clk_th1520_gate("clkgen_clk_out_3_clk", "clk_out_3", ap_base + 0x1bc, 5);
+	clks[CLKGEN_CLK_OUT_4_CLK] = xuantie_clk_th1520_gate("clkgen_clk_out_4_clk", "clk_out_4", ap_base + 0x1c0, 5);
+	clks[CLKGEN_NPUSYS_AXI_ACLK] = xuantie_clk_th1520_gate("clkgen_npusys_axi_aclk", "npu_cclk", ap_base + 0x1c8, 5);
+	clks[CLKGEN_SRAM_AXI_ACLK_0] = xuantie_clk_th1520_gate("clkgen_sram_axi_aclk_0", "npu_cclk", ap_base + 0x20c, 4);
+	clks[CLKGEN_APB_CPU2CFG_HCLK] = xuantie_clk_th1520_gate("clkgen_apb_cpu2cfg_hclk", "cfg_apb_pclk", ap_base + 0x1c4, 5);
+	clks[CLKGEN_SRAM_AXI_ACLK_1] = xuantie_clk_th1520_gate("clkgen_sram_axi_aclk_1", "visys_aclk_m", ap_base + 0x20c, 3);
+	clks[CLKGEN_SRAM_AXI_ACLK_3] = xuantie_clk_th1520_gate("clkgen_sram_axi_aclk_3", "vpsys_axi_aclk", ap_base + 0x20c, 1);
+	clks[CLKGEN_VPSYS_VENC_CCLK] = xuantie_clk_th1520_gate("clkgen_vpsys_venc_cclk", "venc_cclk", ap_base + 0x1e4, 5);
+	clks[CLKGEN_EMMC_SDIO_REF_CLK] = xuantie_clk_th1520_gate("clkgen_emmc_sdio_ref_clk", "emmc_sdio_ref_clk", ap_base + 0x204, 30);
+
+	clks[CLKGEN_X2H_CPUSYS_MHCLK] = xuantie_clk_th1520_gate_shared("clkgen_x2h_cpusys_mhclk", "ahb2_cpusys_hclk", ap_base + 0x120, 7, &share_cnt_x2h_cpusys_clk_en);
+	clks[CLKGEN_X2H_CPUSYS_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_x2h_cpusys_aclk", "cfg_axi_aclk", ap_base + 0x120, 7, &share_cnt_x2h_cpusys_clk_en);
+	clks[CLKGEN_DMAC_CPUSYS_HCLK] = xuantie_clk_th1520_gate_shared("clkgen_dmac_cpusys_hclk", "ahb2_cpusys_hclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
+	clks[CLKGEN_IOPMP_DMAC_CPUSYS_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_iopmp_dmac_cpusys_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
+	clks[CLKGEN_DMAC_CPUSYS_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_dmac_cpusys_aclk", "axi4_cpusys2_aclk", ap_base + 0x208, 8, &share_cnt_dmac_cpusys_clk_en);
+	clks[CLKGEN_TIMER0_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_timer0_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 1, &share_cnt_timer0_clk_en);
+	clks[CLKGEN_TIMER0_CCLK] = xuantie_clk_th1520_gate_shared("clkgen_timer0_cclk", "timer_cclk", ap_base + 0x208, 1, &share_cnt_timer0_clk_en);
+	clks[CLKGEN_TIMER1_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_timer1_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 0, &share_cnt_timer1_clk_en);
+	clks[CLKGEN_TIMER1_CCLK] = xuantie_clk_th1520_gate_shared("clkgen_timer1_cclk", "timer_cclk", ap_base + 0x208, 0, &share_cnt_timer1_clk_en);
+	clks[CLKGEN_AXI4_CPUSYS2_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_axi4_cpusys2_pclk", "apb3_cpusys_pclk", ap_base + 0x134, 5, &share_cnt_axi4_cpusys2_clk_en);
+	clks[CLKGEN_AXI4_CPUSYS2_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_axi4_cpusys2_aclk", "axi4_cpusys2_aclk", ap_base + 0x134, 5, &share_cnt_axi4_cpusys2_clk_en);
+	clks[CLKGEN_BMU_C910_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_bmu_c910_pclk", "apb3_cpusys_pclk", ap_base + 0x100, 5, &share_cnt_bmu_c910_clk_en);
+	clks[CLKGEN_BMU_C910_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_bmu_c910_aclk", "axi4_cpusys1_aclk", ap_base + 0x100, 5, &share_cnt_bmu_c910_clk_en);
+	clks[CLKGEN_IOPMP_AON_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_iopmp_aon_pclk", "apb3_cpusys_pclk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
+	clks[CLKGEN_AON2CPU_A2X_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_aon2cpu_a2x_aclk", "axi4_cpusys2_aclk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
+	clks[CLKGEN_AON2CPU_A2X_HCLK] = xuantie_clk_th1520_gate_shared("clkgen_aon2cpu_a2x_hclk", "aonsys_bus_clk", ap_base + 0x134, 8, &share_cnt_aon2cpu_a2x_clk_en);
+	clks[CLKGEN_IOPMP_CHIP_DBG_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_iopmp_chip_dbg_pclk", "apb3_cpusys_pclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
+	clks[CLKGEN_CHIP_DBG_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_chip_dbg_aclk", "axi4_cpusys2_aclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
+	clks[CLKGEN_CHIP_DBG_CCLK] = xuantie_clk_th1520_gate_shared("clkgen_chip_dbg_cclk", "chip_dbg_cclk", ap_base + 0x208, 9, &share_cnt_chip_dbg_clk_en);
+	clks[CLKGEN_X2X_CPUSYS_ACLK_M] = xuantie_clk_th1520_gate_shared("clkgen_x2x_cpusys_aclk_m", "axi4_cpusys2_aclk", ap_base + 0x134, 7, &share_cnt_x2x_cpusys_clk_en);
+	clks[CLKGEN_X2X_CPUSYS_ACLK_S] = xuantie_clk_th1520_gate_shared("clkgen_x2x_cpusys_aclk_s", "axi4_cpusys1_aclk", ap_base + 0x134, 7, &share_cnt_x2x_cpusys_clk_en);
+	clks[CLKGEN_CPU2PERI_X2H_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_cpu2peri_x2h_aclk", "axi4_cpusys1_aclk", ap_base + 0x140, 9, &share_cnt_cpu2peri_x2h_clk_en);
+	clks[CLKGEN_CPU2PERI_X2H_MHCLK] = xuantie_clk_th1520_gate_shared("clkgen_cpu2peri_x2h_mhclk", "perisys_ahb_hclk", ap_base + 0x140, 9, &share_cnt_cpu2peri_x2h_clk_en);
+	clks[CLKGEN_CPU2VI_X2H_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_cpu2vi_x2h_aclk", "axi4_cpusys1_aclk", ap_base + 0x1d0, 21, &share_cnt_cpu2vi_x2h_clk_en);
+	clks[CLKGEN_CPU2VI_X2H_MHCLK] = xuantie_clk_th1520_gate_shared("clkgen_cpu2vi_x2h_mhclk", "visys_ahb_hclk", ap_base + 0x1d0, 21, &share_cnt_cpu2vi_x2h_clk_en);
+	clks[CLKGEN_CFG2TEE_X2H_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_cfg2tee_x2h_aclk", "cfg_axi_aclk", ap_base + 0x1cc, 24, &share_cnt_cfg2tee_x2h_clk_en); // just for teesys!!!
+	clks[CLKGEN_CFG2TEE_X2H_MHCLK] = xuantie_clk_th1520_gate_shared("clkgen_cfg2tee_x2h_mhclk", "teesys_hclk", ap_base + 0x1cc, 24, &share_cnt_cfg2tee_x2h_clk_en); // just for teesys!!!
+	clks[CLKGEN_CPU2AON_X2H_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_cpu2aon_x2h_aclk", "cfg_axi_aclk", ap_base + 0x138, 8, &share_cnt_cpu2aon_x2h_clk_en);
+	clks[CLKGEN_CPU2AON_X2H_MHCLK] = xuantie_clk_th1520_gate_shared("clkgen_cpu2aon_x2h_mhclk", "aonsys_bus_clk", ap_base + 0x138, 8, &share_cnt_cpu2aon_x2h_clk_en);
+	clks[CLKGEN_CPU2VP_X2P_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_cpu2vp_x2p_aclk", "cfg_axi_aclk", ap_base + 0x1e0, 13, &share_cnt_cpu2vp_x2p_clk_en);
+	clks[CLKGEN_CPU2VP_X2P_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_cpu2vp_x2p_pclk", "vpsys_apb_pclk", ap_base + 0x1e0, 13, &share_cnt_cpu2vp_x2p_clk_en);
+	clks[CLKGEN_TOP_AXI4S_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_top_axi4s_aclk", "cfg_axi_aclk", ap_base + 0x1c8, 4, &share_cnt_npu_core_clk_en);
+	clks[CLKGEN_TOP_APB_SX_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_top_apb_sx_pclk", "cfg_apb_pclk", ap_base + 0x1c8, 4, &share_cnt_npu_core_clk_en);
+	clks[CLKGEN_MISC2VP_X2X_ACLK_M] = xuantie_clk_th1520_gate_shared("clkgen_misc2vp_x2x_aclk_m", "perisys_ahb_hclk", ap_base + 0x1e0, 15, &share_cnt_vpsys_axi_aclk_en);
+	clks[CLKGEN_VPSYS_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_vpsys_aclk", "vpsys_axi_aclk", ap_base + 0x1e0, 15, &share_cnt_vpsys_axi_aclk_en);
+	clks[CLKGEN_GMAC1_HCLK] = xuantie_clk_th1520_gate_shared("clkgen_gmac1_hclk", "perisys_ahb_hclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
+	clks[CLKGEN_GMAC1_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_gmac1_pclk", "perisys_ahb_hclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
+	clks[CLKGEN_GMAC1_CCLK] = xuantie_clk_th1520_gate_shared("clkgen_gmac1_cclk", "gmac_cclk", ap_base + 0x204, 26, &share_cnt_gmac1_clk_en);
+	clks[CLKGEN_GMAC0_HCLK] = xuantie_clk_th1520_gate_shared("clkgen_gmac0_hclk", "perisys_ahb_hclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
+	clks[CLKGEN_GMAC0_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_gmac0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
+	clks[CLKGEN_GMAC0_CCLK] = xuantie_clk_th1520_gate_shared("clkgen_gmac0_cclk", "gmac_cclk", ap_base + 0x204, 19, &share_cnt_gmac0_clk_en);
+	clks[CLKGEN_PERI2PERI1_APB_HCLK] = xuantie_clk_th1520_gate_shared("clkgen_peri2peri1_apb_hclk", "perisys_ahb_hclk", ap_base + 0x150, 11, &share_cnt_perisys_apb3_hclk_en);
+	clks[CLKGEN_PERI2PERI1_APB_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_peri2peri1_apb_pclk", "peri2sys_apb_pclk", ap_base + 0x150, 11, &share_cnt_perisys_apb3_hclk_en);
+	clks[CLKGEN_QSPI0_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_qspi0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 17, &share_cnt_qspi0_clk_en);
+	clks[CLKGEN_QSPI0_SSI_CLK] = xuantie_clk_th1520_gate_shared("clkgen_qspi0_ssi_clk", "qspi0_ssi_clk", ap_base + 0x204, 17, &share_cnt_qspi0_clk_en);
+	clks[CLKGEN_GMAC_AXI_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_gmac_axi_aclk", "perisys_ahb_hclk", ap_base + 0x204, 21, &share_cnt_gmac_axi_clk_en);
+	clks[CLKGEN_GMAC_AXI_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_gmac_axi_pclk", "perisys_ahb_hclk", ap_base + 0x204, 21, &share_cnt_gmac_axi_clk_en);
+	clks[CLKGEN_GPIO0_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_gpio0_pclk", "perisys_ahb_hclk", ap_base + 0x204, 8, &share_cnt_gpio0_clk_en);
+	clks[CLKGEN_GPIO0_DBCLK] = xuantie_clk_th1520_gate_shared("clkgen_gpio0_dbclk", "gpio0_dbclk", ap_base + 0x204, 8, &share_cnt_gpio0_clk_en);
+	clks[CLKGEN_GPIO1_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_gpio1_pclk", "perisys_ahb_hclk", ap_base + 0x204, 7, &share_cnt_gpio0_clk_en);
+	clks[CLKGEN_GPIO1_DBCLK] = xuantie_clk_th1520_gate_shared("clkgen_gpio1_dbclk", "gpio1_dbclk", ap_base + 0x204, 7, &share_cnt_gpio1_clk_en);
+	clks[CLKGEN_PWM_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_pwm_pclk", "perisys_apb_pclk", ap_base + 0x204, 18, &share_cnt_pwm_clk_en);
+	clks[CLKGEN_PWM_CCLK] = xuantie_clk_th1520_gate_shared("clkgen_pwm_cclk", "pwm_cclk", ap_base + 0x204, 18, &share_cnt_pwm_clk_en);
+	clks[CLKGEN_SPI_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_spi_pclk", "perisys_apb_pclk", ap_base + 0x204, 15, &share_cnt_spi_clk_en);
+	clks[CLKGEN_SPI_SSI_CLK] = xuantie_clk_th1520_gate_shared("clkgen_spi_ssi_clk", "spi_ssi_clk", ap_base + 0x204, 15, &share_cnt_spi_clk_en);
+	clks[CLKGEN_UART0_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart0_pclk", "perisys_apb_pclk", ap_base + 0x204, 14, &share_cnt_uart0_clk_en);
+	clks[CLKGEN_UART0_SCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart0_sclk", "uart_sclk", ap_base + 0x204, 14, &share_cnt_uart0_clk_en);
+	clks[CLKGEN_UART2_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart2_pclk", "perisys_apb_pclk", ap_base + 0x204, 12, &share_cnt_uart2_clk_en);
+	clks[CLKGEN_UART2_SCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart2_sclk", "uart_sclk", ap_base + 0x204, 12, &share_cnt_uart2_clk_en);
+	clks[CLKGEN_I2C2_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c2_pclk", "perisys_apb_pclk", ap_base + 0x204, 3, &share_cnt_i2c2_clk_en);
+	clks[CLKGEN_I2C2_IC_CLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c2_ic_clk", "i2c_ic_clk", ap_base + 0x204, 3, &share_cnt_i2c2_clk_en);
+	clks[CLKGEN_I2C3_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c3_pclk", "perisys_apb_pclk", ap_base + 0x204, 2, &share_cnt_i2c3_clk_en);
+	clks[CLKGEN_I2C3_IC_CLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c3_ic_clk", "i2c_ic_clk", ap_base + 0x204, 2, &share_cnt_i2c3_clk_en);
+	clks[CLKGEN_I2S_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_i2s_pclk", "perisys_apb_pclk", ap_base + 0x1f0, 1, &share_cnt_peri_i2s_clk_en);
+	clks[CLKGEN_I2S_SRC_CLK] = xuantie_clk_th1520_gate_shared("clkgen_i2s_src_clk", "peri_i2s_src_clk", ap_base + 0x1f0, 1, &share_cnt_peri_i2s_clk_en);
+	clks[CLKGEN_QSPI1_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_qspi1_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 16, &share_cnt_qspi1_clk_en);
+	clks[CLKGEN_QSPI1_SSI_CLK] = xuantie_clk_th1520_gate_shared("clkgen_qspi1_ssi_clk", "qspi1_ssi_clk", ap_base + 0x204, 16, &share_cnt_qspi1_clk_en);
+	clks[CLKGEN_UART1_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart1_pclk", "per2sys_apb_pclk", ap_base + 0x204, 13, &share_cnt_uart1_clk_en);
+	clks[CLKGEN_UART1_SCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart1_sclk", "uart_sclk", ap_base + 0x204, 13, &share_cnt_uart1_clk_en);
+	clks[CLKGEN_UART3_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart3_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 11, &share_cnt_uart3_clk_en);
+	clks[CLKGEN_UART3_SCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart3_sclk", "uart_sclk", ap_base + 0x204, 11, &share_cnt_uart3_clk_en);
+	clks[CLKGEN_UART4_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart4_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 10, &share_cnt_uart4_clk_en);
+	clks[CLKGEN_UART4_SCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart4_sclk", "uart_sclk", ap_base + 0x204, 10, &share_cnt_uart4_clk_en);
+	clks[CLKGEN_UART5_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart5_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 9, &share_cnt_uart5_clk_en);
+	clks[CLKGEN_UART5_SCLK] = xuantie_clk_th1520_gate_shared("clkgen_uart5_sclk", "uart_sclk", ap_base + 0x204, 9, &share_cnt_uart5_clk_en);
+	clks[CLKGEN_I2C0_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c0_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 5, &share_cnt_i2c0_clk_en);
+	clks[CLKGEN_I2C0_IC_CLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c0_ic_clk", "i2c_ic_clk", ap_base + 0x204, 5, &share_cnt_i2c0_clk_en);
+	clks[CLKGEN_I2C1_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c1_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 4, &share_cnt_i2c1_clk_en);
+	clks[CLKGEN_I2C1_IC_CLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c1_ic_clk", "i2c_ic_clk", ap_base + 0x204, 4, &share_cnt_i2c1_clk_en);
+	clks[CLKGEN_I2C4_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c4_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 1, &share_cnt_i2c4_clk_en);
+	clks[CLKGEN_I2C4_IC_CLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c4_ic_clk", "i2c_ic_clk", ap_base + 0x204, 1, &share_cnt_i2c4_clk_en);
+	clks[CLKGEN_I2C5_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c5_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 0, &share_cnt_i2c5_clk_en);
+	clks[CLKGEN_I2C5_IC_CLK] = xuantie_clk_th1520_gate_shared("clkgen_i2c5_ic_clk", "i2c_ic_clk", ap_base + 0x204, 0, &share_cnt_i2c5_clk_en);
+	clks[CLKGEN_GPIO2_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_gpio2_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en);
+	clks[CLKGEN_GPIO2_DBCLK] = xuantie_clk_th1520_gate_shared("clkgen_gpio2_dbclk", "gpio2_dbclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en);
+	clks[CLKGEN_GPIO3_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_gpio3_pclk", "peri2sys_apb_pclk", ap_base + 0x204, 6, &share_cnt_gpio2_clk_en); //!!! gpio3 pclk is controlled by gpio2_clk_en
+	clks[CLKGEN_GPIO3_DBCLK] = xuantie_clk_th1520_gate_shared("clkgen_gpio3_dbclk", "gpio3_dbclk", ap_base + 0x204, 20, &share_cnt_gpio3_clk_en);
+	clks[CLKGEN_VOSYS_AXI_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_vosys_axi_aclk", "vosys_aclk_m", ap_base + 0x1dc, 5, &share_cnt_vosys_axi_aclk_en);
+	clks[CLKGEN_VOSYS_X2X_ACLK_S] = xuantie_clk_th1520_gate_shared("clkgen_vosys_x2x_aclk_s", "npu_cclk", ap_base + 0x1dc, 5, &share_cnt_vosys_axi_aclk_en);
+
+	clk_data.clks = clks;
+	clk_data.clk_num = ARRAY_SIZE(clks);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register clks for th1520\n");
+		goto unregister_clks;
+	}
+
+#ifndef FPGA_EMU
+	/* HW defalut */
+	clk_set_parent(clks[C910_CCLK], clks[CPU_PLL1_FOUTPOSTDIV]);
+#else
+	clk_set_parent(clks[C910_CCLK_I0], clks[OSC_24M]);
+	clk_set_parent(clks[C910_CCLK], clks[C910_CCLK_I0]);
+#endif
+	dev_info(dev, "succeed to register th1520 fullmask clock driver\n");
+
+	return 0;
+
+unregister_clks:
+	xuantie_unregister_clocks(clks, ARRAY_SIZE(clks));
+	return ret;
+}
+
+const bool tee_sys_flag;
+
+static const struct of_device_id th1520_clk_of_match[] = {
+	{ .compatible = "xuantie,th1520-fm-ree-clk" },
+	{ .compatible = "xuantie,th1520-fm-tee-clk", .data = &tee_sys_flag,},
+	{ /* Sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, th1520_clk_of_match);
+
+static struct platform_driver th1520_clk_driver = {
+	.probe = th1520_clocks_probe,
+	.driver = {
+		.name = "th1520-fm-clk",
+		.of_match_table = of_match_ptr(th1520_clk_of_match),
+	},
+};
+
+module_platform_driver(th1520_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie Th1520 Fullmask clock driver");
+MODULE_LICENSE("GPL");
--- a/drivers/clk/thead/clk.c
+++ /dev/null
@@ -1,766 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- */
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/iopoll.h>
-#include <linux/of.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-
-#include "clk.h"
-
-#define TH1520_PLL_CFG0		0x0
-#define TH1520_PLL_CFG1		0x04
-#define TH1520_PLL_CFG2		0x8
-#define TH1520_POSTDIV2_SHIFT	24
-#define TH1520_POSTDIV2_MASK	GENMASK(26, 24)
-#define TH1520_POSTDIV1_SHIFT	20
-#define TH1520_POSTDIV1_MASK	GENMASK(22, 20)
-#define TH1520_FBDIV_SHIFT	8
-#define TH1520_FBDIV_MASK	GENMASK(19, 8)
-#define TH1520_REFDIV_SHIFT	0
-#define TH1520_REFDIV_MASK	GENMASK(5, 0)
-#define TH1520_BYPASS_MASK	BIT(30)
-#define TH1520_RST_MASK		BIT(29)
-#define TH1520_DSMPD_MASK	BIT(24)
-#define TH1520_DACPD_MASK	BIT(25)
-#define TH1520_FRAC_MASK		GENMASK(23, 0)
-#define TH1520_FRAC_SHIFT	0
-#define TH1520_FRAC_DIV		BIT(24)
-
-#define LOCK_TIMEOUT_US		10000
-
-#define div_mask(d)	((1 << (d->width)) - 1)
-
-DEFINE_SPINLOCK(thead_th1520_clk_lock);
-
-enum th1520_pll_mode {
-        PLL_MODE_FRAC,
-        PLL_MODE_INT,
-};
-
-struct clk_th1520pll {
-	struct clk_hw			hw;
-	void __iomem			*base;
-	enum th1520_pll_clktype		clk_type;
-	enum th1520_pll_outtype		out_type;
-	enum th1520_pll_mode		pll_mode;
-	const struct th1520_pll_rate_table *rate_table;
-	int rate_count;
-
-	u32 cfg0_reg_off;
-	u32 pll_sts_off;
-	int pll_lock_bit;
-
-	/* Th1520 MPW Aon/ddr pll define bypass:rst bits as: 31:30
-	 * but AP pll define bypass:rst bits as: 30:29
-	 *
-	 * Th1520 Fullmask align these register field define, all pll
-	 * define bypss:rst bits as: 30:29
-	 */
-	int pll_rst_bit;
-	int pll_bypass_bit;
-};
-
-struct clk_th1520div {
-	struct clk_divider divider;
-	enum th1520_div_type div_type;
-	u16 min_div;
-	u16 max_div;
-	u8 sync_en;
-	const struct clk_ops *ops;
-};
-
-struct clk_th1520gate {
-	struct clk_gate gate;
-	unsigned int *share_count;
-	const struct clk_ops *ops;
-};
-
-#define to_clk_th1520pll(_hw) container_of(_hw, struct clk_th1520pll, hw)
-
-void thead_unregister_clocks(struct clk *clks[], unsigned int count)
-{
-        unsigned int i;
-
-        for (i = 0; i < count; i++)
-                clk_unregister(clks[i]);
-}
-
-static void clk_th1520_pll_cfg_init(struct clk_th1520pll *pll)
-{
-	switch (pll->clk_type) {
-	case TH1520_AUDIO_PLL:
-		pll->cfg0_reg_off = 0x0;
-		pll->pll_sts_off = 0x90;
-		pll->pll_lock_bit = BIT(0);
-		pll->pll_bypass_bit = BIT(31);
-		pll->pll_rst_bit = BIT(30);
-		pll->pll_mode = PLL_MODE_FRAC;
-		break;
-	case TH1520_SYS_PLL:
-		pll->cfg0_reg_off = 0x10;
-		pll->pll_sts_off = 0x90;
-		pll->pll_lock_bit = BIT(1);
-		pll->pll_bypass_bit = BIT(31);
-		pll->pll_rst_bit = BIT(30);
-		pll->pll_mode = PLL_MODE_FRAC;
-		break;
-	case TH1520_CPU_PLL0:
-		pll->cfg0_reg_off = 0x0;
-		pll->pll_sts_off = 0x80;
-		pll->pll_lock_bit = BIT(1);
-		pll->pll_bypass_bit = BIT(30);
-		pll->pll_rst_bit = BIT(29);
-		pll->pll_mode = PLL_MODE_INT;
-		break;
-	case TH1520_CPU_PLL1:
-		pll->cfg0_reg_off = 0x10;
-		pll->pll_sts_off = 0x80;
-		pll->pll_lock_bit = BIT(4);
-		pll->pll_bypass_bit = BIT(30);
-		pll->pll_rst_bit = BIT(29);
-		pll->pll_mode = PLL_MODE_INT;
-		break;
-	case TH1520_GMAC_PLL:
-		pll->cfg0_reg_off = 0x20;
-		pll->pll_sts_off = 0x80;
-		pll->pll_lock_bit = BIT(3);
-		pll->pll_bypass_bit = BIT(30);
-		pll->pll_rst_bit = BIT(29);
-		pll->pll_mode = PLL_MODE_INT;
-		break;
-	case TH1520_VIDEO_PLL:
-		pll->cfg0_reg_off = 0x30;
-		pll->pll_sts_off = 0x80;
-		pll->pll_lock_bit = BIT(7);
-		pll->pll_bypass_bit = BIT(30);
-		pll->pll_rst_bit = BIT(29);
-		pll->pll_mode = PLL_MODE_INT;
-		break;
-	case TH1520_DDR_PLL:
-		pll->cfg0_reg_off = 0x8;
-		pll->pll_sts_off = 0x18;
-		pll->pll_lock_bit = BIT(0);
-		pll->pll_bypass_bit = BIT(31);
-		pll->pll_rst_bit = BIT(30);
-		pll->pll_mode = PLL_MODE_INT;
-		break;
-	case TH1520_DPU0_PLL:
-		pll->cfg0_reg_off = 0x40;
-		pll->pll_sts_off = 0x80;
-		pll->pll_lock_bit = BIT(8);
-		pll->pll_bypass_bit = BIT(30);
-		pll->pll_rst_bit = BIT(29);
-		pll->pll_mode = PLL_MODE_INT;
-		break;
-	case TH1520_DPU1_PLL:
-		pll->cfg0_reg_off = 0x50;
-		pll->pll_sts_off = 0x80;
-		pll->pll_lock_bit = BIT(9);
-		pll->pll_bypass_bit = BIT(30);
-		pll->pll_rst_bit = BIT(29);
-		pll->pll_mode = PLL_MODE_INT;
-		break;
-	default:
-		pr_err("%s: Unknown pll type\n", __func__);
-	};
-}
-
-static int clk_th1520_pll_wait_lock(struct clk_th1520pll *pll)
-{
-	u32 val;
-
-	return readl_poll_timeout(pll->base + pll->pll_sts_off, val,
-				  val & pll->pll_lock_bit, 0,
-				  LOCK_TIMEOUT_US);
-}
-
-static int clk_th1520_pll_prepare(struct clk_hw *hw)
-{
-	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
-	void __iomem *cfg1_off;
-	u32 val;
-	int ret;
-
-	cfg1_off = pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1;
-	val = readl_relaxed(cfg1_off);
-	if (!(val & pll->pll_rst_bit))
-		return 0;
-
-	/* Enable RST */
-	val |= pll->pll_rst_bit;
-	writel_relaxed(val, cfg1_off);
-
-	udelay(3);
-
-	/* Disable RST */
-	val &= ~pll->pll_rst_bit;
-	writel_relaxed(val, cfg1_off);
-
-	ret = clk_th1520_pll_wait_lock(pll);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int clk_th1520_pll_is_prepared(struct clk_hw *hw)
-{
-	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
-	u32 val;
-
-	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
-
-	return (val & pll->pll_rst_bit) ? 0 : 1;
-}
-
-static void clk_th1520_pll_unprepare(struct clk_hw *hw)
-{
-	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
-	u32 val;
-
-	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
-	val |= pll->pll_rst_bit;
-	writel_relaxed(val, pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
-}
-
-static unsigned long clk_th1520_pll_recalc_rate(struct clk_hw *hw,
-					       unsigned long parent_rate)
-{
-#ifndef CONFIG_TH1520_CLK_EMU
-	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
-	u32 refdiv, fbdiv, postdiv1, postdiv2, frac;
-	u32 pll_cfg0, pll_cfg1;
-	u64 fvco = 0;
-
-	pll_cfg0 = readl_relaxed(pll->base + pll->cfg0_reg_off);
-	pll_cfg1 = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
-	refdiv = (pll_cfg0 & TH1520_REFDIV_MASK) >> TH1520_REFDIV_SHIFT;
-	fbdiv = (pll_cfg0 & TH1520_FBDIV_MASK) >> TH1520_FBDIV_SHIFT;
-	postdiv1 = (pll_cfg0 & TH1520_POSTDIV1_MASK) >> TH1520_POSTDIV1_SHIFT;
-	postdiv2 = (pll_cfg0 & TH1520_POSTDIV2_MASK) >> TH1520_POSTDIV2_SHIFT;
-	frac = (pll_cfg1 & TH1520_FRAC_MASK) >> TH1520_FRAC_SHIFT;
-
-	/* rate calculation:
-	 * INT mode: FOUTVCO = FREE * FBDIV / REFDIV
-	 * FRAC mode:FOUTVCO = (FREE * FBDIV + FREE * FRAC/BIT(24)) / REFDIV
-	 */
-	if (pll->pll_mode == PLL_MODE_FRAC)
-		fvco = (parent_rate * frac) / TH1520_FRAC_DIV;
-
-	fvco += (parent_rate * fbdiv);
-	do_div(fvco, refdiv);
-
-	if (pll->out_type == TH1520_PLL_DIV)
-		do_div(fvco, postdiv1 * postdiv2);
-
-	return fvco;
-#else
-
-	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
-	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
-
-	/* return minimum supported value */
-	if (pll->out_type == TH1520_PLL_DIV)
-		return rate_table[0].rate;
-
-	return rate_table[0].vco_rate;
-#endif
-}
-
-static const struct th1520_pll_rate_table *th1520_get_pll_div_settings(
-		struct clk_th1520pll *pll, unsigned long rate)
-{
-	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
-	int i;
-
-	for (i = 0; i < pll->rate_count; i++)
-		if (rate == rate_table[i].rate)
-			return &rate_table[i];
-
-	return NULL;
-}
-
-static const struct th1520_pll_rate_table *th1520_get_pll_vco_settings(
-		struct clk_th1520pll *pll, unsigned long rate)
-{
-	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
-	int i;
-
-	for (i = 0; i < pll->rate_count; i++)
-		if (rate == rate_table[i].vco_rate)
-			return &rate_table[i];
-
-	return NULL;
-}
-
-static inline bool clk_th1520_pll_change(struct clk_th1520pll *pll,
-					const struct th1520_pll_rate_table *rate)
-{
-	u32 refdiv_old, fbdiv_old, postdiv1_old, postdiv2_old, frac_old;
-	u32 cfg0, cfg1;
-	bool pll_changed;
-
-	cfg0 = readl_relaxed(pll->base + pll->cfg0_reg_off);
-	cfg1 = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
-
-	refdiv_old = (cfg0 & TH1520_REFDIV_MASK) >> TH1520_REFDIV_SHIFT;
-	fbdiv_old = (cfg0 & TH1520_FBDIV_MASK) >> TH1520_FBDIV_SHIFT;
-	postdiv1_old = (cfg0 & TH1520_POSTDIV1_MASK) >> TH1520_POSTDIV1_SHIFT;
-	postdiv2_old = (cfg0 & TH1520_POSTDIV2_MASK) >> TH1520_POSTDIV2_SHIFT;
-	frac_old = (cfg1 & TH1520_FRAC_MASK) >> TH1520_FRAC_SHIFT;
-
-	pll_changed = rate->refdiv != refdiv_old || rate->fbdiv != fbdiv_old ||
-		      rate->postdiv1 != postdiv1_old || rate->postdiv2 != postdiv2_old;
-	if (pll->pll_mode == PLL_MODE_FRAC)
-		pll_changed |= (rate->frac != frac_old);
-
-	return pll_changed;
-}
-
-static int clk_th1520_pll_set_rate(struct clk_hw *hw, unsigned long drate,
-				 unsigned long prate)
-{
-	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
-	const struct th1520_pll_rate_table *rate;
-	void __iomem *cfg1_off;
-	u32 tmp, div_val;
-	int ret;
-
-	if (pll->out_type == TH1520_PLL_VCO) {
-		rate = th1520_get_pll_vco_settings(pll, drate);
-		if (!rate) {
-			pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
-				drate, clk_hw_get_name(hw));
-			return -EINVAL;
-		}
-	} else {
-		rate = th1520_get_pll_div_settings(pll, drate);
-		if (!rate) {
-			pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
-				drate, clk_hw_get_name(hw));
-			return -EINVAL;
-		}
-	}
-
-	if (!clk_th1520_pll_change(pll, rate))
-		return 0;
-
-	/* Enable RST */
-	cfg1_off = pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1;
-	tmp = readl_relaxed(cfg1_off);
-	tmp |= pll->pll_rst_bit;
-	writel_relaxed(tmp, cfg1_off);
-
-	div_val = (rate->refdiv << TH1520_REFDIV_SHIFT) |
-		  (rate->fbdiv << TH1520_FBDIV_SHIFT) |
-		  (rate->postdiv1 << TH1520_POSTDIV1_SHIFT) |
-		  (rate->postdiv2 << TH1520_POSTDIV2_SHIFT);
-	writel_relaxed(div_val, pll->base + pll->cfg0_reg_off);
-
-	if (pll->pll_mode == PLL_MODE_FRAC) {
-		tmp &= ~(TH1520_FRAC_MASK << TH1520_FRAC_SHIFT);
-		tmp |= rate->frac;
-		writel_relaxed(tmp, cfg1_off);
-	}
-
-	udelay(3);
-
-	/* Disable RST */
-	tmp &= ~pll->pll_rst_bit;
-	writel_relaxed(tmp, cfg1_off);
-
-	/* Wait Lock, ~20us cost */
-	ret = clk_th1520_pll_wait_lock(pll);
-	if (ret)
-		return ret;
-
-	/* HW requires 30us for pll stable */
-	udelay(30);
-
-	return 0;
-}
-
-static long clk_th1520_pllvco_round_rate(struct clk_hw *hw, unsigned long rate,
-					unsigned long *prate)
-{
-	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
-	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
-	unsigned long best = 0, now = 0;
-	unsigned int i, best_i = 0;
-
-	for (i = 0; i < pll->rate_count; i++) {
-		now = rate_table[i].vco_rate;
-
-		if (rate == now) {
-			return rate_table[i].vco_rate;
-		} else if (abs(now - rate) < abs(best - rate)) {
-			best = now;
-			best_i = i;
-		}
-	}
-
-	/* return minimum supported value */
-	return rate_table[best_i].vco_rate;
-}
-
-static long clk_th1520_plldiv_round_rate(struct clk_hw *hw, unsigned long rate,
-					unsigned long *prate)
-{
-	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
-	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
-	unsigned long best = 0, now = 0;
-	unsigned int i, best_i = 0;
-
-	for (i = 0; i < pll->rate_count; i++) {
-		now = rate_table[i].rate;
-
-		if (rate == now) {
-			return rate_table[i].rate;
-		} else if (abs(now - rate) < abs(best - rate)) {
-			best = now;
-			best_i = i;
-		}
-	}
-
-	/* return minimum supported value */
-	return rate_table[best_i].rate;
-}
-
-static const struct clk_ops clk_th1520_pll_def_ops = {
-	.recalc_rate	= clk_th1520_pll_recalc_rate,
-};
-
-static const struct clk_ops clk_th1520_pllvco_ops = {
-	.prepare	= clk_th1520_pll_prepare,
-	.unprepare	= clk_th1520_pll_unprepare,
-	.is_prepared	= clk_th1520_pll_is_prepared,
-	.recalc_rate	= clk_th1520_pll_recalc_rate,
-	.round_rate	= clk_th1520_pllvco_round_rate,
-	.set_rate	= clk_th1520_pll_set_rate,
-};
-
-static const struct clk_ops clk_th1520_plldiv_ops = {
-	.prepare	= clk_th1520_pll_prepare,
-	.unprepare	= clk_th1520_pll_unprepare,
-	.is_prepared	= clk_th1520_pll_is_prepared,
-	.recalc_rate	= clk_th1520_pll_recalc_rate,
-	.round_rate	= clk_th1520_plldiv_round_rate,
-	.set_rate	= clk_th1520_pll_set_rate,
-};
-
-struct clk *thead_th1520_pll(const char *name, const char *parent_name,
-			    void __iomem *base,
-			    const struct th1520_pll_clk *pll_clk)
-{
-	struct clk_th1520pll *pll;
-	struct clk *clk;
-	struct clk_init_data init;
-	u32 val;
-
-	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
-	if (!pll)
-		return ERR_PTR(-ENOMEM);
-
-	init.name = name;
-	init.flags = pll_clk->flags;
-	init.parent_names = &parent_name;
-	init.num_parents = 1;
-
-	switch (pll_clk->out_type) {
-	case TH1520_PLL_VCO:
-		if (pll_clk->rate_table)
-			init.ops = &clk_th1520_pllvco_ops;
-		break;
-	case TH1520_PLL_DIV:
-		if (pll_clk->rate_table)
-			init.ops = &clk_th1520_plldiv_ops;
-		break;
-	default:
-		pr_err("%s: Unknown pll out type for pll clk %s\n",
-		       __func__, name);
-	};
-
-	if (!pll_clk->rate_table)
-		init.ops = &clk_th1520_pll_def_ops;
-
-	pll->base = base;
-	pll->hw.init = &init;
-	pll->out_type = pll_clk->out_type;
-	pll->clk_type = pll_clk->clk_type;
-	pll->rate_table = pll_clk->rate_table;
-	pll->rate_count = pll_clk->rate_count;
-
-	clk_th1520_pll_cfg_init(pll);
-
-	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
-	val &= ~pll->pll_bypass_bit;
-	val |= TH1520_DACPD_MASK;
-	val |= TH1520_DSMPD_MASK;
-	if (pll->pll_mode == PLL_MODE_FRAC) {
-		val &= ~TH1520_DSMPD_MASK;
-		val &= ~TH1520_DACPD_MASK;
-	}
-	writel_relaxed(val, pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
-
-	clk = clk_register(NULL, &pll->hw);
-	if (IS_ERR(clk)) {
-		pr_err("%s: failed to register pll %s %lu\n",
-			__func__, name, PTR_ERR(clk));
-		kfree(pll);
-	}
-
-	return clk;
-}
-
-static inline struct clk_th1520div *to_clk_th1520div(struct clk_hw *hw)
-{
-	struct clk_divider *divider = to_clk_divider(hw);
-
-	return container_of(divider, struct clk_th1520div, divider);
-}
-
-static unsigned long clk_th1520div_recalc_rate(struct clk_hw *hw,
-					 unsigned long parent_rate)
-{
-	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
-
-	return th1520_div->ops->recalc_rate(&th1520_div->divider.hw, parent_rate);
-}
-
-static long clk_th1520div_round_rate(struct clk_hw *hw, unsigned long rate,
-			       unsigned long *prate)
-{
-	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
-
-	return th1520_div->ops->round_rate(&th1520_div->divider.hw, rate, prate);
-}
-
-static int clk_th1520div_set_rate(struct clk_hw *hw, unsigned long rate,
-				 unsigned long parent_rate)
-{
-	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
-	struct clk_divider *div = to_clk_divider(hw);
-	unsigned int divider, value;
-	unsigned long flags = 0;
-	u32 val;
-
-	/** 
-	 * The clk-divider will calculate the node frequency by rounding up 
-	 * based on the parent frequency and the target divider.
-	 * This calculation is to restore accurate frequency divider. 
-	*/
-	divider = DIV64_U64_ROUND_CLOSEST(parent_rate, rate);
-
-	/* DIV is zero based divider, but CDE is not */
-	if (th1520_div->div_type == MUX_TYPE_DIV)
-		value = divider;
-	else
-		value = divider - 1;
-
-	/* handle the div valid range */
-	if (value > th1520_div->max_div)
-		value = th1520_div->max_div;
-	if (value < th1520_div->min_div)
-		value = th1520_div->min_div;
-
-	spin_lock_irqsave(div->lock, flags);
-
-	val = readl(div->reg);
-	val &= ~BIT(th1520_div->sync_en);
-	writel(val, div->reg);
-
-	udelay(1);
-
-	val &= ~(div_mask(div) << div->shift);
-	val |= value << div->shift;
-	writel(val, div->reg);
-
-	udelay(1);
-
-	val |= BIT(th1520_div->sync_en);
-	writel(val, div->reg);
-
-	spin_unlock_irqrestore(div->lock, flags);
-
-	return 0;
-}
-
-static const struct clk_ops clk_th1520div_ops = {
-	.recalc_rate = clk_th1520div_recalc_rate,
-	.round_rate = clk_th1520div_round_rate,
-	.set_rate = clk_th1520div_set_rate,
-};
-
-static struct clk *thead_clk_th1520_divider_internal(const char *name, const char *parent,
-				       void __iomem *reg, u8 shift, u8 width,
-				       u8 sync, enum th1520_div_type div_type,
-				       u16 min, u16 max, bool closest)
-{
-	struct clk_th1520div *th1520_div;
-	struct clk_hw *hw;
-	struct clk_init_data init;
-	int ret;
-
-	th1520_div = kzalloc(sizeof(*th1520_div), GFP_KERNEL);
-	if (!th1520_div)
-		return ERR_PTR(-ENOMEM);
-
-	init.name = name;
-	init.ops = &clk_th1520div_ops;
-	init.flags = CLK_SET_RATE_PARENT;
-	init.parent_names = parent ? &parent : NULL;
-	init.num_parents = parent ? 1 : 0;
-
-	th1520_div->divider.reg = reg;
-	th1520_div->divider.shift = shift;
-	th1520_div->divider.width = width;
-	th1520_div->divider.lock = &thead_th1520_clk_lock;
-	th1520_div->divider.hw.init = &init;
-	th1520_div->ops = &clk_divider_ops;
-	th1520_div->sync_en = sync;
-	th1520_div->div_type = div_type;
-	if (th1520_div->div_type == MUX_TYPE_DIV)
-		th1520_div->divider.flags = CLK_DIVIDER_ONE_BASED;
-
-	if (closest)
-		th1520_div->divider.flags |= CLK_DIVIDER_ROUND_CLOSEST;
-
-	th1520_div->min_div = min > ((1 << width) - 1) ?
-			     ((1 << width) - 1) : min;
-	th1520_div->max_div = max > ((1 << width) - 1) ?
-			     ((1 << width) - 1) : max;
-
-	hw = &th1520_div->divider.hw;
-
-	ret = clk_hw_register(NULL, hw);
-	if (ret) {
-		kfree(th1520_div);
-		return ERR_PTR(ret);
-	}
-
-	return hw->clk;
-}
-
-struct clk *thead_clk_th1520_divider(const char *name, const char *parent,
-				       void __iomem *reg, u8 shift, u8 width,
-				       u8 sync, enum th1520_div_type div_type,
-				       u16 min, u16 max)
-{
-	return thead_clk_th1520_divider_internal(name, parent, reg, shift, width,
-											sync, div_type, min, max, false);
-}
-
-struct clk *thead_clk_th1520_divider_closest(const char *name, const char *parent,
-				       void __iomem *reg, u8 shift, u8 width,
-				       u8 sync, enum th1520_div_type div_type,
-				       u16 min, u16 max)
-{
-	return thead_clk_th1520_divider_internal(name, parent, reg, shift, width,
-											sync, div_type, min, max, true);
-}
-
-static inline struct clk_th1520gate *to_clk_th1520gate(struct clk_hw *hw)
-{
-	struct clk_gate *gate = to_clk_gate(hw);
-
-	return container_of(gate, struct clk_th1520gate, gate);
-}
-
-static int clk_th1520_gate_share_is_enabled(struct clk_hw *hw)
-{
-	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
-
-	return th1520_gate->ops->is_enabled(hw);
-}
-
-static int clk_th1520_gate_share_enable(struct clk_hw *hw)
-{
-	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
-
-	if (th1520_gate->share_count && (*th1520_gate->share_count)++ > 0) {
-		pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
-		return 0;
-	}
-
-	pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
-
-	return th1520_gate->ops->enable(hw);
-}
-
-static void clk_th1520_gate_share_disable(struct clk_hw *hw)
-{
-	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
-
-	if (th1520_gate->share_count) {
-		if (WARN_ON(*th1520_gate->share_count == 0))
-			return;
-		else if (--(*th1520_gate->share_count) > 0) {
-			pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
-			return;
-		}
-	}
-
-	pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
-
-	th1520_gate->ops->disable(hw);
-}
-
-static void clk_th1520_gate_share_disable_unused(struct clk_hw *hw)
-{
-	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
-
-	if (!th1520_gate->share_count || *th1520_gate->share_count == 0)
-		return th1520_gate->ops->disable(hw);
-}
-
-static const struct clk_ops clk_th1520gate_share_ops = {
-	.enable = clk_th1520_gate_share_enable,
-	.disable = clk_th1520_gate_share_disable,
-	.disable_unused = clk_th1520_gate_share_disable_unused,
-	.is_enabled = clk_th1520_gate_share_is_enabled,
-};
-
-struct clk *thead_clk_th1520_register_gate_shared(const char *name, const char *parent,
-						 unsigned long flags, void __iomem *reg,
-						 u8 shift, spinlock_t *lock,
-						 unsigned int *share_count)
-{
-	struct clk_th1520gate *th1520_gate;
-	struct clk_hw *hw;
-	struct clk_init_data init;
-	int ret;
-
-	th1520_gate = kzalloc(sizeof(*th1520_gate), GFP_KERNEL);
-	if (!th1520_gate)
-		return ERR_PTR(-ENOMEM);
-
-	th1520_gate->gate.reg = reg;
-	th1520_gate->gate.bit_idx = shift;
-	th1520_gate->gate.flags = 0;
-	th1520_gate->gate.lock = lock;
-	th1520_gate->gate.hw.init = &init;
-	th1520_gate->ops = &clk_gate_ops;
-	th1520_gate->share_count = share_count;
-
-	init.name = name;
-	init.ops = &clk_th1520gate_share_ops;
-	init.flags = flags;
-	init.parent_names = parent ? &parent : NULL;
-	init.num_parents = parent ? 1 : 0;
-
-	hw = &th1520_gate->gate.hw;
-
-	ret = clk_hw_register(NULL, hw);
-	if (ret) {
-		kfree(th1520_gate);
-		return ERR_PTR(ret);
-	}
-
-	return hw->clk;
-}
--- /dev/null
+++ b/drivers/clk/xuantie/clk.c
@@ -0,0 +1,766 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "clk.h"
+
+#define TH1520_PLL_CFG0		0x0
+#define TH1520_PLL_CFG1		0x04
+#define TH1520_PLL_CFG2		0x8
+#define TH1520_POSTDIV2_SHIFT	24
+#define TH1520_POSTDIV2_MASK	GENMASK(26, 24)
+#define TH1520_POSTDIV1_SHIFT	20
+#define TH1520_POSTDIV1_MASK	GENMASK(22, 20)
+#define TH1520_FBDIV_SHIFT	8
+#define TH1520_FBDIV_MASK	GENMASK(19, 8)
+#define TH1520_REFDIV_SHIFT	0
+#define TH1520_REFDIV_MASK	GENMASK(5, 0)
+#define TH1520_BYPASS_MASK	BIT(30)
+#define TH1520_RST_MASK		BIT(29)
+#define TH1520_DSMPD_MASK	BIT(24)
+#define TH1520_DACPD_MASK	BIT(25)
+#define TH1520_FRAC_MASK		GENMASK(23, 0)
+#define TH1520_FRAC_SHIFT	0
+#define TH1520_FRAC_DIV		BIT(24)
+
+#define LOCK_TIMEOUT_US		10000
+
+#define div_mask(d)	((1 << (d->width)) - 1)
+
+DEFINE_SPINLOCK(xuantie_th1520_clk_lock);
+
+enum th1520_pll_mode {
+        PLL_MODE_FRAC,
+        PLL_MODE_INT,
+};
+
+struct clk_th1520pll {
+	struct clk_hw			hw;
+	void __iomem			*base;
+	enum th1520_pll_clktype		clk_type;
+	enum th1520_pll_outtype		out_type;
+	enum th1520_pll_mode		pll_mode;
+	const struct th1520_pll_rate_table *rate_table;
+	int rate_count;
+
+	u32 cfg0_reg_off;
+	u32 pll_sts_off;
+	int pll_lock_bit;
+
+	/* Th1520 MPW Aon/ddr pll define bypass:rst bits as: 31:30
+	 * but AP pll define bypass:rst bits as: 30:29
+	 *
+	 * Th1520 Fullmask align these register field define, all pll
+	 * define bypss:rst bits as: 30:29
+	 */
+	int pll_rst_bit;
+	int pll_bypass_bit;
+};
+
+struct clk_th1520div {
+	struct clk_divider divider;
+	enum th1520_div_type div_type;
+	u16 min_div;
+	u16 max_div;
+	u8 sync_en;
+	const struct clk_ops *ops;
+};
+
+struct clk_th1520gate {
+	struct clk_gate gate;
+	unsigned int *share_count;
+	const struct clk_ops *ops;
+};
+
+#define to_clk_th1520pll(_hw) container_of(_hw, struct clk_th1520pll, hw)
+
+void xuantie_unregister_clocks(struct clk *clks[], unsigned int count)
+{
+        unsigned int i;
+
+        for (i = 0; i < count; i++)
+                clk_unregister(clks[i]);
+}
+
+static void clk_th1520_pll_cfg_init(struct clk_th1520pll *pll)
+{
+	switch (pll->clk_type) {
+	case TH1520_AUDIO_PLL:
+		pll->cfg0_reg_off = 0x0;
+		pll->pll_sts_off = 0x90;
+		pll->pll_lock_bit = BIT(0);
+		pll->pll_bypass_bit = BIT(31);
+		pll->pll_rst_bit = BIT(30);
+		pll->pll_mode = PLL_MODE_FRAC;
+		break;
+	case TH1520_SYS_PLL:
+		pll->cfg0_reg_off = 0x10;
+		pll->pll_sts_off = 0x90;
+		pll->pll_lock_bit = BIT(1);
+		pll->pll_bypass_bit = BIT(31);
+		pll->pll_rst_bit = BIT(30);
+		pll->pll_mode = PLL_MODE_FRAC;
+		break;
+	case TH1520_CPU_PLL0:
+		pll->cfg0_reg_off = 0x0;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(1);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_CPU_PLL1:
+		pll->cfg0_reg_off = 0x10;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(4);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_GMAC_PLL:
+		pll->cfg0_reg_off = 0x20;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(3);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_VIDEO_PLL:
+		pll->cfg0_reg_off = 0x30;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(7);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_DDR_PLL:
+		pll->cfg0_reg_off = 0x8;
+		pll->pll_sts_off = 0x18;
+		pll->pll_lock_bit = BIT(0);
+		pll->pll_bypass_bit = BIT(31);
+		pll->pll_rst_bit = BIT(30);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_DPU0_PLL:
+		pll->cfg0_reg_off = 0x40;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(8);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	case TH1520_DPU1_PLL:
+		pll->cfg0_reg_off = 0x50;
+		pll->pll_sts_off = 0x80;
+		pll->pll_lock_bit = BIT(9);
+		pll->pll_bypass_bit = BIT(30);
+		pll->pll_rst_bit = BIT(29);
+		pll->pll_mode = PLL_MODE_INT;
+		break;
+	default:
+		pr_err("%s: Unknown pll type\n", __func__);
+	};
+}
+
+static int clk_th1520_pll_wait_lock(struct clk_th1520pll *pll)
+{
+	u32 val;
+
+	return readl_poll_timeout(pll->base + pll->pll_sts_off, val,
+				  val & pll->pll_lock_bit, 0,
+				  LOCK_TIMEOUT_US);
+}
+
+static int clk_th1520_pll_prepare(struct clk_hw *hw)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	void __iomem *cfg1_off;
+	u32 val;
+	int ret;
+
+	cfg1_off = pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1;
+	val = readl_relaxed(cfg1_off);
+	if (!(val & pll->pll_rst_bit))
+		return 0;
+
+	/* Enable RST */
+	val |= pll->pll_rst_bit;
+	writel_relaxed(val, cfg1_off);
+
+	udelay(3);
+
+	/* Disable RST */
+	val &= ~pll->pll_rst_bit;
+	writel_relaxed(val, cfg1_off);
+
+	ret = clk_th1520_pll_wait_lock(pll);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int clk_th1520_pll_is_prepared(struct clk_hw *hw)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	u32 val;
+
+	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+
+	return (val & pll->pll_rst_bit) ? 0 : 1;
+}
+
+static void clk_th1520_pll_unprepare(struct clk_hw *hw)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	u32 val;
+
+	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+	val |= pll->pll_rst_bit;
+	writel_relaxed(val, pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+}
+
+static unsigned long clk_th1520_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+#ifndef CONFIG_TH1520_CLK_EMU
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	u32 refdiv, fbdiv, postdiv1, postdiv2, frac;
+	u32 pll_cfg0, pll_cfg1;
+	u64 fvco = 0;
+
+	pll_cfg0 = readl_relaxed(pll->base + pll->cfg0_reg_off);
+	pll_cfg1 = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+	refdiv = (pll_cfg0 & TH1520_REFDIV_MASK) >> TH1520_REFDIV_SHIFT;
+	fbdiv = (pll_cfg0 & TH1520_FBDIV_MASK) >> TH1520_FBDIV_SHIFT;
+	postdiv1 = (pll_cfg0 & TH1520_POSTDIV1_MASK) >> TH1520_POSTDIV1_SHIFT;
+	postdiv2 = (pll_cfg0 & TH1520_POSTDIV2_MASK) >> TH1520_POSTDIV2_SHIFT;
+	frac = (pll_cfg1 & TH1520_FRAC_MASK) >> TH1520_FRAC_SHIFT;
+
+	/* rate calculation:
+	 * INT mode: FOUTVCO = FREE * FBDIV / REFDIV
+	 * FRAC mode:FOUTVCO = (FREE * FBDIV + FREE * FRAC/BIT(24)) / REFDIV
+	 */
+	if (pll->pll_mode == PLL_MODE_FRAC)
+		fvco = (parent_rate * frac) / TH1520_FRAC_DIV;
+
+	fvco += (parent_rate * fbdiv);
+	do_div(fvco, refdiv);
+
+	if (pll->out_type == TH1520_PLL_DIV)
+		do_div(fvco, postdiv1 * postdiv2);
+
+	return fvco;
+#else
+
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+
+	/* return minimum supported value */
+	if (pll->out_type == TH1520_PLL_DIV)
+		return rate_table[0].rate;
+
+	return rate_table[0].vco_rate;
+#endif
+}
+
+static const struct th1520_pll_rate_table *th1520_get_pll_div_settings(
+		struct clk_th1520pll *pll, unsigned long rate)
+{
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+	int i;
+
+	for (i = 0; i < pll->rate_count; i++)
+		if (rate == rate_table[i].rate)
+			return &rate_table[i];
+
+	return NULL;
+}
+
+static const struct th1520_pll_rate_table *th1520_get_pll_vco_settings(
+		struct clk_th1520pll *pll, unsigned long rate)
+{
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+	int i;
+
+	for (i = 0; i < pll->rate_count; i++)
+		if (rate == rate_table[i].vco_rate)
+			return &rate_table[i];
+
+	return NULL;
+}
+
+static inline bool clk_th1520_pll_change(struct clk_th1520pll *pll,
+					const struct th1520_pll_rate_table *rate)
+{
+	u32 refdiv_old, fbdiv_old, postdiv1_old, postdiv2_old, frac_old;
+	u32 cfg0, cfg1;
+	bool pll_changed;
+
+	cfg0 = readl_relaxed(pll->base + pll->cfg0_reg_off);
+	cfg1 = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+
+	refdiv_old = (cfg0 & TH1520_REFDIV_MASK) >> TH1520_REFDIV_SHIFT;
+	fbdiv_old = (cfg0 & TH1520_FBDIV_MASK) >> TH1520_FBDIV_SHIFT;
+	postdiv1_old = (cfg0 & TH1520_POSTDIV1_MASK) >> TH1520_POSTDIV1_SHIFT;
+	postdiv2_old = (cfg0 & TH1520_POSTDIV2_MASK) >> TH1520_POSTDIV2_SHIFT;
+	frac_old = (cfg1 & TH1520_FRAC_MASK) >> TH1520_FRAC_SHIFT;
+
+	pll_changed = rate->refdiv != refdiv_old || rate->fbdiv != fbdiv_old ||
+		      rate->postdiv1 != postdiv1_old || rate->postdiv2 != postdiv2_old;
+	if (pll->pll_mode == PLL_MODE_FRAC)
+		pll_changed |= (rate->frac != frac_old);
+
+	return pll_changed;
+}
+
+static int clk_th1520_pll_set_rate(struct clk_hw *hw, unsigned long drate,
+				 unsigned long prate)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	const struct th1520_pll_rate_table *rate;
+	void __iomem *cfg1_off;
+	u32 tmp, div_val;
+	int ret;
+
+	if (pll->out_type == TH1520_PLL_VCO) {
+		rate = th1520_get_pll_vco_settings(pll, drate);
+		if (!rate) {
+			pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+				drate, clk_hw_get_name(hw));
+			return -EINVAL;
+		}
+	} else {
+		rate = th1520_get_pll_div_settings(pll, drate);
+		if (!rate) {
+			pr_err("%s: Invalid rate : %lu for pll clk %s\n", __func__,
+				drate, clk_hw_get_name(hw));
+			return -EINVAL;
+		}
+	}
+
+	if (!clk_th1520_pll_change(pll, rate))
+		return 0;
+
+	/* Enable RST */
+	cfg1_off = pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1;
+	tmp = readl_relaxed(cfg1_off);
+	tmp |= pll->pll_rst_bit;
+	writel_relaxed(tmp, cfg1_off);
+
+	div_val = (rate->refdiv << TH1520_REFDIV_SHIFT) |
+		  (rate->fbdiv << TH1520_FBDIV_SHIFT) |
+		  (rate->postdiv1 << TH1520_POSTDIV1_SHIFT) |
+		  (rate->postdiv2 << TH1520_POSTDIV2_SHIFT);
+	writel_relaxed(div_val, pll->base + pll->cfg0_reg_off);
+
+	if (pll->pll_mode == PLL_MODE_FRAC) {
+		tmp &= ~(TH1520_FRAC_MASK << TH1520_FRAC_SHIFT);
+		tmp |= rate->frac;
+		writel_relaxed(tmp, cfg1_off);
+	}
+
+	udelay(3);
+
+	/* Disable RST */
+	tmp &= ~pll->pll_rst_bit;
+	writel_relaxed(tmp, cfg1_off);
+
+	/* Wait Lock, ~20us cost */
+	ret = clk_th1520_pll_wait_lock(pll);
+	if (ret)
+		return ret;
+
+	/* HW requires 30us for pll stable */
+	udelay(30);
+
+	return 0;
+}
+
+static long clk_th1520_pllvco_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *prate)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+	unsigned long best = 0, now = 0;
+	unsigned int i, best_i = 0;
+
+	for (i = 0; i < pll->rate_count; i++) {
+		now = rate_table[i].vco_rate;
+
+		if (rate == now) {
+			return rate_table[i].vco_rate;
+		} else if (abs(now - rate) < abs(best - rate)) {
+			best = now;
+			best_i = i;
+		}
+	}
+
+	/* return minimum supported value */
+	return rate_table[best_i].vco_rate;
+}
+
+static long clk_th1520_plldiv_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *prate)
+{
+	struct clk_th1520pll *pll = to_clk_th1520pll(hw);
+	const struct th1520_pll_rate_table *rate_table = pll->rate_table;
+	unsigned long best = 0, now = 0;
+	unsigned int i, best_i = 0;
+
+	for (i = 0; i < pll->rate_count; i++) {
+		now = rate_table[i].rate;
+
+		if (rate == now) {
+			return rate_table[i].rate;
+		} else if (abs(now - rate) < abs(best - rate)) {
+			best = now;
+			best_i = i;
+		}
+	}
+
+	/* return minimum supported value */
+	return rate_table[best_i].rate;
+}
+
+static const struct clk_ops clk_th1520_pll_def_ops = {
+	.recalc_rate	= clk_th1520_pll_recalc_rate,
+};
+
+static const struct clk_ops clk_th1520_pllvco_ops = {
+	.prepare	= clk_th1520_pll_prepare,
+	.unprepare	= clk_th1520_pll_unprepare,
+	.is_prepared	= clk_th1520_pll_is_prepared,
+	.recalc_rate	= clk_th1520_pll_recalc_rate,
+	.round_rate	= clk_th1520_pllvco_round_rate,
+	.set_rate	= clk_th1520_pll_set_rate,
+};
+
+static const struct clk_ops clk_th1520_plldiv_ops = {
+	.prepare	= clk_th1520_pll_prepare,
+	.unprepare	= clk_th1520_pll_unprepare,
+	.is_prepared	= clk_th1520_pll_is_prepared,
+	.recalc_rate	= clk_th1520_pll_recalc_rate,
+	.round_rate	= clk_th1520_plldiv_round_rate,
+	.set_rate	= clk_th1520_pll_set_rate,
+};
+
+struct clk *xuantie_th1520_pll(const char *name, const char *parent_name,
+			    void __iomem *base,
+			    const struct th1520_pll_clk *pll_clk)
+{
+	struct clk_th1520pll *pll;
+	struct clk *clk;
+	struct clk_init_data init;
+	u32 val;
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = pll_clk->flags;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	switch (pll_clk->out_type) {
+	case TH1520_PLL_VCO:
+		if (pll_clk->rate_table)
+			init.ops = &clk_th1520_pllvco_ops;
+		break;
+	case TH1520_PLL_DIV:
+		if (pll_clk->rate_table)
+			init.ops = &clk_th1520_plldiv_ops;
+		break;
+	default:
+		pr_err("%s: Unknown pll out type for pll clk %s\n",
+		       __func__, name);
+	};
+
+	if (!pll_clk->rate_table)
+		init.ops = &clk_th1520_pll_def_ops;
+
+	pll->base = base;
+	pll->hw.init = &init;
+	pll->out_type = pll_clk->out_type;
+	pll->clk_type = pll_clk->clk_type;
+	pll->rate_table = pll_clk->rate_table;
+	pll->rate_count = pll_clk->rate_count;
+
+	clk_th1520_pll_cfg_init(pll);
+
+	val = readl_relaxed(pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+	val &= ~pll->pll_bypass_bit;
+	val |= TH1520_DACPD_MASK;
+	val |= TH1520_DSMPD_MASK;
+	if (pll->pll_mode == PLL_MODE_FRAC) {
+		val &= ~TH1520_DSMPD_MASK;
+		val &= ~TH1520_DACPD_MASK;
+	}
+	writel_relaxed(val, pll->base + pll->cfg0_reg_off + TH1520_PLL_CFG1);
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk)) {
+		pr_err("%s: failed to register pll %s %lu\n",
+			__func__, name, PTR_ERR(clk));
+		kfree(pll);
+	}
+
+	return clk;
+}
+
+static inline struct clk_th1520div *to_clk_th1520div(struct clk_hw *hw)
+{
+	struct clk_divider *divider = to_clk_divider(hw);
+
+	return container_of(divider, struct clk_th1520div, divider);
+}
+
+static unsigned long clk_th1520div_recalc_rate(struct clk_hw *hw,
+					 unsigned long parent_rate)
+{
+	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
+
+	return th1520_div->ops->recalc_rate(&th1520_div->divider.hw, parent_rate);
+}
+
+static long clk_th1520div_round_rate(struct clk_hw *hw, unsigned long rate,
+			       unsigned long *prate)
+{
+	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
+
+	return th1520_div->ops->round_rate(&th1520_div->divider.hw, rate, prate);
+}
+
+static int clk_th1520div_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct clk_th1520div *th1520_div = to_clk_th1520div(hw);
+	struct clk_divider *div = to_clk_divider(hw);
+	unsigned int divider, value;
+	unsigned long flags = 0;
+	u32 val;
+
+	/** 
+	 * The clk-divider will calculate the node frequency by rounding up 
+	 * based on the parent frequency and the target divider.
+	 * This calculation is to restore accurate frequency divider. 
+	*/
+	divider = DIV64_U64_ROUND_CLOSEST(parent_rate, rate);
+
+	/* DIV is zero based divider, but CDE is not */
+	if (th1520_div->div_type == MUX_TYPE_DIV)
+		value = divider;
+	else
+		value = divider - 1;
+
+	/* handle the div valid range */
+	if (value > th1520_div->max_div)
+		value = th1520_div->max_div;
+	if (value < th1520_div->min_div)
+		value = th1520_div->min_div;
+
+	spin_lock_irqsave(div->lock, flags);
+
+	val = readl(div->reg);
+	val &= ~BIT(th1520_div->sync_en);
+	writel(val, div->reg);
+
+	udelay(1);
+
+	val &= ~(div_mask(div) << div->shift);
+	val |= value << div->shift;
+	writel(val, div->reg);
+
+	udelay(1);
+
+	val |= BIT(th1520_div->sync_en);
+	writel(val, div->reg);
+
+	spin_unlock_irqrestore(div->lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops clk_th1520div_ops = {
+	.recalc_rate = clk_th1520div_recalc_rate,
+	.round_rate = clk_th1520div_round_rate,
+	.set_rate = clk_th1520div_set_rate,
+};
+
+static struct clk *xuantie_clk_th1520_divider_internal(const char *name, const char *parent,
+				       void __iomem *reg, u8 shift, u8 width,
+				       u8 sync, enum th1520_div_type div_type,
+				       u16 min, u16 max, bool closest)
+{
+	struct clk_th1520div *th1520_div;
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int ret;
+
+	th1520_div = kzalloc(sizeof(*th1520_div), GFP_KERNEL);
+	if (!th1520_div)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &clk_th1520div_ops;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_names = parent ? &parent : NULL;
+	init.num_parents = parent ? 1 : 0;
+
+	th1520_div->divider.reg = reg;
+	th1520_div->divider.shift = shift;
+	th1520_div->divider.width = width;
+	th1520_div->divider.lock = &xuantie_th1520_clk_lock;
+	th1520_div->divider.hw.init = &init;
+	th1520_div->ops = &clk_divider_ops;
+	th1520_div->sync_en = sync;
+	th1520_div->div_type = div_type;
+	if (th1520_div->div_type == MUX_TYPE_DIV)
+		th1520_div->divider.flags = CLK_DIVIDER_ONE_BASED;
+
+	if (closest)
+		th1520_div->divider.flags |= CLK_DIVIDER_ROUND_CLOSEST;
+
+	th1520_div->min_div = min > ((1 << width) - 1) ?
+			     ((1 << width) - 1) : min;
+	th1520_div->max_div = max > ((1 << width) - 1) ?
+			     ((1 << width) - 1) : max;
+
+	hw = &th1520_div->divider.hw;
+
+	ret = clk_hw_register(NULL, hw);
+	if (ret) {
+		kfree(th1520_div);
+		return ERR_PTR(ret);
+	}
+
+	return hw->clk;
+}
+
+struct clk *xuantie_clk_th1520_divider(const char *name, const char *parent,
+				       void __iomem *reg, u8 shift, u8 width,
+				       u8 sync, enum th1520_div_type div_type,
+				       u16 min, u16 max)
+{
+	return xuantie_clk_th1520_divider_internal(name, parent, reg, shift, width,
+											sync, div_type, min, max, false);
+}
+
+struct clk *xuantie_clk_th1520_divider_closest(const char *name, const char *parent,
+				       void __iomem *reg, u8 shift, u8 width,
+				       u8 sync, enum th1520_div_type div_type,
+				       u16 min, u16 max)
+{
+	return xuantie_clk_th1520_divider_internal(name, parent, reg, shift, width,
+											sync, div_type, min, max, true);
+}
+
+static inline struct clk_th1520gate *to_clk_th1520gate(struct clk_hw *hw)
+{
+	struct clk_gate *gate = to_clk_gate(hw);
+
+	return container_of(gate, struct clk_th1520gate, gate);
+}
+
+static int clk_th1520_gate_share_is_enabled(struct clk_hw *hw)
+{
+	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
+
+	return th1520_gate->ops->is_enabled(hw);
+}
+
+static int clk_th1520_gate_share_enable(struct clk_hw *hw)
+{
+	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
+
+	if (th1520_gate->share_count && (*th1520_gate->share_count)++ > 0) {
+		pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
+		return 0;
+	}
+
+	pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
+
+	return th1520_gate->ops->enable(hw);
+}
+
+static void clk_th1520_gate_share_disable(struct clk_hw *hw)
+{
+	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
+
+	if (th1520_gate->share_count) {
+		if (WARN_ON(*th1520_gate->share_count == 0))
+			return;
+		else if (--(*th1520_gate->share_count) > 0) {
+			pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
+			return;
+		}
+	}
+
+	pr_debug("[%s,%d]share_count = %d\n", __func__, __LINE__, (*th1520_gate->share_count));
+
+	th1520_gate->ops->disable(hw);
+}
+
+static void clk_th1520_gate_share_disable_unused(struct clk_hw *hw)
+{
+	struct clk_th1520gate *th1520_gate = to_clk_th1520gate(hw);
+
+	if (!th1520_gate->share_count || *th1520_gate->share_count == 0)
+		return th1520_gate->ops->disable(hw);
+}
+
+static const struct clk_ops clk_th1520gate_share_ops = {
+	.enable = clk_th1520_gate_share_enable,
+	.disable = clk_th1520_gate_share_disable,
+	.disable_unused = clk_th1520_gate_share_disable_unused,
+	.is_enabled = clk_th1520_gate_share_is_enabled,
+};
+
+struct clk *xuantie_clk_th1520_register_gate_shared(const char *name, const char *parent,
+						 unsigned long flags, void __iomem *reg,
+						 u8 shift, spinlock_t *lock,
+						 unsigned int *share_count)
+{
+	struct clk_th1520gate *th1520_gate;
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int ret;
+
+	th1520_gate = kzalloc(sizeof(*th1520_gate), GFP_KERNEL);
+	if (!th1520_gate)
+		return ERR_PTR(-ENOMEM);
+
+	th1520_gate->gate.reg = reg;
+	th1520_gate->gate.bit_idx = shift;
+	th1520_gate->gate.flags = 0;
+	th1520_gate->gate.lock = lock;
+	th1520_gate->gate.hw.init = &init;
+	th1520_gate->ops = &clk_gate_ops;
+	th1520_gate->share_count = share_count;
+
+	init.name = name;
+	init.ops = &clk_th1520gate_share_ops;
+	init.flags = flags;
+	init.parent_names = parent ? &parent : NULL;
+	init.num_parents = parent ? 1 : 0;
+
+	hw = &th1520_gate->gate.hw;
+
+	ret = clk_hw_register(NULL, hw);
+	if (ret) {
+		kfree(th1520_gate);
+		return ERR_PTR(ret);
+	}
+
+	return hw->clk;
+}
--- a/drivers/clk/thead/clk.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- */
-
-#ifndef __MACH_THEAD_CLK_H
-#define __MACH_THEAD_CLK_H
-
-#include <linux/spinlock.h>
-#include <linux/clk-provider.h>
-
-extern spinlock_t thead_th1520_clk_lock;
-
-#define TH1520_PLL_RATE(_vco, _rate, _r, _b, _f, _p, _k)	\
-	{						\
-		.vco_rate	=	(_vco),		\
-		.rate		=	(_rate),	\
-		.refdiv		=	(_r),		\
-		.fbdiv		=	(_b),		\
-		.frac		=	(_f),		\
-		.postdiv1	=	(_p),		\
-		.postdiv2	=	(_k),		\
-	}
-
-enum th1520_pll_outtype {
-	TH1520_PLL_VCO,
-	TH1520_PLL_DIV,
-};
-
-enum th1520_div_type {
-        MUX_TYPE_DIV,
-        MUX_TYPE_CDE,
-};
-
-enum th1520_pll_clktype {
-	TH1520_AUDIO_PLL,
-	TH1520_SYS_PLL,
-	TH1520_CPU_PLL0,
-	TH1520_CPU_PLL1,
-	TH1520_GMAC_PLL,
-	TH1520_VIDEO_PLL,
-	TH1520_DDR_PLL,
-	TH1520_DPU0_PLL,
-	TH1520_DPU1_PLL,
-};
-
-struct th1520_pll_rate_table {
-	unsigned long vco_rate;
-	unsigned long rate;
-	unsigned int refdiv;
-	unsigned int fbdiv;
-	unsigned int frac;
-	unsigned int postdiv1;
-	unsigned int postdiv2;
-};
-
-struct th1520_pll_clk {
-	enum th1520_pll_outtype out_type;
-	enum th1520_pll_clktype clk_type;
-	const struct th1520_pll_rate_table *rate_table;
-	int rate_count;
-	int flags;
-};
-
-static inline struct clk *thead_th1520_clk_fixed_factor(const char *name,
-		const char *parent, unsigned int mult, unsigned int div)
-{
-	return clk_register_fixed_factor(NULL, name, parent,
-			CLK_SET_RATE_PARENT, mult, div);
-}
-
-struct clk *thead_th1520_pll(const char *name, const char *parent_name,
-			    void __iomem *base,
-			    const struct th1520_pll_clk *pll_clk);
-
-static inline struct clk *thead_clk_th1520_gate(const char *name, const char *parent,
-					       void __iomem *reg, u8 shift)
-{
-	return clk_register_gate(NULL, name, parent, CLK_SET_RATE_PARENT, reg,
-			shift, 0, &thead_th1520_clk_lock);
-}
-
-struct clk *thead_clk_th1520_register_gate_shared(const char *name, const char *parent,
-						 unsigned long flags, void __iomem *reg,
-						 u8 shift, spinlock_t *lock,
-						 unsigned int *share_count);
-
-struct clk *thead_clk_th1520_divider(const char *name, const char *parent,
-				    void __iomem *reg, u8 shift, u8 width,
-				    u8 sync, enum th1520_div_type div_type,
-				    u16 min, u16 max);
-
-/**
-* By default, the clk framework calculates frequency by rounding downwards.
-* This function is to achieve closest frequency.
-*/
-struct clk *thead_clk_th1520_divider_closest(const char *name, const char *parent,
-				    void __iomem *reg, u8 shift, u8 width,
-				    u8 sync, enum th1520_div_type div_type,
-				    u16 min, u16 max);
-
-void thead_unregister_clocks(struct clk *clks[], unsigned int count);
-
-static inline struct clk *thead_clk_fixed(const char *name, unsigned long rate)
-{
-	return clk_register_fixed_rate(NULL, name, NULL, 0, rate);
-}
-
-static inline struct clk *thead_clk_th1520_gate_shared(const char *name, const char *parent,
-					void __iomem *reg, u8 shift,
-					unsigned int *share_count)
-{
-	return thead_clk_th1520_register_gate_shared(name, parent, CLK_SET_RATE_PARENT, reg,
-						    shift, &thead_th1520_clk_lock, share_count);
-}
-
-static inline struct clk *thead_th1520_clk_mux_flags(const char *name,
-			void __iomem *reg, u8 shift, u8 width,
-			const char * const *parents, int num_parents,
-			unsigned long flags)
-{
-	return clk_register_mux(NULL, name, parents, num_parents,
-			flags , reg, shift, width, 0,
-			&thead_th1520_clk_lock);
-}
-#endif
--- /dev/null
+++ b/drivers/clk/xuantie/clk.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#ifndef __MACH_XUANTIE_CLK_H
+#define __MACH_XUANTIE_CLK_H
+
+#include <linux/spinlock.h>
+#include <linux/clk-provider.h>
+
+extern spinlock_t xuantie_th1520_clk_lock;
+
+#define TH1520_PLL_RATE(_vco, _rate, _r, _b, _f, _p, _k)	\
+	{						\
+		.vco_rate	=	(_vco),		\
+		.rate		=	(_rate),	\
+		.refdiv		=	(_r),		\
+		.fbdiv		=	(_b),		\
+		.frac		=	(_f),		\
+		.postdiv1	=	(_p),		\
+		.postdiv2	=	(_k),		\
+	}
+
+enum th1520_pll_outtype {
+	TH1520_PLL_VCO,
+	TH1520_PLL_DIV,
+};
+
+enum th1520_div_type {
+        MUX_TYPE_DIV,
+        MUX_TYPE_CDE,
+};
+
+enum th1520_pll_clktype {
+	TH1520_AUDIO_PLL,
+	TH1520_SYS_PLL,
+	TH1520_CPU_PLL0,
+	TH1520_CPU_PLL1,
+	TH1520_GMAC_PLL,
+	TH1520_VIDEO_PLL,
+	TH1520_DDR_PLL,
+	TH1520_DPU0_PLL,
+	TH1520_DPU1_PLL,
+};
+
+struct th1520_pll_rate_table {
+	unsigned long vco_rate;
+	unsigned long rate;
+	unsigned int refdiv;
+	unsigned int fbdiv;
+	unsigned int frac;
+	unsigned int postdiv1;
+	unsigned int postdiv2;
+};
+
+struct th1520_pll_clk {
+	enum th1520_pll_outtype out_type;
+	enum th1520_pll_clktype clk_type;
+	const struct th1520_pll_rate_table *rate_table;
+	int rate_count;
+	int flags;
+};
+
+static inline struct clk *xuantie_th1520_clk_fixed_factor(const char *name,
+		const char *parent, unsigned int mult, unsigned int div)
+{
+	return clk_register_fixed_factor(NULL, name, parent,
+			CLK_SET_RATE_PARENT, mult, div);
+}
+
+struct clk *xuantie_th1520_pll(const char *name, const char *parent_name,
+			    void __iomem *base,
+			    const struct th1520_pll_clk *pll_clk);
+
+static inline struct clk *xuantie_clk_th1520_gate(const char *name, const char *parent,
+					       void __iomem *reg, u8 shift)
+{
+	return clk_register_gate(NULL, name, parent, CLK_SET_RATE_PARENT, reg,
+			shift, 0, &xuantie_th1520_clk_lock);
+}
+
+struct clk *xuantie_clk_th1520_register_gate_shared(const char *name, const char *parent,
+						 unsigned long flags, void __iomem *reg,
+						 u8 shift, spinlock_t *lock,
+						 unsigned int *share_count);
+
+struct clk *xuantie_clk_th1520_divider(const char *name, const char *parent,
+				    void __iomem *reg, u8 shift, u8 width,
+				    u8 sync, enum th1520_div_type div_type,
+				    u16 min, u16 max);
+
+/**
+* By default, the clk framework calculates frequency by rounding downwards.
+* This function is to achieve closest frequency.
+*/
+struct clk *xuantie_clk_th1520_divider_closest(const char *name, const char *parent,
+				    void __iomem *reg, u8 shift, u8 width,
+				    u8 sync, enum th1520_div_type div_type,
+				    u16 min, u16 max);
+
+void xuantie_unregister_clocks(struct clk *clks[], unsigned int count);
+
+static inline struct clk *xuantie_clk_fixed(const char *name, unsigned long rate)
+{
+	return clk_register_fixed_rate(NULL, name, NULL, 0, rate);
+}
+
+static inline struct clk *xuantie_clk_th1520_gate_shared(const char *name, const char *parent,
+					void __iomem *reg, u8 shift,
+					unsigned int *share_count)
+{
+	return xuantie_clk_th1520_register_gate_shared(name, parent, CLK_SET_RATE_PARENT, reg,
+						    shift, &xuantie_th1520_clk_lock, share_count);
+}
+
+static inline struct clk *xuantie_th1520_clk_mux_flags(const char *name,
+			void __iomem *reg, u8 shift, u8 width,
+			const char * const *parents, int num_parents,
+			unsigned long flags)
+{
+	return clk_register_mux(NULL, name, parents, num_parents,
+			flags , reg, shift, width, 0,
+			&xuantie_th1520_clk_lock);
+}
+#endif
--- /dev/null
+++ b/drivers/clk/xuantie/gate/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_CLK_TH1520_FM) += xuantie-gate.o visys-gate.o vpsys-gate.o vosys-gate.o dspsys-gate.o audiosys-gate.o miscsys-gate.o
--- a/drivers/clk/thead/gate/audiosys-gate.c
+++ /dev/null
@@ -1,124 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-
-#include <dt-bindings/clock/th1520-fm-ap-clock.h>
-#include <dt-bindings/clock/th1520-audiosys.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include "clk-gate.h"
-#include "../clk.h"
-
-static struct clk *gates[TH1520_CLKGEN_AUDIO_CLK_END];
-static struct clk_onecell_data clk_gate_data;
-
-static int th1520_audiosys_clk_probe(struct platform_device *pdev)
-{
-	struct regmap *audiosys_regmap;
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	int ret;
-
-	audiosys_regmap = syscon_regmap_lookup_by_phandle(np, "audiosys-regmap");
-	if (IS_ERR(audiosys_regmap)) {
-		dev_err(&pdev->dev, "cannot find regmap for vi system register\n");
-		return PTR_ERR(audiosys_regmap);
-	}
-
-	printk("%s audiosys_regmap=0x%px\n", __func__, audiosys_regmap);
-
-	/* we assume that the gate clock is a root clock  */
-	gates[TH1520_CLKGEN_AUDIO_CPU] = thead_gate_clk_register("clkgen_audiosys_cpu_clk", NULL,
-									audiosys_regmap, 0x10, 0, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_SRAM0] = thead_gate_clk_register("clkgen_audiosys_sram0_clk", NULL,
-									audiosys_regmap, 0x10, 1, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_SRAM1] = thead_gate_clk_register("clkgen_audiosys_sram1_clk", NULL,
-									audiosys_regmap, 0x10, 2, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_DMA] = thead_gate_clk_register("clkgen_audiosys_dma_clk", NULL,
-									audiosys_regmap, 0x10, 3, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_BSM] = thead_gate_clk_register("clkgen_audiosys_bsm_clk", NULL,
-									audiosys_regmap, 0x10, 4, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_TIMER] = thead_gate_clk_register("clkgen_audiosys_timer_clk", NULL,
-									audiosys_regmap, 0x10, 8, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT1] = thead_gate_clk_register("clkgen_audiosys_timer_cnt1_clk", NULL,
-									audiosys_regmap, 0x10, 9, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT2] = thead_gate_clk_register("clkgen_audiosys_timer_cnt2_clk", NULL,
-									audiosys_regmap, 0x10, 10, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT3] = thead_gate_clk_register("clkgen_audiosys_timer_cnt3_clk", NULL,
-									audiosys_regmap, 0x10, 11, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT4] = thead_gate_clk_register("clkgen_audiosys_timer_cnt4_clk", NULL,
-									audiosys_regmap, 0x10, 12, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_WDR] = thead_gate_clk_register("clkgen_audiosys_wdr_clk", NULL,
-									audiosys_regmap, 0x10, 13, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_I2C0] = thead_gate_clk_register("clkgen_audiosys_i2c0_clk", NULL,
-									audiosys_regmap, 0x10, 14, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_I2C1] = thead_gate_clk_register("clkgen_audiosys_i2c1_clk", NULL,
-									audiosys_regmap, 0x10, 15, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_UART] = thead_gate_clk_register("clkgen_audiosys_uart_clk", NULL,
-									audiosys_regmap, 0x10, 16, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_I2S0] = thead_gate_clk_register("clkgen_audiosys_i2s0_clk", NULL,
-									audiosys_regmap, 0x10, 17, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_I2S1] = thead_gate_clk_register("clkgen_audiosys_i2s1_clk", NULL,
-									audiosys_regmap, 0x10, 18, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_I2S2] = thead_gate_clk_register("clkgen_audiosys_i2s2_clk", NULL,
-									audiosys_regmap, 0x10, 19, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_I2S8CH] = thead_gate_clk_register("clkgen_audiosys_i2s8ch_clk", NULL,
-									audiosys_regmap, 0x10, 20, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_TDM] = thead_gate_clk_register("clkgen_audiosys_tdm_clk", NULL,
-									audiosys_regmap, 0x10, 21, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_GPIO] = thead_gate_clk_register("clkgen_audiosys_gpio_clk", NULL,
-									audiosys_regmap, 0x10, 22, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_SPDIF0] = thead_gate_clk_register("clkgen_audiosys_spdif0_clk", NULL,
-									audiosys_regmap, 0x10, 23, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_SPDIF1] = thead_gate_clk_register("clkgen_audiosys_spdif1_clk", NULL,
-									audiosys_regmap, 0x10, 24, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_VAD] = thead_gate_clk_register("clkgen_audiosys_vad_clk", NULL,
-									audiosys_regmap, 0x10, 25, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AUDIO_IOMUX] = thead_gate_clk_register("clkgen_audiosys_iomux_clk", NULL,
-									audiosys_regmap, 0x10, 26, GATE_NOT_SHARED, NULL, dev);
-
-	clk_gate_data.clks = gates;
-	clk_gate_data.clk_num = ARRAY_SIZE(gates);
-
-	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
-	if (ret < 0) {
-		dev_err(dev, "failed to register gate clks for th1520 audiosys\n");
-		goto unregister_clks;
-	}
-
-	dev_info(dev, "succeed to register audiosys gate clock provider\n");
-
-	return 0;
-
-unregister_clks:
-	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
-	return ret;
-}
-
-static const struct of_device_id audiosys_clk_gate_of_match[] = {
-	{ .compatible = "thead,audiosys-gate-controller" },
-	{ /* sentinel */ },
-};
-MODULE_DEVICE_TABLE(of, audiosys_clk_gate_of_match);
-
-static struct platform_driver th1520_audiosys_clk_driver = {
-	.probe = th1520_audiosys_clk_probe,
-	.driver = {
-		.name = "audiosys-clk-gate-provider",
-		.of_match_table = of_match_ptr(audiosys_clk_gate_of_match),
-	},
-};
-
-module_platform_driver(th1520_audiosys_clk_driver);
-MODULE_AUTHOR("nanli.yd <nanli.yd@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead Th1520 Fullmask audiosys clock gate provider");
-MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/clk/xuantie/gate/audiosys-gate.c
@@ -0,0 +1,124 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <dt-bindings/clock/th1520-audiosys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "clk-gate.h"
+#include "../clk.h"
+
+static struct clk *gates[TH1520_CLKGEN_AUDIO_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+
+static int th1520_audiosys_clk_probe(struct platform_device *pdev)
+{
+	struct regmap *audiosys_regmap;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	audiosys_regmap = syscon_regmap_lookup_by_phandle(np, "audiosys-regmap");
+	if (IS_ERR(audiosys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for vi system register\n");
+		return PTR_ERR(audiosys_regmap);
+	}
+
+	printk("%s audiosys_regmap=0x%px\n", __func__, audiosys_regmap);
+
+	/* we assume that the gate clock is a root clock  */
+	gates[TH1520_CLKGEN_AUDIO_CPU] = xuantie_gate_clk_register("clkgen_audiosys_cpu_clk", NULL,
+									audiosys_regmap, 0x10, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_SRAM0] = xuantie_gate_clk_register("clkgen_audiosys_sram0_clk", NULL,
+									audiosys_regmap, 0x10, 1, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_SRAM1] = xuantie_gate_clk_register("clkgen_audiosys_sram1_clk", NULL,
+									audiosys_regmap, 0x10, 2, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_DMA] = xuantie_gate_clk_register("clkgen_audiosys_dma_clk", NULL,
+									audiosys_regmap, 0x10, 3, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_BSM] = xuantie_gate_clk_register("clkgen_audiosys_bsm_clk", NULL,
+									audiosys_regmap, 0x10, 4, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER] = xuantie_gate_clk_register("clkgen_audiosys_timer_clk", NULL,
+									audiosys_regmap, 0x10, 8, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT1] = xuantie_gate_clk_register("clkgen_audiosys_timer_cnt1_clk", NULL,
+									audiosys_regmap, 0x10, 9, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT2] = xuantie_gate_clk_register("clkgen_audiosys_timer_cnt2_clk", NULL,
+									audiosys_regmap, 0x10, 10, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT3] = xuantie_gate_clk_register("clkgen_audiosys_timer_cnt3_clk", NULL,
+									audiosys_regmap, 0x10, 11, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TIMER_CNT4] = xuantie_gate_clk_register("clkgen_audiosys_timer_cnt4_clk", NULL,
+									audiosys_regmap, 0x10, 12, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_WDR] = xuantie_gate_clk_register("clkgen_audiosys_wdr_clk", NULL,
+									audiosys_regmap, 0x10, 13, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2C0] = xuantie_gate_clk_register("clkgen_audiosys_i2c0_clk", NULL,
+									audiosys_regmap, 0x10, 14, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2C1] = xuantie_gate_clk_register("clkgen_audiosys_i2c1_clk", NULL,
+									audiosys_regmap, 0x10, 15, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_UART] = xuantie_gate_clk_register("clkgen_audiosys_uart_clk", NULL,
+									audiosys_regmap, 0x10, 16, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2S0] = xuantie_gate_clk_register("clkgen_audiosys_i2s0_clk", NULL,
+									audiosys_regmap, 0x10, 17, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2S1] = xuantie_gate_clk_register("clkgen_audiosys_i2s1_clk", NULL,
+									audiosys_regmap, 0x10, 18, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2S2] = xuantie_gate_clk_register("clkgen_audiosys_i2s2_clk", NULL,
+									audiosys_regmap, 0x10, 19, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_I2S8CH] = xuantie_gate_clk_register("clkgen_audiosys_i2s8ch_clk", NULL,
+									audiosys_regmap, 0x10, 20, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_TDM] = xuantie_gate_clk_register("clkgen_audiosys_tdm_clk", NULL,
+									audiosys_regmap, 0x10, 21, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_GPIO] = xuantie_gate_clk_register("clkgen_audiosys_gpio_clk", NULL,
+									audiosys_regmap, 0x10, 22, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_SPDIF0] = xuantie_gate_clk_register("clkgen_audiosys_spdif0_clk", NULL,
+									audiosys_regmap, 0x10, 23, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_SPDIF1] = xuantie_gate_clk_register("clkgen_audiosys_spdif1_clk", NULL,
+									audiosys_regmap, 0x10, 24, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_VAD] = xuantie_gate_clk_register("clkgen_audiosys_vad_clk", NULL,
+									audiosys_regmap, 0x10, 25, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AUDIO_IOMUX] = xuantie_gate_clk_register("clkgen_audiosys_iomux_clk", NULL,
+									audiosys_regmap, 0x10, 26, GATE_NOT_SHARED, NULL, dev);
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 audiosys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register audiosys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	xuantie_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id audiosys_clk_gate_of_match[] = {
+	{ .compatible = "xuantie,audiosys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, audiosys_clk_gate_of_match);
+
+static struct platform_driver th1520_audiosys_clk_driver = {
+	.probe = th1520_audiosys_clk_probe,
+	.driver = {
+		.name = "audiosys-clk-gate-provider",
+		.of_match_table = of_match_ptr(audiosys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(th1520_audiosys_clk_driver);
+MODULE_AUTHOR("nanli.yd <nanli.yd@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie Th1520 Fullmask audiosys clock gate provider");
+MODULE_LICENSE("GPL v2");
--- a/drivers/clk/thead/gate/clk-gate.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-
-#ifndef CLK_GATE_H
-#define CLK_GATE_H
-
-#include <linux/clk-provider.h>
-#include <linux/mfd/syscon.h>
-
-enum clk_gate_type {
-	GATE_NOT_SHARED,
-	GATE_SHARED,
-};
-
-struct thead_clk_gate {
-	struct clk_hw hw;
-	struct regmap *regmap;
-	u32 offset;
-	u8 bit;
-	bool shared;
-	u32 *share_count;
-};
-
-struct clk *thead_gate_clk_register(const char *name,
-				    const char *parent_name,
-				    struct regmap *regmap,
-				    int offset,
-				    u8 bit,
-				    bool shared,
-				    u32 *share_count,
-				    struct device *dev);
-
-#endif
--- /dev/null
+++ b/drivers/clk/xuantie/gate/clk-gate.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef CLK_GATE_H
+#define CLK_GATE_H
+
+#include <linux/clk-provider.h>
+#include <linux/mfd/syscon.h>
+
+enum clk_gate_type {
+	GATE_NOT_SHARED,
+	GATE_SHARED,
+};
+
+struct xuantie_clk_gate {
+	struct clk_hw hw;
+	struct regmap *regmap;
+	u32 offset;
+	u8 bit;
+	bool shared;
+	u32 *share_count;
+};
+
+struct clk *xuantie_gate_clk_register(const char *name,
+				    const char *parent_name,
+				    struct regmap *regmap,
+				    int offset,
+				    u8 bit,
+				    bool shared,
+				    u32 *share_count,
+				    struct device *dev);
+
+#endif
--- a/drivers/clk/thead/gate/dspsys-gate.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-
-#include <dt-bindings/clock/th1520-dspsys.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/mfd/syscon.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include "clk-gate.h"
-#include "../clk.h"
-
-static struct clk *gates[TH1520_CLKGEN_DSPSYS_CLK_END];
-static struct clk_onecell_data clk_gate_data;
-static const char * const dsp0_cclk_sels[] = {"gmac_pll_foutpostdiv", "dspsys_dsp_clk"};
-static const char * const dsp1_cclk_sels[] = {"gmac_pll_foutpostdiv", "dspsys_dsp_clk"};
-
-static int thead_dspsys_clk_probe(struct platform_device *pdev)
-{
-	struct regmap *dspsys_regmap, *tee_dspsys_regmap;
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	struct device_node *np_reg = of_parse_phandle(np, "dspsys-regmap", 0);
-	void __iomem *gate_base;
-	int ret;
-
-	dspsys_regmap = syscon_regmap_lookup_by_phandle(np, "dspsys-regmap");
-	if (IS_ERR(dspsys_regmap)) {
-		dev_err(&pdev->dev, "cannot find regmap for dsp system register\n");
-		return PTR_ERR(dspsys_regmap);
-	}
-
-	tee_dspsys_regmap = syscon_regmap_lookup_by_phandle(np, "tee-dspsys-regmap");
-	if (IS_ERR(tee_dspsys_regmap)) {
-		dev_warn(&pdev->dev, "cannot find regmap for tee dsp system register\n");
-		tee_dspsys_regmap = NULL;
-	}
-	gate_base = of_iomap(np_reg,0);
-	// MUX 
-	gates[DSPSYS_DSP0_CLK_SWITCH] = thead_th1520_clk_mux_flags("dspsys_dsp0_clk_switch", gate_base + 0x1c, 0, 1, dsp0_cclk_sels, ARRAY_SIZE(dsp0_cclk_sels), 0);
-	gates[DSPSYS_DSP1_CLK_SWITCH] = thead_th1520_clk_mux_flags("dspsys_dsp1_clk_switch", gate_base + 0x20, 0, 1, dsp1_cclk_sels, ARRAY_SIZE(dsp1_cclk_sels), 0);
-
-	// DIV & CDE
-	gates[DSPSYS_DSP_CLK] = thead_th1520_clk_fixed_factor("dspsys_dsp_clk", "video_pll_foutvco", 1, 3);
-	gates[DSPSYS_DSP0_CLK_CDE] = thead_clk_th1520_divider("dspsys_dsp0_clk_cde", "dspsys_dsp0_clk_switch", gate_base + 0x0, 0, 3, 4, MUX_TYPE_CDE, 0, 7);
-	gates[DSPSYS_DSP1_CLK_CDE] = thead_clk_th1520_divider("dspsys_dsp1_clk_cde", "dspsys_dsp1_clk_switch", gate_base + 0x4, 0, 3, 4, MUX_TYPE_CDE, 0, 7);
-
-	// gate
-	gates[CLKGEN_DSP0_PCLK] = thead_gate_clk_register("clkgen_dsp0_pclk", NULL, dspsys_regmap,
-							  0x24, 0, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_DSP1_PCLK] = thead_gate_clk_register("clkgen_dsp1_pclk", NULL, dspsys_regmap,
-							  0x24, 1, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_DSP1_CCLK] = thead_gate_clk_register("clkgen_dsp1_cclk", "dspsys_dsp1_clk_cde", dspsys_regmap,
-							  0x24, 2, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_DSP0_CCLK] = thead_gate_clk_register("clkgen_dsp0_cclk", "dspsys_dsp0_clk_cde", dspsys_regmap,
-							  0x24, 3, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_X2X_DSP2_ACLK_S] = thead_gate_clk_register("clkgen_x2x_dsp2_aclk_s", NULL, dspsys_regmap,
-							  0x24, 4, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_X2X_DSP0_ACLK_S] = thead_gate_clk_register("clkgen_x2x_dsp0_aclk_s", NULL, dspsys_regmap,
-							  0x24, 5, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_X2X_X4_DSPSLV_DSP1_ACLK_M] = thead_gate_clk_register("clkgen_x2x_x4_dspslv_dsp1_aclk_m",
-							  NULL, dspsys_regmap, 0x24, 6, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_X2X_X4_DSPSLV_DSP0_ACLK_M] = thead_gate_clk_register("clkgen_x2x_x4_dspslv_dsp0_aclk_m",
-							  NULL, dspsys_regmap, 0x24, 7, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_AXI4_DSPSYS_SLV_ACLK] = thead_gate_clk_register("clkgen_axi4_dspsys_slv_aclk", NULL, dspsys_regmap,
-							  0x24, 20, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_AXI4_DSPSYS_SLV_PCLK] = thead_gate_clk_register("clkgen_axi4_dspsys_slv_pclk", NULL, dspsys_regmap,
-							  0x24, 21, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_AXI4_DSPSYS_ACLK] = thead_gate_clk_register("clkgen_axi4_dspsys_aclk", NULL, dspsys_regmap,
-							  0x24, 23, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_AXI4_DSPSYS_PCLK] = thead_gate_clk_register("clkgen_axi4_dspsys_pclk", NULL, dspsys_regmap,
-							  0x24, 24, GATE_NOT_SHARED, NULL, dev);
-	if (tee_dspsys_regmap) {
-		gates[CLKGEN_IOPMP_DSP1_PCLK] = thead_gate_clk_register("clkgen_iopmp_dsp1_pclk", NULL, tee_dspsys_regmap,
-							  0x24, 25, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_IOPMP_DSP0_PCLK] = thead_gate_clk_register("clkgen_iopmp_dsp0_pclk", NULL, tee_dspsys_regmap,
-							  0x24, 26, GATE_NOT_SHARED, NULL, dev);
-	}
-
-	clk_gate_data.clks = gates;
-	clk_gate_data.clk_num = ARRAY_SIZE(gates);
-
-	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
-	if (ret < 0) {
-		dev_err(dev, "failed to register gate clks for th1520 dspsys\n");
-		goto unregister_clks;
-	}
-
-	dev_info(dev, "succeed to register dspsys gate clock provider\n");
-
-	return 0;
-
-unregister_clks:
-	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
-	return ret;
-}
-
-static const struct of_device_id dspsys_clk_gate_of_match[] = {
-	{ .compatible = "thead,dspsys-gate-controller" },
-	{ /* sentinel */ },
-};
-MODULE_DEVICE_TABLE(of, dspsys_clk_gate_of_match);
-
-static struct platform_driver thead_dspsys_clk_driver = {
-	.probe = thead_dspsys_clk_probe,
-	.driver = {
-		.name = "dspsys-clk-gate-provider",
-		.of_match_table = of_match_ptr(dspsys_clk_gate_of_match),
-	},
-};
-
-module_platform_driver(thead_dspsys_clk_driver);
-MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead Th1520 Fullmask dspsys clock gate provider");
-MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/clk/xuantie/gate/dspsys-gate.c
@@ -0,0 +1,123 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-dspsys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "clk-gate.h"
+#include "../clk.h"
+
+static struct clk *gates[TH1520_CLKGEN_DSPSYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+static const char * const dsp0_cclk_sels[] = {"gmac_pll_foutpostdiv", "dspsys_dsp_clk"};
+static const char * const dsp1_cclk_sels[] = {"gmac_pll_foutpostdiv", "dspsys_dsp_clk"};
+
+static int xuantie_dspsys_clk_probe(struct platform_device *pdev)
+{
+	struct regmap *dspsys_regmap, *tee_dspsys_regmap;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *np_reg = of_parse_phandle(np, "dspsys-regmap", 0);
+	void __iomem *gate_base;
+	int ret;
+
+	dspsys_regmap = syscon_regmap_lookup_by_phandle(np, "dspsys-regmap");
+	if (IS_ERR(dspsys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for dsp system register\n");
+		return PTR_ERR(dspsys_regmap);
+	}
+
+	tee_dspsys_regmap = syscon_regmap_lookup_by_phandle(np, "tee-dspsys-regmap");
+	if (IS_ERR(tee_dspsys_regmap)) {
+		dev_warn(&pdev->dev, "cannot find regmap for tee dsp system register\n");
+		tee_dspsys_regmap = NULL;
+	}
+	gate_base = of_iomap(np_reg,0);
+	// MUX 
+	gates[DSPSYS_DSP0_CLK_SWITCH] = xuantie_th1520_clk_mux_flags("dspsys_dsp0_clk_switch", gate_base + 0x1c, 0, 1, dsp0_cclk_sels, ARRAY_SIZE(dsp0_cclk_sels), 0);
+	gates[DSPSYS_DSP1_CLK_SWITCH] = xuantie_th1520_clk_mux_flags("dspsys_dsp1_clk_switch", gate_base + 0x20, 0, 1, dsp1_cclk_sels, ARRAY_SIZE(dsp1_cclk_sels), 0);
+
+	// DIV & CDE
+	gates[DSPSYS_DSP_CLK] = xuantie_th1520_clk_fixed_factor("dspsys_dsp_clk", "video_pll_foutvco", 1, 3);
+	gates[DSPSYS_DSP0_CLK_CDE] = xuantie_clk_th1520_divider("dspsys_dsp0_clk_cde", "dspsys_dsp0_clk_switch", gate_base + 0x0, 0, 3, 4, MUX_TYPE_CDE, 0, 7);
+	gates[DSPSYS_DSP1_CLK_CDE] = xuantie_clk_th1520_divider("dspsys_dsp1_clk_cde", "dspsys_dsp1_clk_switch", gate_base + 0x4, 0, 3, 4, MUX_TYPE_CDE, 0, 7);
+
+	// gate
+	gates[CLKGEN_DSP0_PCLK] = xuantie_gate_clk_register("clkgen_dsp0_pclk", NULL, dspsys_regmap,
+							  0x24, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_DSP1_PCLK] = xuantie_gate_clk_register("clkgen_dsp1_pclk", NULL, dspsys_regmap,
+							  0x24, 1, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_DSP1_CCLK] = xuantie_gate_clk_register("clkgen_dsp1_cclk", "dspsys_dsp1_clk_cde", dspsys_regmap,
+							  0x24, 2, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_DSP0_CCLK] = xuantie_gate_clk_register("clkgen_dsp0_cclk", "dspsys_dsp0_clk_cde", dspsys_regmap,
+							  0x24, 3, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_X2X_DSP2_ACLK_S] = xuantie_gate_clk_register("clkgen_x2x_dsp2_aclk_s", NULL, dspsys_regmap,
+							  0x24, 4, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_X2X_DSP0_ACLK_S] = xuantie_gate_clk_register("clkgen_x2x_dsp0_aclk_s", NULL, dspsys_regmap,
+							  0x24, 5, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_X2X_X4_DSPSLV_DSP1_ACLK_M] = xuantie_gate_clk_register("clkgen_x2x_x4_dspslv_dsp1_aclk_m",
+							  NULL, dspsys_regmap, 0x24, 6, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_X2X_X4_DSPSLV_DSP0_ACLK_M] = xuantie_gate_clk_register("clkgen_x2x_x4_dspslv_dsp0_aclk_m",
+							  NULL, dspsys_regmap, 0x24, 7, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_AXI4_DSPSYS_SLV_ACLK] = xuantie_gate_clk_register("clkgen_axi4_dspsys_slv_aclk", NULL, dspsys_regmap,
+							  0x24, 20, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_AXI4_DSPSYS_SLV_PCLK] = xuantie_gate_clk_register("clkgen_axi4_dspsys_slv_pclk", NULL, dspsys_regmap,
+							  0x24, 21, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_AXI4_DSPSYS_ACLK] = xuantie_gate_clk_register("clkgen_axi4_dspsys_aclk", NULL, dspsys_regmap,
+							  0x24, 23, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_AXI4_DSPSYS_PCLK] = xuantie_gate_clk_register("clkgen_axi4_dspsys_pclk", NULL, dspsys_regmap,
+							  0x24, 24, GATE_NOT_SHARED, NULL, dev);
+	if (tee_dspsys_regmap) {
+		gates[CLKGEN_IOPMP_DSP1_PCLK] = xuantie_gate_clk_register("clkgen_iopmp_dsp1_pclk", NULL, tee_dspsys_regmap,
+							  0x24, 25, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_IOPMP_DSP0_PCLK] = xuantie_gate_clk_register("clkgen_iopmp_dsp0_pclk", NULL, tee_dspsys_regmap,
+							  0x24, 26, GATE_NOT_SHARED, NULL, dev);
+	}
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 dspsys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register dspsys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	xuantie_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id dspsys_clk_gate_of_match[] = {
+	{ .compatible = "xuantie,dspsys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, dspsys_clk_gate_of_match);
+
+static struct platform_driver xuantie_dspsys_clk_driver = {
+	.probe = xuantie_dspsys_clk_probe,
+	.driver = {
+		.name = "dspsys-clk-gate-provider",
+		.of_match_table = of_match_ptr(dspsys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(xuantie_dspsys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie Th1520 Fullmask dspsys clock gate provider");
+MODULE_LICENSE("GPL v2");
--- a/drivers/clk/thead/gate/miscsys-gate.c
+++ /dev/null
@@ -1,108 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-#include <dt-bindings/clock/th1520-miscsys.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include "clk-gate.h"
-#include "../clk.h"
-static struct clk *gates[CLKGEN_MISCSYS_CLK_END];
-static struct clk_onecell_data clk_gate_data;
-static int thead_miscsys_clk_probe(struct platform_device *pdev)
-{
-	struct regmap *miscsys_regmap, *tee_miscsys_regmap = NULL;
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	int ret;
-
-	miscsys_regmap = syscon_regmap_lookup_by_phandle(np, "miscsys-regmap");
-	if (IS_ERR(miscsys_regmap)) {
-		dev_err(&pdev->dev, "cannot find regmap for misc system register\n");
-		return PTR_ERR(miscsys_regmap);
-	}
-	tee_miscsys_regmap = syscon_regmap_lookup_by_phandle(np, "tee-miscsys-regmap");
-	if (IS_ERR(tee_miscsys_regmap)) {
-		dev_err(&pdev->dev, "cannot find regmap for tee misc system register\n");
-		return PTR_ERR(tee_miscsys_regmap);
-	}
-	/* we assume that the gate clock is a root clock  */
-	gates[CLKGEN_MISCSYS_MISCSYS_ACLK] = thead_gate_clk_register("clkgen_missys_aclk", NULL,
-								miscsys_regmap, 0x100, 0, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_MISCSYS_USB3_DRD_CLK] = thead_gate_clk_register("clkgen_usb3_drd_clk", NULL,
-								miscsys_regmap, 0x104, 0, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_MISCSYS_USB3_DRD_CTRL_REF_CLK] = thead_gate_clk_register("clkgen_usb3_drd_ctrl_ref_clk", "osc_24m",
-								miscsys_regmap, 0x104, 1, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_MISCSYS_USB3_DRD_PHY_REF_CLK] = thead_gate_clk_register("clkgen_usb3_drd_phy_ref_clk", "osc_24m",
-								miscsys_regmap, 0x104, 2, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_MISCSYS_USB3_DRD_SUSPEND_CLK] = thead_gate_clk_register("clkgen_usb3_drd_suspend_clk", NULL,
-								miscsys_regmap, 0x104, 3, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_MISCSYS_EMMC_CLK] = thead_gate_clk_register("clkgen_emmc_clk", "osc_24m",
-								miscsys_regmap, 0x108, 0, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_MISCSYS_SDIO0_CLK] = thead_gate_clk_register("clkgen_sdio0_clk", "osc_24m",
-								miscsys_regmap, 0x10c, 0, GATE_NOT_SHARED, NULL, dev);
-	gates[CLKGEN_MISCSYS_SDIO1_CLK] = thead_gate_clk_register("clkgen_sdio1_clk", "osc_24m",
-								miscsys_regmap, 0x110, 0, GATE_NOT_SHARED, NULL, dev);
-	if (tee_miscsys_regmap) {
-		gates[CLKGEN_MISCSYS_AHB2_TEESYS_HCLK] = thead_gate_clk_register("clkgen_ahb2_teesys_hclk", NULL,
-								tee_miscsys_regmap, 0x120, 0, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_APB3_TEESYS_HCLK] = thead_gate_clk_register("clkgen_apb3_teesys_hclk", NULL,
-								tee_miscsys_regmap, 0x120, 1, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_AXI4_TEESYS_ACLK] = thead_gate_clk_register("clkgen_axi4_teesys_aclk", NULL,
-								tee_miscsys_regmap, 0x120, 2, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_EIP120SI_CLK] = thead_gate_clk_register("clkgen_eip120si_clk", NULL,
-								tee_miscsys_regmap, 0x120, 3, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_EIP120SII_CLK] = thead_gate_clk_register("clkgen_eip120sii_clk", NULL,
-								tee_miscsys_regmap, 0x120, 4, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_EIP120SIII_CLK] = thead_gate_clk_register("clkgen_eip120siii_clk", NULL,
-								tee_miscsys_regmap, 0x120, 5, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_TEEDMAC_CLK] = thead_gate_clk_register("clkgen_teedmac_clk", NULL,
-								tee_miscsys_regmap, 0x120, 6, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_EIP150B_HCLK] = thead_gate_clk_register("clkgen_eip150b_hclk", NULL,
-								tee_miscsys_regmap, 0x120, 7, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_OCRAM_HCLK] = thead_gate_clk_register("clkgen_ocram_hclk", NULL,
-								tee_miscsys_regmap, 0x120, 8, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_EFUSE_PCLK] = thead_gate_clk_register("clkgen_efuse_pclk", NULL,
-								tee_miscsys_regmap, 0x120, 9, GATE_NOT_SHARED, NULL, dev);
-		gates[CLKGEN_MISCSYS_TEE_SYSREG_PCLK] = thead_gate_clk_register("clkgen_tee_sysreg_pclk", NULL,
-								tee_miscsys_regmap, 0x120, 10, GATE_NOT_SHARED, NULL, dev);
-	}
-	clk_gate_data.clks = gates;
-	clk_gate_data.clk_num = ARRAY_SIZE(gates);
-	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
-	if (ret < 0) {
-		dev_err(dev, "failed to register gate clks for th1520 miscsys\n");
-		goto unregister_clks;
-	}
-	dev_info(dev, "succeed to register miscsys gate clock provider\n");
-	return 0;
-unregister_clks:
-	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
-	return ret;
-}
-static const struct of_device_id miscsys_clk_gate_of_match[] = {
-	{ .compatible = "thead,miscsys-gate-controller" },
-	{ /* sentinel */ },
-};
-MODULE_DEVICE_TABLE(of, miscsys_clk_gate_of_match);
-static struct platform_driver thead_miscsys_clk_driver = {
-	.probe = thead_miscsys_clk_probe,
-	.driver = {
-		.name = "miscsys-clk-gate-provider",
-		.owner = THIS_MODULE,
-		.of_match_table = of_match_ptr(miscsys_clk_gate_of_match),
-	},
-};
-module_platform_driver(thead_miscsys_clk_driver);
-MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
-MODULE_AUTHOR("Esther.Z <Esther.Z@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead th1520 Fullmask miscsys clock gate provider");
-MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/clk/xuantie/gate/miscsys-gate.c
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+#include <dt-bindings/clock/th1520-miscsys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "clk-gate.h"
+#include "../clk.h"
+static struct clk *gates[CLKGEN_MISCSYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+static int xuantie_miscsys_clk_probe(struct platform_device *pdev)
+{
+	struct regmap *miscsys_regmap, *tee_miscsys_regmap = NULL;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	miscsys_regmap = syscon_regmap_lookup_by_phandle(np, "miscsys-regmap");
+	if (IS_ERR(miscsys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for misc system register\n");
+		return PTR_ERR(miscsys_regmap);
+	}
+	tee_miscsys_regmap = syscon_regmap_lookup_by_phandle(np, "tee-miscsys-regmap");
+	if (IS_ERR(tee_miscsys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for tee misc system register\n");
+		return PTR_ERR(tee_miscsys_regmap);
+	}
+	/* we assume that the gate clock is a root clock  */
+	gates[CLKGEN_MISCSYS_MISCSYS_ACLK] = xuantie_gate_clk_register("clkgen_missys_aclk", NULL,
+								miscsys_regmap, 0x100, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_USB3_DRD_CLK] = xuantie_gate_clk_register("clkgen_usb3_drd_clk", NULL,
+								miscsys_regmap, 0x104, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_USB3_DRD_CTRL_REF_CLK] = xuantie_gate_clk_register("clkgen_usb3_drd_ctrl_ref_clk", "osc_24m",
+								miscsys_regmap, 0x104, 1, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_USB3_DRD_PHY_REF_CLK] = xuantie_gate_clk_register("clkgen_usb3_drd_phy_ref_clk", "osc_24m",
+								miscsys_regmap, 0x104, 2, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_USB3_DRD_SUSPEND_CLK] = xuantie_gate_clk_register("clkgen_usb3_drd_suspend_clk", NULL,
+								miscsys_regmap, 0x104, 3, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_EMMC_CLK] = xuantie_gate_clk_register("clkgen_emmc_clk", "osc_24m",
+								miscsys_regmap, 0x108, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_SDIO0_CLK] = xuantie_gate_clk_register("clkgen_sdio0_clk", "osc_24m",
+								miscsys_regmap, 0x10c, 0, GATE_NOT_SHARED, NULL, dev);
+	gates[CLKGEN_MISCSYS_SDIO1_CLK] = xuantie_gate_clk_register("clkgen_sdio1_clk", "osc_24m",
+								miscsys_regmap, 0x110, 0, GATE_NOT_SHARED, NULL, dev);
+	if (tee_miscsys_regmap) {
+		gates[CLKGEN_MISCSYS_AHB2_TEESYS_HCLK] = xuantie_gate_clk_register("clkgen_ahb2_teesys_hclk", NULL,
+								tee_miscsys_regmap, 0x120, 0, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_APB3_TEESYS_HCLK] = xuantie_gate_clk_register("clkgen_apb3_teesys_hclk", NULL,
+								tee_miscsys_regmap, 0x120, 1, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_AXI4_TEESYS_ACLK] = xuantie_gate_clk_register("clkgen_axi4_teesys_aclk", NULL,
+								tee_miscsys_regmap, 0x120, 2, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EIP120SI_CLK] = xuantie_gate_clk_register("clkgen_eip120si_clk", NULL,
+								tee_miscsys_regmap, 0x120, 3, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EIP120SII_CLK] = xuantie_gate_clk_register("clkgen_eip120sii_clk", NULL,
+								tee_miscsys_regmap, 0x120, 4, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EIP120SIII_CLK] = xuantie_gate_clk_register("clkgen_eip120siii_clk", NULL,
+								tee_miscsys_regmap, 0x120, 5, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_TEEDMAC_CLK] = xuantie_gate_clk_register("clkgen_teedmac_clk", NULL,
+								tee_miscsys_regmap, 0x120, 6, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EIP150B_HCLK] = xuantie_gate_clk_register("clkgen_eip150b_hclk", NULL,
+								tee_miscsys_regmap, 0x120, 7, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_OCRAM_HCLK] = xuantie_gate_clk_register("clkgen_ocram_hclk", NULL,
+								tee_miscsys_regmap, 0x120, 8, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_EFUSE_PCLK] = xuantie_gate_clk_register("clkgen_efuse_pclk", NULL,
+								tee_miscsys_regmap, 0x120, 9, GATE_NOT_SHARED, NULL, dev);
+		gates[CLKGEN_MISCSYS_TEE_SYSREG_PCLK] = xuantie_gate_clk_register("clkgen_tee_sysreg_pclk", NULL,
+								tee_miscsys_regmap, 0x120, 10, GATE_NOT_SHARED, NULL, dev);
+	}
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 miscsys\n");
+		goto unregister_clks;
+	}
+	dev_info(dev, "succeed to register miscsys gate clock provider\n");
+	return 0;
+unregister_clks:
+	xuantie_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+static const struct of_device_id miscsys_clk_gate_of_match[] = {
+	{ .compatible = "xuantie,miscsys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, miscsys_clk_gate_of_match);
+static struct platform_driver xuantie_miscsys_clk_driver = {
+	.probe = xuantie_miscsys_clk_probe,
+	.driver = {
+		.name = "miscsys-clk-gate-provider",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(miscsys_clk_gate_of_match),
+	},
+};
+module_platform_driver(xuantie_miscsys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_AUTHOR("Esther.Z <Esther.Z@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie th1520 Fullmask miscsys clock gate provider");
+MODULE_LICENSE("GPL v2");
--- a/drivers/clk/thead/gate/visys-gate.c
+++ /dev/null
@@ -1,144 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-
-#include <dt-bindings/clock/th1520-fm-ap-clock.h>
-#include <dt-bindings/clock/th1520-visys.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include "clk-gate.h"
-#include "../clk.h"
-
-static struct clk *gates[TH1520_CLKGEN_VISYS_CLK_END];
-static struct clk_onecell_data clk_gate_data;
-
-static u32 share_cnt_isp0_hclk_en;
-static u32 share_cnt_isp0_aclk_en;
-
-static int thead_visys_clk_probe(struct platform_device *pdev)
-{
-	struct regmap *visys_regmap;
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	int ret;
-
-	visys_regmap = syscon_regmap_lookup_by_phandle(np, "visys-regmap");
-	if (IS_ERR(visys_regmap)) {
-		dev_err(&pdev->dev, "cannot find regmap for vi system register\n");
-		return PTR_ERR(visys_regmap);
-	}
-
-	/* we assume that the gate clock is a root clock  */
-	gates[TH1520_CLKGEN_DW200_ACLK] = thead_gate_clk_register("clkgen_dw200_aclk", NULL,
-									visys_regmap, 0xa0, 27, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AXI4_VISYS1_ACLK] = thead_gate_clk_register("clkgen_axi4_visys1_aclk", NULL,
-									visys_regmap, 0xa0, 26, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AXI4_VISYS2_ACLK] = thead_gate_clk_register("clkgen_axi4_visys2_aclk", NULL,
-									visys_regmap, 0xa0, 25, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_AXI4_VISYS3_ACLK] = thead_gate_clk_register("clkgen_axi4_visys3_aclk", NULL,
-									visys_regmap, 0xa0, 24, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP_RY_ACLK] = thead_gate_clk_register("clkgen_isp_ry_aclk", NULL,
-									visys_regmap, 0xa0, 22, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP_VENC_SHAKE_ACLK] = thead_gate_clk_register("clkgen_isp_venc_shake_aclk", NULL,
-									visys_regmap, 0xa0, 30, GATE_NOT_SHARED, NULL, dev);
-
-	gates[TH1520_CLKGEN_VIPRE_ACLK] = thead_gate_clk_register("clkgen_vipre_aclk", NULL,
-									visys_regmap, 0xa0, 31, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_DW200_HCLK] = thead_gate_clk_register("clkgen_dw200_hclk", NULL,
-									visys_regmap, 0xa0, 13, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP_RY_HCLK] = thead_gate_clk_register("clkgen_isp_ry_hclk", NULL,
-									visys_regmap, 0xa0, 12, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_MIPI_CSI0_PCLK] = thead_gate_clk_register("clkgen_mipi_csi0_pclk", NULL,
-									visys_regmap, 0xa0, 18, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_MIPI_CSI1_PCLK] = thead_gate_clk_register("clkgen_mipi_csi1_pclk", NULL,
-									visys_regmap, 0xa0, 17, GATE_NOT_SHARED, NULL, dev);
-
-	gates[TH1520_CLKGEN_MIPI_CSI2_PCLK] = thead_gate_clk_register("clkgen_mipi_csi2_pclk", NULL,
-									visys_regmap, 0xa0, 16, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_VIPRE_PCLK] = thead_gate_clk_register("clkgen_vipre_pclk", NULL,
-									visys_regmap, 0xa0, 15, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP_VENC_SHAKE_PCLK] = thead_gate_clk_register("clkgen_isp_venc_shake_pclk", NULL,
-									visys_regmap, 0xa0, 29, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_MIPI_CSI0_PIXCLK] = thead_gate_clk_register("clkgen_mipi_csi0_pixclk", NULL,
-									visys_regmap, 0xa0, 11, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_MIPI_CSI1_PIXCLK] = thead_gate_clk_register("clkgen_mipi_csi1_pixclk", NULL,
-									visys_regmap, 0xa0, 10, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_MIPI_CSI2_PIXCLK] = thead_gate_clk_register("clkgen_mipi_csi2_pixclk", NULL,
-									visys_regmap, 0xa0, 9, GATE_NOT_SHARED, NULL, dev);
-
-	gates[TH1520_CLKGEN_VIPRE_PIXELCLK] = thead_gate_clk_register("clkgen_vipre_pixelclk", NULL,
-									visys_regmap, 0xa4, 23, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_MIPI_CSI0_CFG_CLK] = thead_gate_clk_register("clkgen_mipi_csi0_cfg_clk", NULL,
-									visys_regmap, 0xa0, 8, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_MIPI_CSI1_CFG_CLK] = thead_gate_clk_register("clkgen_mipi_csi1_cfg_clk", NULL,
-									visys_regmap, 0xa0, 6, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_MIPI_CSI2_CFG_CLK] = thead_gate_clk_register("clkgen_mipi_csi2_cfg_clk", NULL,
-									visys_regmap, 0xa0, 7, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_DW200_CLK_VSE] = thead_gate_clk_register("clkgen_dw200_clk_vse", NULL,
-									visys_regmap, 0xa0, 5, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_DW200_CLK_DWE] = thead_gate_clk_register("clkgen_dw200_clk_dwe", NULL,
-									visys_regmap, 0xa0, 4, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP0_CLK] = thead_gate_clk_register("clkgen_isp_clk_0", NULL,
-									visys_regmap, 0xa4, 31, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP1_CLK] = thead_gate_clk_register("clkgen_isp_clk_1", NULL,
-									visys_regmap, 0xa4, 30, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP_RY_CCLK] = thead_gate_clk_register("clkgen_isp_ry_cclk", NULL,
-									visys_regmap, 0xa0, 21, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP1_PIXELCLK] = thead_gate_clk_register("clkgen_isp1_pixelclk", NULL,
-									visys_regmap, 0xa4, 28, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP0_PIXELCLK] = thead_gate_clk_register("clkgen_isp0_pixelclk", NULL,
-									visys_regmap, 0xa4, 29, GATE_NOT_SHARED, NULL, dev);
-	gates[TH1520_CLKGEN_ISP1_HCLK] = thead_gate_clk_register("clkgen_isp1_hclk", NULL,
-									visys_regmap, 0xa0, 1, GATE_SHARED, &share_cnt_isp0_hclk_en, dev);
-	gates[TH1520_CLKGEN_ISP0_HCLK] = thead_gate_clk_register("clkgen_isp0_hclk", NULL,
-									visys_regmap, 0xa0, 1, GATE_SHARED, &share_cnt_isp0_hclk_en, dev);
-	gates[TH1520_CLKGEN_ISP1_ACLK] = thead_gate_clk_register("clkgen_isp1_aclk", NULL,
-									visys_regmap, 0xa0, 3, GATE_SHARED, &share_cnt_isp0_aclk_en, dev);
-	gates[TH1520_CLKGEN_ISP0_ACLK] = thead_gate_clk_register("clkgen_isp0_aclk", NULL,
-									visys_regmap, 0xa0, 3, GATE_SHARED, &share_cnt_isp0_aclk_en, dev);
-
-	clk_gate_data.clks = gates;
-	clk_gate_data.clk_num = ARRAY_SIZE(gates);
-
-	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
-	if (ret < 0) {
-		dev_err(dev, "failed to register gate clks for th1520 visys\n");
-		goto unregister_clks;
-	}
-
-	dev_info(dev, "succeed to register visys gate clock provider\n");
-
-	return 0;
-
-unregister_clks:
-	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
-	return ret;
-}
-
-static const struct of_device_id visys_clk_gate_of_match[] = {
-	{ .compatible = "thead,visys-gate-controller" },
-	{ /* sentinel */ },
-};
-MODULE_DEVICE_TABLE(of, visys_clk_gate_of_match);
-
-static struct platform_driver thead_visys_clk_driver = {
-	.probe = thead_visys_clk_probe,
-	.driver = {
-		.name = "visys-clk-gate-provider",
-		.of_match_table = of_match_ptr(visys_clk_gate_of_match),
-	},
-};
-
-module_platform_driver(thead_visys_clk_driver);
-MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead Th1520 Fullmask visys clock gate provider");
-MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/clk/xuantie/gate/visys-gate.c
@@ -0,0 +1,144 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <dt-bindings/clock/th1520-visys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "clk-gate.h"
+#include "../clk.h"
+
+static struct clk *gates[TH1520_CLKGEN_VISYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+
+static u32 share_cnt_isp0_hclk_en;
+static u32 share_cnt_isp0_aclk_en;
+
+static int xuantie_visys_clk_probe(struct platform_device *pdev)
+{
+	struct regmap *visys_regmap;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	visys_regmap = syscon_regmap_lookup_by_phandle(np, "visys-regmap");
+	if (IS_ERR(visys_regmap)) {
+		dev_err(&pdev->dev, "cannot find regmap for vi system register\n");
+		return PTR_ERR(visys_regmap);
+	}
+
+	/* we assume that the gate clock is a root clock  */
+	gates[TH1520_CLKGEN_DW200_ACLK] = xuantie_gate_clk_register("clkgen_dw200_aclk", NULL,
+									visys_regmap, 0xa0, 27, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AXI4_VISYS1_ACLK] = xuantie_gate_clk_register("clkgen_axi4_visys1_aclk", NULL,
+									visys_regmap, 0xa0, 26, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AXI4_VISYS2_ACLK] = xuantie_gate_clk_register("clkgen_axi4_visys2_aclk", NULL,
+									visys_regmap, 0xa0, 25, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_AXI4_VISYS3_ACLK] = xuantie_gate_clk_register("clkgen_axi4_visys3_aclk", NULL,
+									visys_regmap, 0xa0, 24, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_RY_ACLK] = xuantie_gate_clk_register("clkgen_isp_ry_aclk", NULL,
+									visys_regmap, 0xa0, 22, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_VENC_SHAKE_ACLK] = xuantie_gate_clk_register("clkgen_isp_venc_shake_aclk", NULL,
+									visys_regmap, 0xa0, 30, GATE_NOT_SHARED, NULL, dev);
+
+	gates[TH1520_CLKGEN_VIPRE_ACLK] = xuantie_gate_clk_register("clkgen_vipre_aclk", NULL,
+									visys_regmap, 0xa0, 31, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_DW200_HCLK] = xuantie_gate_clk_register("clkgen_dw200_hclk", NULL,
+									visys_regmap, 0xa0, 13, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_RY_HCLK] = xuantie_gate_clk_register("clkgen_isp_ry_hclk", NULL,
+									visys_regmap, 0xa0, 12, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI0_PCLK] = xuantie_gate_clk_register("clkgen_mipi_csi0_pclk", NULL,
+									visys_regmap, 0xa0, 18, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI1_PCLK] = xuantie_gate_clk_register("clkgen_mipi_csi1_pclk", NULL,
+									visys_regmap, 0xa0, 17, GATE_NOT_SHARED, NULL, dev);
+
+	gates[TH1520_CLKGEN_MIPI_CSI2_PCLK] = xuantie_gate_clk_register("clkgen_mipi_csi2_pclk", NULL,
+									visys_regmap, 0xa0, 16, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_VIPRE_PCLK] = xuantie_gate_clk_register("clkgen_vipre_pclk", NULL,
+									visys_regmap, 0xa0, 15, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_VENC_SHAKE_PCLK] = xuantie_gate_clk_register("clkgen_isp_venc_shake_pclk", NULL,
+									visys_regmap, 0xa0, 29, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI0_PIXCLK] = xuantie_gate_clk_register("clkgen_mipi_csi0_pixclk", NULL,
+									visys_regmap, 0xa0, 11, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI1_PIXCLK] = xuantie_gate_clk_register("clkgen_mipi_csi1_pixclk", NULL,
+									visys_regmap, 0xa0, 10, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI2_PIXCLK] = xuantie_gate_clk_register("clkgen_mipi_csi2_pixclk", NULL,
+									visys_regmap, 0xa0, 9, GATE_NOT_SHARED, NULL, dev);
+
+	gates[TH1520_CLKGEN_VIPRE_PIXELCLK] = xuantie_gate_clk_register("clkgen_vipre_pixelclk", NULL,
+									visys_regmap, 0xa4, 23, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI0_CFG_CLK] = xuantie_gate_clk_register("clkgen_mipi_csi0_cfg_clk", NULL,
+									visys_regmap, 0xa0, 8, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI1_CFG_CLK] = xuantie_gate_clk_register("clkgen_mipi_csi1_cfg_clk", NULL,
+									visys_regmap, 0xa0, 6, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_MIPI_CSI2_CFG_CLK] = xuantie_gate_clk_register("clkgen_mipi_csi2_cfg_clk", NULL,
+									visys_regmap, 0xa0, 7, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_DW200_CLK_VSE] = xuantie_gate_clk_register("clkgen_dw200_clk_vse", NULL,
+									visys_regmap, 0xa0, 5, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_DW200_CLK_DWE] = xuantie_gate_clk_register("clkgen_dw200_clk_dwe", NULL,
+									visys_regmap, 0xa0, 4, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP0_CLK] = xuantie_gate_clk_register("clkgen_isp_clk_0", NULL,
+									visys_regmap, 0xa4, 31, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP1_CLK] = xuantie_gate_clk_register("clkgen_isp_clk_1", NULL,
+									visys_regmap, 0xa4, 30, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP_RY_CCLK] = xuantie_gate_clk_register("clkgen_isp_ry_cclk", NULL,
+									visys_regmap, 0xa0, 21, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP1_PIXELCLK] = xuantie_gate_clk_register("clkgen_isp1_pixelclk", NULL,
+									visys_regmap, 0xa4, 28, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP0_PIXELCLK] = xuantie_gate_clk_register("clkgen_isp0_pixelclk", NULL,
+									visys_regmap, 0xa4, 29, GATE_NOT_SHARED, NULL, dev);
+	gates[TH1520_CLKGEN_ISP1_HCLK] = xuantie_gate_clk_register("clkgen_isp1_hclk", NULL,
+									visys_regmap, 0xa0, 1, GATE_SHARED, &share_cnt_isp0_hclk_en, dev);
+	gates[TH1520_CLKGEN_ISP0_HCLK] = xuantie_gate_clk_register("clkgen_isp0_hclk", NULL,
+									visys_regmap, 0xa0, 1, GATE_SHARED, &share_cnt_isp0_hclk_en, dev);
+	gates[TH1520_CLKGEN_ISP1_ACLK] = xuantie_gate_clk_register("clkgen_isp1_aclk", NULL,
+									visys_regmap, 0xa0, 3, GATE_SHARED, &share_cnt_isp0_aclk_en, dev);
+	gates[TH1520_CLKGEN_ISP0_ACLK] = xuantie_gate_clk_register("clkgen_isp0_aclk", NULL,
+									visys_regmap, 0xa0, 3, GATE_SHARED, &share_cnt_isp0_aclk_en, dev);
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 visys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register visys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	xuantie_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id visys_clk_gate_of_match[] = {
+	{ .compatible = "xuantie,visys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, visys_clk_gate_of_match);
+
+static struct platform_driver xuantie_visys_clk_driver = {
+	.probe = xuantie_visys_clk_probe,
+	.driver = {
+		.name = "visys-clk-gate-provider",
+		.of_match_table = of_match_ptr(visys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(xuantie_visys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie Th1520 Fullmask visys clock gate provider");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/clk/xuantie/gate/vosys-gate.c
@@ -0,0 +1,111 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <dt-bindings/clock/th1520-vosys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "../clk.h"
+
+static struct clk *gates[TH1520_CLKGEN_VOSYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+
+static int xuantie_vosys_clk_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	void __iomem *gate_base;
+	int ret;
+
+	gate_base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(gate_base)))
+		return PTR_ERR(gate_base);
+
+	/* we assume that the gate clock is a root clock  */
+	gates[TH1520_CLKGEN_AXI4_VO_PCLK] = xuantie_clk_th1520_gate("clkgen_axi4_vo_pclk", NULL,
+								gate_base + 0x50, 22);
+	gates[TH1520_CLKGEN_IOPMP_VOSYS_DPU_PCLK] = xuantie_clk_th1520_gate("clkgen_iopmp_dpu_pclk", NULL,
+								gate_base + 0x50, 23);
+	gates[TH1520_CLKGEN_IOPMP_VOSYS_DPU1_PCLK] = xuantie_clk_th1520_gate("clkgen_iopmp_dpu1_pclk", NULL,
+								gate_base + 0x50, 24);
+	gates[TH1520_CLKGEN_IOPMP_VOSYS_GPU_PCLK] = xuantie_clk_th1520_gate("clkgen_iopmp_gpu_pclk", NULL,
+								gate_base + 0x50, 25);
+	gates[TH1520_CLKGEN_HDMI_PCLK] = xuantie_clk_th1520_gate("clkgen_hdmi_pclk", NULL, gate_base + 0x50, 11);
+	gates[TH1520_CLKGEN_MIPIDSI0_PCLK] = xuantie_clk_th1520_gate("clkgen_mipidsi0_pclk", NULL,
+								  gate_base + 0x50, 13);
+	gates[TH1520_CLKGEN_MIPIDSI1_PCLK] = xuantie_clk_th1520_gate("clkgen_mipidsi1_pclk", NULL,
+								  gate_base + 0x50, 14);
+	gates[TH1520_CLKGEN_AXI4_VO_ACLK] = xuantie_clk_th1520_gate("clkgen_axi4_vo_aclk", NULL,
+								  gate_base + 0x50, 0);
+	gates[TH1520_CLKGEN_IOPMP_GPU_ACLK] = xuantie_clk_th1520_gate("clkgen_iopmp_gpu_aclk", NULL,
+								  gate_base + 0x50, 29);
+	gates[TH1520_CLKGEN_IOPMP_DPU_ACLK] = xuantie_clk_th1520_gate("clkgen_iopmp_dpu_aclk", NULL,
+								  gate_base + 0x50, 28);
+	gates[TH1520_CLKGEN_IOPMP_DPU1_ACLK] = xuantie_clk_th1520_gate("clkgen_iopmp_dpu1_aclk", NULL,
+								  gate_base + 0x50, 27);
+	gates[TH1520_CLKGEN_X2H_DPU_ACLK] = xuantie_clk_th1520_gate("clkgen_x2h_dpu_aclk", NULL, gate_base + 0x50, 21);
+	gates[TH1520_CLKGEN_X2H_DPU1_ACLK] = xuantie_clk_th1520_gate("clkgen_x2h_dpu1_aclk", NULL, gate_base + 0x50, 20);
+	gates[TH1520_CLKGEN_MIPIDSI0_PIXCLK] = xuantie_clk_th1520_gate("clkgen_mipidsi0_pixclk", NULL, gate_base + 0x50, 30);
+	gates[TH1520_CLKGEN_HDMI_PIXCLK] = xuantie_clk_th1520_gate("clkgen_hdmi_pixclk", NULL, gate_base + 0x54, 0);
+	gates[TH1520_CLKGEN_MIPIDSI1_PIXCLK] = xuantie_clk_th1520_gate("clkgen_mipidsi1_pixclk", NULL, gate_base + 0x50, 31);
+	gates[TH1520_CLKGEN_HDMI_SFR_CLK] = xuantie_clk_th1520_gate("clkgen_hdmi_sfr_clk", NULL, gate_base + 0x50, 10);
+	gates[TH1520_CLKGEN_HDMI_CEC_CLK] = xuantie_clk_th1520_gate("clkgen_hdmi_cec_cclk", NULL, gate_base + 0x50, 12);
+	gates[TH1520_CLKGEN_HDMI_I2S_CLK] = xuantie_clk_th1520_gate("clkgen_hdmi_i2s_clk", NULL, gate_base + 0x50, 19);
+	gates[TH1520_CLKGEN_MIPIDSI0_CFG_CLK] = xuantie_clk_th1520_gate("clkgen_mipidsi0_cfg_clk", NULL, gate_base + 0x50, 15);
+	gates[TH1520_CLKGEN_MIPIDSI1_CFG_CLK] = xuantie_clk_th1520_gate("clkgen_mipidsi1_cfg_clk", NULL, gate_base + 0x50, 16);
+	gates[TH1520_CLKGEN_MIPIDSI0_REFCLK] = xuantie_clk_th1520_gate("clkgen_mipidsi0_refclk", NULL, gate_base + 0x50, 17);
+	gates[TH1520_CLKGEN_MIPIDSI1_REFCLK] = xuantie_clk_th1520_gate("clkgen_mipidsi1_refclk", NULL, gate_base + 0x50, 18);
+	gates[TH1520_CLKGEN_GPU_CORE_CLK] = xuantie_clk_th1520_gate("clkgen_gpu_core_clk", "vosys_aclk_m", gate_base + 0x50, 3);
+	gates[TH1520_CLKGEN_GPU_CFG_ACLK] = xuantie_clk_th1520_gate("clkgen_gpu_cfg_aclk", NULL, gate_base + 0x50, 4);
+	gates[TH1520_CLKGEN_DPU_HCLK] = xuantie_clk_th1520_gate("clkgen_dpu_hclk", NULL, gate_base + 0x50, 7);
+	gates[TH1520_CLKGEN_DPU_ACLK] = xuantie_clk_th1520_gate("clkgen_dpu_aclk", NULL, gate_base + 0x50, 8);
+	gates[TH1520_CLKGEN_DPU_CCLK] = xuantie_clk_th1520_gate("clkgen_dpu_cclk", NULL, gate_base + 0x50, 9);
+	gates[TH1520_CLKGEN_DPU_PIXCLK0] = xuantie_clk_th1520_gate("clkgen_dpu_pixclk0", NULL, gate_base + 0x50, 5);
+	gates[TH1520_CLKGEN_DPU_PIXCLK1] = xuantie_clk_th1520_gate("clkgen_dpu_pixclk1", NULL, gate_base + 0x50, 6);
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 vosys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register vosys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	xuantie_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id vosys_clk_gate_of_match[] = {
+	{ .compatible = "xuantie,vosys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, vosys_clk_gate_of_match);
+
+static struct platform_driver xuantie_vosys_clk_driver = {
+	.probe = xuantie_vosys_clk_probe,
+	.driver = {
+		.name = "vosys-clk-gate-provider",
+		.of_match_table = of_match_ptr(vosys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(xuantie_vosys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie Th1520 Fullmask vosys clock gate provider");
+MODULE_LICENSE("GPL");
--- a/drivers/clk/thead/gate/vpsys-gate.c
+++ /dev/null
@@ -1,99 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-
-#include <dt-bindings/clock/th1520-fm-ap-clock.h>
-#include <dt-bindings/clock/th1520-vpsys.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include "../clk.h"
-
-static struct clk *gates[TH1520_VPSYS_CLK_END];
-static struct clk_onecell_data clk_gate_data;
-
-static u32 share_cnt_g2d_clk_en;
-static u32 share_cnt_fce_clk_en;
-
-static int thead_vpsys_clk_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	void __iomem *gate_base;
-	int ret;
-
-	gate_base = devm_platform_ioremap_resource(pdev, 0);
-	if (WARN_ON(IS_ERR(gate_base)))
-		return PTR_ERR(gate_base);
-
-	// DIV & CDE
-	gates[TH1520_VPSYS_G2D_CCLK_DIV] = thead_clk_th1520_divider("clkgen_vpsys_g2d_cclk_div", "video_pll_foutvco", gate_base + 0x30, 0, 4, 4, MUX_TYPE_DIV, 3, 15);
-	gates[TH1520_VPSYS_DEC_CCLK_DIV] = thead_clk_th1520_divider("clkgen_vpsys_dec_cclk_div", "video_pll_foutvco", gate_base + 0x24, 0, 4, 4, MUX_TYPE_DIV, 4, 15);
-
-	/* G2D clock configuration : Completed the upward configuration of CCLK */
-	gates[TH1520_VPSYS_G2D_PCLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_g2d_pclk", NULL,
-								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
-	gates[TH1520_VPSYS_G2D_ACLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_g2d_aclk", NULL,
-								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
-	gates[TH1520_VPSYS_G2D_CCLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_g2d_cclk", "clkgen_vpsys_g2d_cclk_div",
-								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
-
-	/* we assume that the gate clock is a root clock  */
-	gates[TH1520_VPSYS_FCE_PCLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_fce_pclk", NULL,
-								   gate_base + 0x20, 2, &share_cnt_fce_clk_en);
-	gates[TH1520_VPSYS_FCE_ACLK] = thead_clk_th1520_gate_shared("clkgen_vpsys_fce_aclk", NULL,
-								   gate_base + 0x20, 2, &share_cnt_fce_clk_en);
-
-	/* VENC&VDEC clock configuration : Completed the upward configuration of CCLK */
-	gates[TH1520_VPSYS_VDEC_ACLK] = thead_clk_th1520_gate("clkgen_vdec_aclk", NULL, gate_base + 0x20, 4);
-	gates[TH1520_VPSYS_VDEC_CCLK] = thead_clk_th1520_gate("clkgen_vdec_cclk", "clkgen_vpsys_dec_cclk_div", gate_base + 0x20, 5);
-	gates[TH1520_VPSYS_VDEC_PCLK] = thead_clk_th1520_gate("clkgen_vdec_pclk", NULL, gate_base + 0x20, 6);
-
-	gates[TH1520_VPSYS_VENC_CCLK] = thead_clk_th1520_gate("clkgen_venc_cclk", "clkgen_vpsys_venc_cclk", gate_base + 0x20, 8);
-	gates[TH1520_VPSYS_VENC_PCLK] = thead_clk_th1520_gate("clkgen_venc_pclk", NULL, gate_base + 0x20, 9);
-	gates[TH1520_VPSYS_VENC_ACLK] = thead_clk_th1520_gate("clkgen_venc_aclk", NULL, gate_base + 0x20, 7);
-
-	clk_gate_data.clks = gates;
-	clk_gate_data.clk_num = ARRAY_SIZE(gates);
-
-	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
-	if (ret < 0) {
-		dev_err(dev, "failed to register gate clks for th1520 vpsys\n");
-		goto unregister_clks;
-	}
-
-	dev_info(dev, "succeed to register vpsys gate clock provider\n");
-
-	return 0;
-
-unregister_clks:
-	thead_unregister_clocks(gates, ARRAY_SIZE(gates));
-	return ret;
-}
-
-static const struct of_device_id vpsys_clk_gate_of_match[] = {
-	{ .compatible = "thead,vpsys-gate-controller" },
-	{ /* sentinel */ },
-};
-MODULE_DEVICE_TABLE(of, vpsys_clk_gate_of_match);
-
-static struct platform_driver thead_vpsys_clk_driver = {
-	.probe = thead_vpsys_clk_probe,
-	.driver = {
-		.name = "vpsys-clk-gate-provider",
-		.of_match_table = of_match_ptr(vpsys_clk_gate_of_match),
-	},
-};
-
-module_platform_driver(thead_vpsys_clk_driver);
-MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead Th1520 Fullmask vpsys clock gate provider");
-MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/clk/xuantie/gate/vpsys-gate.c
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/clock/th1520-fm-ap-clock.h>
+#include <dt-bindings/clock/th1520-vpsys.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include "../clk.h"
+
+static struct clk *gates[TH1520_VPSYS_CLK_END];
+static struct clk_onecell_data clk_gate_data;
+
+static u32 share_cnt_g2d_clk_en;
+static u32 share_cnt_fce_clk_en;
+
+static int xuantie_vpsys_clk_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	void __iomem *gate_base;
+	int ret;
+
+	gate_base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(gate_base)))
+		return PTR_ERR(gate_base);
+
+	// DIV & CDE
+	gates[TH1520_VPSYS_G2D_CCLK_DIV] = xuantie_clk_th1520_divider("clkgen_vpsys_g2d_cclk_div", "video_pll_foutvco", gate_base + 0x30, 0, 4, 4, MUX_TYPE_DIV, 3, 15);
+	gates[TH1520_VPSYS_DEC_CCLK_DIV] = xuantie_clk_th1520_divider("clkgen_vpsys_dec_cclk_div", "video_pll_foutvco", gate_base + 0x24, 0, 4, 4, MUX_TYPE_DIV, 4, 15);
+
+	/* G2D clock configuration : Completed the upward configuration of CCLK */
+	gates[TH1520_VPSYS_G2D_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_vpsys_g2d_pclk", NULL,
+								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
+	gates[TH1520_VPSYS_G2D_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_vpsys_g2d_aclk", NULL,
+								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
+	gates[TH1520_VPSYS_G2D_CCLK] = xuantie_clk_th1520_gate_shared("clkgen_vpsys_g2d_cclk", "clkgen_vpsys_g2d_cclk_div",
+								   gate_base + 0x20, 3, &share_cnt_g2d_clk_en);
+
+	/* we assume that the gate clock is a root clock  */
+	gates[TH1520_VPSYS_FCE_PCLK] = xuantie_clk_th1520_gate_shared("clkgen_vpsys_fce_pclk", NULL,
+								   gate_base + 0x20, 2, &share_cnt_fce_clk_en);
+	gates[TH1520_VPSYS_FCE_ACLK] = xuantie_clk_th1520_gate_shared("clkgen_vpsys_fce_aclk", NULL,
+								   gate_base + 0x20, 2, &share_cnt_fce_clk_en);
+
+	/* VENC&VDEC clock configuration : Completed the upward configuration of CCLK */
+	gates[TH1520_VPSYS_VDEC_ACLK] = xuantie_clk_th1520_gate("clkgen_vdec_aclk", NULL, gate_base + 0x20, 4);
+	gates[TH1520_VPSYS_VDEC_CCLK] = xuantie_clk_th1520_gate("clkgen_vdec_cclk", "clkgen_vpsys_dec_cclk_div", gate_base + 0x20, 5);
+	gates[TH1520_VPSYS_VDEC_PCLK] = xuantie_clk_th1520_gate("clkgen_vdec_pclk", NULL, gate_base + 0x20, 6);
+
+	gates[TH1520_VPSYS_VENC_CCLK] = xuantie_clk_th1520_gate("clkgen_venc_cclk", "clkgen_vpsys_venc_cclk", gate_base + 0x20, 8);
+	gates[TH1520_VPSYS_VENC_PCLK] = xuantie_clk_th1520_gate("clkgen_venc_pclk", NULL, gate_base + 0x20, 9);
+	gates[TH1520_VPSYS_VENC_ACLK] = xuantie_clk_th1520_gate("clkgen_venc_aclk", NULL, gate_base + 0x20, 7);
+
+	clk_gate_data.clks = gates;
+	clk_gate_data.clk_num = ARRAY_SIZE(gates);
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get, &clk_gate_data);
+	if (ret < 0) {
+		dev_err(dev, "failed to register gate clks for th1520 vpsys\n");
+		goto unregister_clks;
+	}
+
+	dev_info(dev, "succeed to register vpsys gate clock provider\n");
+
+	return 0;
+
+unregister_clks:
+	xuantie_unregister_clocks(gates, ARRAY_SIZE(gates));
+	return ret;
+}
+
+static const struct of_device_id vpsys_clk_gate_of_match[] = {
+	{ .compatible = "xuantie,vpsys-gate-controller" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, vpsys_clk_gate_of_match);
+
+static struct platform_driver xuantie_vpsys_clk_driver = {
+	.probe = xuantie_vpsys_clk_probe,
+	.driver = {
+		.name = "vpsys-clk-gate-provider",
+		.of_match_table = of_match_ptr(vpsys_clk_gate_of_match),
+	},
+};
+
+module_platform_driver(xuantie_vpsys_clk_driver);
+MODULE_AUTHOR("wei.liu <lw312886@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie Th1520 Fullmask vpsys clock gate provider");
+MODULE_LICENSE("GPL v2");
--- a/drivers/clk/thead/gate/thead-gate.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/regmap.h>
-#include "clk-gate.h"
-
-#define to_thead_clk_gate(_hw)	container_of(_hw, struct thead_clk_gate, hw)
-
-static int thead_clk_gate_is_enabled(struct clk_hw *hw)
-{
-	struct thead_clk_gate *tcg = to_thead_clk_gate(hw);
-	u32 val;
-
-	regmap_read(tcg->regmap, tcg->offset, &val);
-
-	val &= BIT(tcg->bit);
-
-	return val != 0;
-}
-
-static void thead_clk_gate_disable(struct clk_hw *hw)
-{
-	struct thead_clk_gate *tcg = to_thead_clk_gate(hw);
-
-	if (!tcg->shared)
-		goto out;
-
-	if (tcg->share_count) {
-		if (WARN_ON(*tcg->share_count == 0))
-			return;
-		else if (--(*tcg->share_count) > 0) {
-			pr_info("[%s,%d]share_count = %d\n", __func__, __LINE__,
-					(*tcg->share_count));
-			return;
-		}
-	}
-
-out:
-	regmap_update_bits(tcg->regmap, tcg->offset,
-			   BIT(tcg->bit), 0);
-}
-
-static int thead_clk_gate_enable(struct clk_hw *hw)
-{
-	struct thead_clk_gate *tcg = to_thead_clk_gate(hw);
-
-	if (!tcg->shared)
-		goto out;
-
-	if (tcg->share_count && (*tcg->share_count)++ > 0) {
-		pr_info("[%s,%d]share_count = %d\n", __func__, __LINE__, (*tcg->share_count));
-		return 0;
-	}
-
-out:
-	return regmap_update_bits(tcg->regmap, tcg->offset,
-				  BIT(tcg->bit), BIT(tcg->bit));
-}
-
-const struct clk_ops thead_gate_clk_ops = {
-	.enable = thead_clk_gate_enable,
-	.disable = thead_clk_gate_disable,
-	.is_enabled = thead_clk_gate_is_enabled,
-};
-
-struct clk *thead_gate_clk_register(const char *name,
-				    const char *parent_name,
-				    struct regmap *regmap,
-				    int offset,
-				    u8 bit,
-				    bool shared,
-				    u32 *share_count,
-				    struct device *dev)
-{
-	struct thead_clk_gate *tcg;
-	struct clk *clk;
-	struct clk_init_data init = {};
-
-	tcg = kzalloc(sizeof(*tcg), GFP_KERNEL);
-	if (!tcg)
-		return ERR_PTR(-ENOMEM);
-
-	tcg->regmap = regmap;
-	tcg->offset = offset;
-	tcg->bit = bit;
-	tcg->shared = shared;
-	tcg->share_count = share_count;
-
-	init.name = name;
-	init.flags = CLK_SET_RATE_PARENT;
-	init.parent_names = parent_name ? &parent_name : NULL;
-	init.num_parents = parent_name ? 1 : 0;
-	init.ops = &thead_gate_clk_ops;
-
-	tcg->hw.init = &init;
-
-	clk = clk_register(dev, &tcg->hw);
-	if (IS_ERR(clk))
-		kfree(tcg);
-
-	return clk;
-}
--- /dev/null
+++ b/drivers/clk/xuantie/gate/xuantie-gate.c
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include "clk-gate.h"
+
+#define to_xuantie_clk_gate(_hw)	container_of(_hw, struct xuantie_clk_gate, hw)
+
+static int xuantie_clk_gate_is_enabled(struct clk_hw *hw)
+{
+	struct xuantie_clk_gate *tcg = to_xuantie_clk_gate(hw);
+	u32 val;
+
+	regmap_read(tcg->regmap, tcg->offset, &val);
+
+	val &= BIT(tcg->bit);
+
+	return val != 0;
+}
+
+static void xuantie_clk_gate_disable(struct clk_hw *hw)
+{
+	struct xuantie_clk_gate *tcg = to_xuantie_clk_gate(hw);
+
+	if (!tcg->shared)
+		goto out;
+
+	if (tcg->share_count) {
+		if (WARN_ON(*tcg->share_count == 0))
+			return;
+		else if (--(*tcg->share_count) > 0) {
+			pr_info("[%s,%d]share_count = %d\n", __func__, __LINE__,
+					(*tcg->share_count));
+			return;
+		}
+	}
+
+out:
+	regmap_update_bits(tcg->regmap, tcg->offset,
+			   BIT(tcg->bit), 0);
+}
+
+static int xuantie_clk_gate_enable(struct clk_hw *hw)
+{
+	struct xuantie_clk_gate *tcg = to_xuantie_clk_gate(hw);
+
+	if (!tcg->shared)
+		goto out;
+
+	if (tcg->share_count && (*tcg->share_count)++ > 0) {
+		pr_info("[%s,%d]share_count = %d\n", __func__, __LINE__, (*tcg->share_count));
+		return 0;
+	}
+
+out:
+	return regmap_update_bits(tcg->regmap, tcg->offset,
+				  BIT(tcg->bit), BIT(tcg->bit));
+}
+
+const struct clk_ops xuantie_gate_clk_ops = {
+	.enable = xuantie_clk_gate_enable,
+	.disable = xuantie_clk_gate_disable,
+	.is_enabled = xuantie_clk_gate_is_enabled,
+};
+
+struct clk *xuantie_gate_clk_register(const char *name,
+				    const char *parent_name,
+				    struct regmap *regmap,
+				    int offset,
+				    u8 bit,
+				    bool shared,
+				    u32 *share_count,
+				    struct device *dev)
+{
+	struct xuantie_clk_gate *tcg;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	tcg = kzalloc(sizeof(*tcg), GFP_KERNEL);
+	if (!tcg)
+		return ERR_PTR(-ENOMEM);
+
+	tcg->regmap = regmap;
+	tcg->offset = offset;
+	tcg->bit = bit;
+	tcg->shared = shared;
+	tcg->share_count = share_count;
+
+	init.name = name;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+	init.ops = &xuantie_gate_clk_ops;
+
+	tcg->hw.init = &init;
+
+	clk = clk_register(dev, &tcg->hw);
+	if (IS_ERR(clk))
+		kfree(tcg);
+
+	return clk;
+}
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -315,7 +315,7 @@ config QORIQ_CPUFREQ
 config RISCV_XUANTIE_TH1520_CPUFREQ
 	tristate "CPU frequency scaling driver for XuanTie th1520 SoCs"
 	depends on OF && COMMON_CLK && TH1520_AON && REGULATOR_TH1520_AON
-	select THEAD_CLK
+	select XUANTIE_CLK
 	select PM_OPP
 	help
 	  This adds the CPUFreq driver support for XuanTie th1520 SoCs
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -314,6 +314,6 @@ source "drivers/firmware/psci/Kconfig"
 source "drivers/firmware/smccc/Kconfig"
 source "drivers/firmware/tegra/Kconfig"
 source "drivers/firmware/xilinx/Kconfig"
-source "drivers/firmware/thead/Kconfig"
+source "drivers/firmware/xuantie/Kconfig"
 
 endmenu
--- a/drivers/firmware/Makefile
+++ b/drivers/firmware/Makefile
@@ -38,4 +38,4 @@ obj-y				+= psci/
 obj-y				+= smccc/
 obj-y				+= tegra/
 obj-y				+= xilinx/
-obj-y				+= thead/
+obj-y				+= xuantie/
--- a/drivers/firmware/thead/Kconfig
+++ /dev/null
@@ -1,23 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-config TH1520_AON
-	bool "Thead TH1520 Aon Protocol driver"
-	depends on TH1520_MBOX
-	default y
-	help
-	  Thead TH1520 Aon is a low-level system function which runs a dedicated
-	  thead riscv E902 core to provide power, clock and resource management.
-
-	  This driver manages the IPC interface between host cpu liks thead
-	  and the Aon firmware running on thead riscv E902 core.
-
-config TH1520_AON_PD
-       bool "Thead TH1520 Aon Power Domain driver"
-       depends on TH1520_AON
-       help
-	The Xuantie TH1520 Aon based power domain virtual driver.
-	When selected, this option adds kernel support for dynamically
-	configuring power to various peripherals and functional block.
-
-        Note: Enabling this option requires the "Xuantie TH1520 Aon Support"
-	(`TH1520_AON`) to be selected first, as this driver is built upon
-	the foundational Aon infrastructure provided by that configuration.
--- /dev/null
+++ b/drivers/firmware/xuantie/Kconfig
@@ -0,0 +1,23 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config TH1520_AON
+	bool "XuanTie TH1520 Aon Protocol driver"
+	depends on TH1520_MBOX
+	default y
+	help
+	  XuanTie TH1520 Aon is a low-level system function which runs a dedicated
+	  XuanTie riscv E902 core to provide power, clock and resource management.
+
+	  This driver manages the IPC interface between host cpu likes xuantie
+	  and the Aon firmware running on xuantie riscv E902 core.
+
+config TH1520_AON_PD
+    bool "XuanTie TH1520 Aon Power Domain driver"
+    depends on TH1520_AON
+    help
+	  The Xuantie TH1520 Aon based power domain virtual driver.
+	  When selected, this option adds kernel support for dynamically
+	  configuring power to various peripherals and functional block.
+
+          Note: Enabling this option requires the "Xuantie TH1520 Aon Support"
+	  (`TH1520_AON`) to be selected first, as this driver is built upon
+	  the foundational Aon infrastructure provided by that configuration.
--- a/drivers/firmware/thead/th1520_aon.c
+++ /dev/null
@@ -1,341 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- */
-
-#include <linux/err.h>
-#include <linux/firmware/thead/ipc.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/mailbox_client.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/of_platform.h>
-#include <linux/of_address.h>
-#include <linux/of_device.h>
-#include <linux/platform_device.h>
-#include <linux/proc_fs.h>
-#include <linux/th1520_proc_debug.h>
-#include <linux/firmware/thead/ipc.h>
-
-/* wait for response for 3000ms instead of 300ms (fix me pls)*/
-#define MAX_RX_TIMEOUT (msecs_to_jiffies(3000))
-#define MAX_TX_TIMEOUT (msecs_to_jiffies(500))
-
-struct th1520_aon_chan {
-	struct th1520_aon_ipc *aon_ipc;
-
-	struct mbox_client cl;
-	struct mbox_chan *ch;
-	struct completion tx_done;
-	/*for log proc*/
-	phys_addr_t log_phy;
-	size_t log_size;
-	void __iomem *log_mem;
-	void *log_ctrl;
-	struct proc_dir_entry *proc_dir;
-};
-
-struct th1520_aon_ipc {
-	struct th1520_aon_chan chans;
-	struct device *dev;
-	struct mutex lock;
-	struct completion done;
-	u32 *msg;
-};
-
-/*
- * This type is used to indicate error response for most functions.
- */
-enum th1520_aon_error_codes {
-	TH1520_AON_ERR_NONE = 0, /* Success */
-	TH1520_AON_ERR_VERSION = 1, /* Incompatible API version */
-	TH1520_AON_ERR_CONFIG = 2, /* Configuration error */
-	TH1520_AON_ERR_PARM = 3, /* Bad parameter */
-	TH1520_AON_ERR_NOACCESS = 4, /* Permission error (no access) */
-	TH1520_AON_ERR_LOCKED = 5, /* Permission error (locked) */
-	TH1520_AON_ERR_UNAVAILABLE = 6, /* Unavailable (out of resources) */
-	TH1520_AON_ERR_NOTFOUND = 7, /* Not found */
-	TH1520_AON_ERR_NOPOWER = 8, /* No power */
-	TH1520_AON_ERR_IPC = 9, /* Generic IPC error */
-	TH1520_AON_ERR_BUSY = 10, /* Resource is currently busy/active */
-	TH1520_AON_ERR_FAIL = 11, /* General I/O failure */
-	TH1520_AON_ERR_LAST
-};
-
-static int th1520_aon_linux_errmap[TH1520_AON_ERR_LAST] = {
-	0, /* TH1520_AON_ERR_NONE */
-	-EINVAL, /* TH1520_AON_ERR_VERSION */
-	-EINVAL, /* TH1520_AON_ERR_CONFIG */
-	-EINVAL, /* TH1520_AON_ERR_PARM */
-	-EACCES, /* TH1520_AON_ERR_NOACCESS */
-	-EACCES, /* TH1520_AON_ERR_LOCKED */
-	-ERANGE, /* TH1520_AON_ERR_UNAVAILABLE */
-	-EEXIST, /* TH1520_AON_ERR_NOTFOUND */
-	-EPERM, /* TH1520_AON_ERR_NOPOWER */
-	-EPIPE, /* TH1520_AON_ERR_IPC */
-	-EBUSY, /* TH1520_AON_ERR_BUSY */
-	-EIO, /* TH1520_AON_ERR_FAIL */
-};
-
-static struct th1520_aon_ipc *th1520_aon_ipc_handle;
-
-static inline int th1520_aon_to_linux_errno(int errno)
-{
-	if (errno >= TH1520_AON_ERR_NONE && errno < TH1520_AON_ERR_LAST)
-		return th1520_aon_linux_errmap[errno];
-	return -EIO;
-}
-
-/*
- * Get the default handle used by SCU
- */
-int th1520_aon_get_handle(struct th1520_aon_ipc **ipc)
-{
-	if (!th1520_aon_ipc_handle)
-		return -EPROBE_DEFER;
-
-	*ipc = th1520_aon_ipc_handle;
-	return 0;
-}
-EXPORT_SYMBOL(th1520_aon_get_handle);
-
-static void th1520_aon_tx_done(struct mbox_client *cl, void *mssg, int r)
-{
-	struct th1520_aon_chan *aon_chan =
-		container_of(cl, struct th1520_aon_chan, cl);
-
-	complete(&aon_chan->tx_done);
-}
-
-static void th1520_aon_rx_callback(struct mbox_client *c, void *msg)
-{
-	struct th1520_aon_chan *aon_chan =
-		container_of(c, struct th1520_aon_chan, cl);
-	struct th1520_aon_ipc *aon_ipc = aon_chan->aon_ipc;
-	struct th1520_aon_rpc_msg_hdr *hdr =
-		(struct th1520_aon_rpc_msg_hdr *)msg;
-	uint8_t recv_size = sizeof(struct th1520_aon_rpc_msg_hdr) + hdr->size;
-
-	memcpy(aon_ipc->msg, msg, recv_size);
-	dev_dbg(aon_ipc->dev, "msg head: 0x%x, size:%d\n", *((u32 *)msg),
-		recv_size);
-	complete(&aon_ipc->done);
-}
-
-static int th1520_aon_ipc_write(struct th1520_aon_ipc *aon_ipc, void *msg)
-{
-	struct th1520_aon_rpc_msg_hdr *hdr = msg;
-	struct th1520_aon_chan *aon_chan;
-	u32 *data = msg;
-	int ret;
-
-	/* check size, currently it requires 7 MSG in one transfer */
-	if (hdr->size != TH1520_AON_RPC_MSG_NUM)
-		return -EINVAL;
-
-	dev_dbg(aon_ipc->dev, "RPC SVC %u FUNC %u SIZE %u\n", hdr->svc,
-		hdr->func, hdr->size);
-
-	aon_chan = &aon_ipc->chans;
-
-	if (!wait_for_completion_timeout(&aon_chan->tx_done, MAX_TX_TIMEOUT)) {
-		dev_err(aon_ipc->dev, "tx_done timeout\n");
-		return -ETIMEDOUT;
-	}
-	reinit_completion(&aon_chan->tx_done);
-
-	ret = mbox_send_message(aon_chan->ch, data);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-/*
- * RPC command/response
- */
-int th1520_aon_call_rpc(struct th1520_aon_ipc *aon_ipc, void *msg,
-			void *ack_msg, bool have_resp)
-{
-	struct th1520_aon_rpc_msg_hdr *hdr = msg;
-	int ret = 0;
-
-	if (WARN_ON(!aon_ipc || !msg))
-		return -EINVAL;
-
-	if (have_resp && WARN_ON(!ack_msg))
-		return -EINVAL;
-	mutex_lock(&aon_ipc->lock);
-	reinit_completion(&aon_ipc->done);
-
-	RPC_SET_VER(hdr, TH1520_AON_RPC_VERSION);
-	/*svc id use 6bit for version 2*/
-	RPC_SET_SVC_ID(hdr, hdr->svc);
-	RPC_SET_SVC_FLAG_MSG_TYPE(hdr, RPC_SVC_MSG_TYPE_DATA);
-
-	if (have_resp) {
-		aon_ipc->msg = ack_msg;
-		RPC_SET_SVC_FLAG_ACK_TYPE(hdr, RPC_SVC_MSG_NEED_ACK);
-	} else {
-		RPC_SET_SVC_FLAG_ACK_TYPE(hdr, RPC_SVC_MSG_NO_NEED_ACK);
-	}
-
-	ret = th1520_aon_ipc_write(aon_ipc, msg);
-	if (ret < 0) {
-		dev_err(aon_ipc->dev, "RPC send msg failed: %d\n", ret);
-		goto out;
-	}
-
-	if (have_resp) {
-		if (!wait_for_completion_timeout(&aon_ipc->done,
-						 MAX_RX_TIMEOUT)) {
-			dev_err(aon_ipc->dev, "RPC send msg timeout\n");
-			mutex_unlock(&aon_ipc->lock);
-			return -ETIMEDOUT;
-		}
-
-		/* response status is stored in msg data[0] field */
-		struct th1520_aon_rpc_ack_common *ack = ack_msg;
-		ret = ack->err_code;
-	}
-
-out:
-	mutex_unlock(&aon_ipc->lock);
-
-	dev_dbg(aon_ipc->dev, "RPC SVC done\n");
-
-	return th1520_aon_to_linux_errno(ret);
-}
-EXPORT_SYMBOL(th1520_aon_call_rpc);
-
-int get_aon_log_mem(struct device *dev, phys_addr_t *mem, size_t *mem_size)
-{
-	struct resource r;
-	struct device_node *node;
-	int ret;
-
-	*mem = 0;
-	*mem_size = 0;
-
-	node = of_parse_phandle(dev->of_node, "log-memory-region", 0);
-	if (!node) {
-		dev_err(dev, "no memory-region specified\n");
-		return -EINVAL;
-	}
-
-	ret = of_address_to_resource(node, 0, &r);
-	if (ret) {
-		dev_err(dev, "memory-region get resource faild\n");
-		return -EINVAL;
-	}
-
-	*mem = r.start;
-	*mem_size = resource_size(&r);
-	return 0;
-}
-
-static int th1520_aon_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct th1520_aon_ipc *aon_ipc;
-	struct th1520_aon_chan *aon_chan;
-	struct mbox_client *cl;
-	char dir_name[32] = { 0x0 };
-	int ret;
-
-	aon_ipc = devm_kzalloc(dev, sizeof(*aon_ipc), GFP_KERNEL);
-	if (!aon_ipc)
-		return -ENOMEM;
-
-	aon_chan = &aon_ipc->chans;
-	cl = &aon_chan->cl;
-	cl->dev = dev;
-	cl->tx_block = false;
-	cl->knows_txdone = true;
-	cl->rx_callback = th1520_aon_rx_callback;
-
-	/* Initial tx_done completion as "done" */
-	cl->tx_done = th1520_aon_tx_done;
-	init_completion(&aon_chan->tx_done);
-	complete(&aon_chan->tx_done);
-
-	aon_chan->aon_ipc = aon_ipc;
-	aon_chan->ch = mbox_request_channel_byname(cl, "aon");
-	if (IS_ERR(aon_chan->ch)) {
-		ret = PTR_ERR(aon_chan->ch);
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "Failed to request aon mbox chan ret %d\n",
-				ret);
-		return ret;
-	}
-
-	dev_dbg(dev, "request th1520 mbox chan: aon\n");
-
-	aon_ipc->dev = dev;
-	mutex_init(&aon_ipc->lock);
-	init_completion(&aon_ipc->done);
-	aon_chan->log_ctrl = NULL;
-
-	ret = get_aon_log_mem(dev, &aon_chan->log_phy, &aon_chan->log_size);
-	if (ret) {
-		return ret;
-	}
-	aon_chan->log_mem = ioremap(aon_chan->log_phy, aon_chan->log_size);
-	if (!IS_ERR(aon_chan->log_mem)) {
-		pr_info("virtual_log_mem=0x%p, phy base=0x%pa\n",aon_chan->log_mem, &aon_chan->log_phy);
-	} else {
-		aon_chan->log_mem = NULL;
-		dev_err(dev, "%s:get aon log region fail\n", __func__);
-		return -1;
-	}
-
-	sprintf(dir_name, "aon_proc");
-	aon_chan->proc_dir = proc_mkdir(dir_name, NULL);
-	if (NULL != aon_chan->proc_dir) {
-		aon_chan->log_ctrl = th1520_create_panic_log_proc(
-			aon_chan->log_phy, aon_chan->proc_dir,
-			aon_chan->log_mem, aon_chan->log_size);
-	} else {
-		dev_err(dev, "create %s fail\n", dir_name);
-		return ret;
-	}
-	th1520_aon_ipc_handle = aon_ipc;
-
-	return devm_of_platform_populate(dev);
-}
-
-static const struct of_device_id th1520_aon_match[] = {
-	{
-		.compatible = "thead,th1520-aon",
-	},
-	{ /* Sentinel */ }
-};
-
-static int __maybe_unused th1520_aon_resume_noirq(struct device *dev)
-{
-	struct th1520_aon_chan *aon_chan;
-
-	aon_chan = &th1520_aon_ipc_handle->chans;
-
-	complete(&aon_chan->tx_done);
-	return 0;
-}
-
-static const struct dev_pm_ops th1520_aon_pm_ops = {
-	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, th1520_aon_resume_noirq)
-};
-static struct platform_driver th1520_aon_driver = {
-	.driver = {
-		.name = "th1520-aon",
-		.of_match_table = th1520_aon_match,
-		.pm = &th1520_aon_pm_ops,
-	},
-	.probe = th1520_aon_probe,
-};
-builtin_platform_driver(th1520_aon_driver);
-
-MODULE_AUTHOR("fugang.duan <duanfugang.dfg@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead Light firmware protocol driver");
-MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/firmware/xuantie/th1520_aon.c
@@ -0,0 +1,341 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#include <linux/err.h>
+#include <linux/firmware/xuantie/ipc.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/mailbox_client.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/th1520_proc_debug.h>
+#include <linux/firmware/xuantie/ipc.h>
+
+/* wait for response for 3000ms instead of 300ms (fix me pls)*/
+#define MAX_RX_TIMEOUT (msecs_to_jiffies(3000))
+#define MAX_TX_TIMEOUT (msecs_to_jiffies(500))
+
+struct th1520_aon_chan {
+	struct th1520_aon_ipc *aon_ipc;
+
+	struct mbox_client cl;
+	struct mbox_chan *ch;
+	struct completion tx_done;
+	/*for log proc*/
+	phys_addr_t log_phy;
+	size_t log_size;
+	void __iomem *log_mem;
+	void *log_ctrl;
+	struct proc_dir_entry *proc_dir;
+};
+
+struct th1520_aon_ipc {
+	struct th1520_aon_chan chans;
+	struct device *dev;
+	struct mutex lock;
+	struct completion done;
+	u32 *msg;
+};
+
+/*
+ * This type is used to indicate error response for most functions.
+ */
+enum th1520_aon_error_codes {
+	TH1520_AON_ERR_NONE = 0, /* Success */
+	TH1520_AON_ERR_VERSION = 1, /* Incompatible API version */
+	TH1520_AON_ERR_CONFIG = 2, /* Configuration error */
+	TH1520_AON_ERR_PARM = 3, /* Bad parameter */
+	TH1520_AON_ERR_NOACCESS = 4, /* Permission error (no access) */
+	TH1520_AON_ERR_LOCKED = 5, /* Permission error (locked) */
+	TH1520_AON_ERR_UNAVAILABLE = 6, /* Unavailable (out of resources) */
+	TH1520_AON_ERR_NOTFOUND = 7, /* Not found */
+	TH1520_AON_ERR_NOPOWER = 8, /* No power */
+	TH1520_AON_ERR_IPC = 9, /* Generic IPC error */
+	TH1520_AON_ERR_BUSY = 10, /* Resource is currently busy/active */
+	TH1520_AON_ERR_FAIL = 11, /* General I/O failure */
+	TH1520_AON_ERR_LAST
+};
+
+static int th1520_aon_linux_errmap[TH1520_AON_ERR_LAST] = {
+	0, /* TH1520_AON_ERR_NONE */
+	-EINVAL, /* TH1520_AON_ERR_VERSION */
+	-EINVAL, /* TH1520_AON_ERR_CONFIG */
+	-EINVAL, /* TH1520_AON_ERR_PARM */
+	-EACCES, /* TH1520_AON_ERR_NOACCESS */
+	-EACCES, /* TH1520_AON_ERR_LOCKED */
+	-ERANGE, /* TH1520_AON_ERR_UNAVAILABLE */
+	-EEXIST, /* TH1520_AON_ERR_NOTFOUND */
+	-EPERM, /* TH1520_AON_ERR_NOPOWER */
+	-EPIPE, /* TH1520_AON_ERR_IPC */
+	-EBUSY, /* TH1520_AON_ERR_BUSY */
+	-EIO, /* TH1520_AON_ERR_FAIL */
+};
+
+static struct th1520_aon_ipc *th1520_aon_ipc_handle;
+
+static inline int th1520_aon_to_linux_errno(int errno)
+{
+	if (errno >= TH1520_AON_ERR_NONE && errno < TH1520_AON_ERR_LAST)
+		return th1520_aon_linux_errmap[errno];
+	return -EIO;
+}
+
+/*
+ * Get the default handle used by SCU
+ */
+int th1520_aon_get_handle(struct th1520_aon_ipc **ipc)
+{
+	if (!th1520_aon_ipc_handle)
+		return -EPROBE_DEFER;
+
+	*ipc = th1520_aon_ipc_handle;
+	return 0;
+}
+EXPORT_SYMBOL(th1520_aon_get_handle);
+
+static void th1520_aon_tx_done(struct mbox_client *cl, void *mssg, int r)
+{
+	struct th1520_aon_chan *aon_chan =
+		container_of(cl, struct th1520_aon_chan, cl);
+
+	complete(&aon_chan->tx_done);
+}
+
+static void th1520_aon_rx_callback(struct mbox_client *c, void *msg)
+{
+	struct th1520_aon_chan *aon_chan =
+		container_of(c, struct th1520_aon_chan, cl);
+	struct th1520_aon_ipc *aon_ipc = aon_chan->aon_ipc;
+	struct th1520_aon_rpc_msg_hdr *hdr =
+		(struct th1520_aon_rpc_msg_hdr *)msg;
+	uint8_t recv_size = sizeof(struct th1520_aon_rpc_msg_hdr) + hdr->size;
+
+	memcpy(aon_ipc->msg, msg, recv_size);
+	dev_dbg(aon_ipc->dev, "msg head: 0x%x, size:%d\n", *((u32 *)msg),
+		recv_size);
+	complete(&aon_ipc->done);
+}
+
+static int th1520_aon_ipc_write(struct th1520_aon_ipc *aon_ipc, void *msg)
+{
+	struct th1520_aon_rpc_msg_hdr *hdr = msg;
+	struct th1520_aon_chan *aon_chan;
+	u32 *data = msg;
+	int ret;
+
+	/* check size, currently it requires 7 MSG in one transfer */
+	if (hdr->size != TH1520_AON_RPC_MSG_NUM)
+		return -EINVAL;
+
+	dev_dbg(aon_ipc->dev, "RPC SVC %u FUNC %u SIZE %u\n", hdr->svc,
+		hdr->func, hdr->size);
+
+	aon_chan = &aon_ipc->chans;
+
+	if (!wait_for_completion_timeout(&aon_chan->tx_done, MAX_TX_TIMEOUT)) {
+		dev_err(aon_ipc->dev, "tx_done timeout\n");
+		return -ETIMEDOUT;
+	}
+	reinit_completion(&aon_chan->tx_done);
+
+	ret = mbox_send_message(aon_chan->ch, data);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * RPC command/response
+ */
+int th1520_aon_call_rpc(struct th1520_aon_ipc *aon_ipc, void *msg,
+			void *ack_msg, bool have_resp)
+{
+	struct th1520_aon_rpc_msg_hdr *hdr = msg;
+	int ret = 0;
+
+	if (WARN_ON(!aon_ipc || !msg))
+		return -EINVAL;
+
+	if (have_resp && WARN_ON(!ack_msg))
+		return -EINVAL;
+	mutex_lock(&aon_ipc->lock);
+	reinit_completion(&aon_ipc->done);
+
+	RPC_SET_VER(hdr, TH1520_AON_RPC_VERSION);
+	/*svc id use 6bit for version 2*/
+	RPC_SET_SVC_ID(hdr, hdr->svc);
+	RPC_SET_SVC_FLAG_MSG_TYPE(hdr, RPC_SVC_MSG_TYPE_DATA);
+
+	if (have_resp) {
+		aon_ipc->msg = ack_msg;
+		RPC_SET_SVC_FLAG_ACK_TYPE(hdr, RPC_SVC_MSG_NEED_ACK);
+	} else {
+		RPC_SET_SVC_FLAG_ACK_TYPE(hdr, RPC_SVC_MSG_NO_NEED_ACK);
+	}
+
+	ret = th1520_aon_ipc_write(aon_ipc, msg);
+	if (ret < 0) {
+		dev_err(aon_ipc->dev, "RPC send msg failed: %d\n", ret);
+		goto out;
+	}
+
+	if (have_resp) {
+		if (!wait_for_completion_timeout(&aon_ipc->done,
+						 MAX_RX_TIMEOUT)) {
+			dev_err(aon_ipc->dev, "RPC send msg timeout\n");
+			mutex_unlock(&aon_ipc->lock);
+			return -ETIMEDOUT;
+		}
+
+		/* response status is stored in msg data[0] field */
+		struct th1520_aon_rpc_ack_common *ack = ack_msg;
+		ret = ack->err_code;
+	}
+
+out:
+	mutex_unlock(&aon_ipc->lock);
+
+	dev_dbg(aon_ipc->dev, "RPC SVC done\n");
+
+	return th1520_aon_to_linux_errno(ret);
+}
+EXPORT_SYMBOL(th1520_aon_call_rpc);
+
+int get_aon_log_mem(struct device *dev, phys_addr_t *mem, size_t *mem_size)
+{
+	struct resource r;
+	struct device_node *node;
+	int ret;
+
+	*mem = 0;
+	*mem_size = 0;
+
+	node = of_parse_phandle(dev->of_node, "log-memory-region", 0);
+	if (!node) {
+		dev_err(dev, "no memory-region specified\n");
+		return -EINVAL;
+	}
+
+	ret = of_address_to_resource(node, 0, &r);
+	if (ret) {
+		dev_err(dev, "memory-region get resource faild\n");
+		return -EINVAL;
+	}
+
+	*mem = r.start;
+	*mem_size = resource_size(&r);
+	return 0;
+}
+
+static int th1520_aon_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct th1520_aon_ipc *aon_ipc;
+	struct th1520_aon_chan *aon_chan;
+	struct mbox_client *cl;
+	char dir_name[32] = { 0x0 };
+	int ret;
+
+	aon_ipc = devm_kzalloc(dev, sizeof(*aon_ipc), GFP_KERNEL);
+	if (!aon_ipc)
+		return -ENOMEM;
+
+	aon_chan = &aon_ipc->chans;
+	cl = &aon_chan->cl;
+	cl->dev = dev;
+	cl->tx_block = false;
+	cl->knows_txdone = true;
+	cl->rx_callback = th1520_aon_rx_callback;
+
+	/* Initial tx_done completion as "done" */
+	cl->tx_done = th1520_aon_tx_done;
+	init_completion(&aon_chan->tx_done);
+	complete(&aon_chan->tx_done);
+
+	aon_chan->aon_ipc = aon_ipc;
+	aon_chan->ch = mbox_request_channel_byname(cl, "aon");
+	if (IS_ERR(aon_chan->ch)) {
+		ret = PTR_ERR(aon_chan->ch);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "Failed to request aon mbox chan ret %d\n",
+				ret);
+		return ret;
+	}
+
+	dev_dbg(dev, "request th1520 mbox chan: aon\n");
+
+	aon_ipc->dev = dev;
+	mutex_init(&aon_ipc->lock);
+	init_completion(&aon_ipc->done);
+	aon_chan->log_ctrl = NULL;
+
+	ret = get_aon_log_mem(dev, &aon_chan->log_phy, &aon_chan->log_size);
+	if (ret) {
+		return ret;
+	}
+	aon_chan->log_mem = ioremap(aon_chan->log_phy, aon_chan->log_size);
+	if (!IS_ERR(aon_chan->log_mem)) {
+		pr_info("virtual_log_mem=0x%p, phy base=0x%pa\n",aon_chan->log_mem, &aon_chan->log_phy);
+	} else {
+		aon_chan->log_mem = NULL;
+		dev_err(dev, "%s:get aon log region fail\n", __func__);
+		return -1;
+	}
+
+	sprintf(dir_name, "aon_proc");
+	aon_chan->proc_dir = proc_mkdir(dir_name, NULL);
+	if (NULL != aon_chan->proc_dir) {
+		aon_chan->log_ctrl = th1520_create_panic_log_proc(
+			aon_chan->log_phy, aon_chan->proc_dir,
+			aon_chan->log_mem, aon_chan->log_size);
+	} else {
+		dev_err(dev, "create %s fail\n", dir_name);
+		return ret;
+	}
+	th1520_aon_ipc_handle = aon_ipc;
+
+	return devm_of_platform_populate(dev);
+}
+
+static const struct of_device_id th1520_aon_match[] = {
+	{
+		.compatible = "xuantie,th1520-aon",
+	},
+	{ /* Sentinel */ }
+};
+
+static int __maybe_unused th1520_aon_resume_noirq(struct device *dev)
+{
+	struct th1520_aon_chan *aon_chan;
+
+	aon_chan = &th1520_aon_ipc_handle->chans;
+
+	complete(&aon_chan->tx_done);
+	return 0;
+}
+
+static const struct dev_pm_ops th1520_aon_pm_ops = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(NULL, th1520_aon_resume_noirq)
+};
+static struct platform_driver th1520_aon_driver = {
+	.driver = {
+		.name = "th1520-aon",
+		.of_match_table = th1520_aon_match,
+		.pm = &th1520_aon_pm_ops,
+	},
+	.probe = th1520_aon_probe,
+};
+builtin_platform_driver(th1520_aon_driver);
+
+MODULE_AUTHOR("fugang.duan <duanfugang.dfg@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie TH1520 firmware protocol driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/firmware/thead/th1520_aon_pd.c
+++ /dev/null
@@ -1,414 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- */
-
-#include <dt-bindings/firmware/thead/rsrc.h>
-#include <linux/ctype.h>
-#include <linux/debugfs.h>
-#include <linux/firmware/thead/ipc.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include <linux/pm.h>
-#include <linux/pm_domain.h>
-#include <linux/seq_file.h>
-#include <linux/slab.h>
-
-struct th1520_aon_msg_req_set_resource_power_mode {
-	struct th1520_aon_rpc_msg_hdr hdr;
-	u16 resource;
-	u16 mode;
-	u16 reserved[10];
-} __packed __aligned(1);
-
-#define TH1520_AONU_PD_NAME_SIZE 20
-#define TH1520_AONU_PD_STATE_NAME_SIZE 10
-
-struct th1520_aon_pm_domain {
-	struct generic_pm_domain pd;
-	char name[TH1520_AONU_PD_NAME_SIZE];
-	u16 rsrc;
-};
-
-struct th1520_aon_pd_range {
-	char *name;
-	u32 rsrc;
-	u8 num;
-
-	/* add domain index */
-	bool postfix;
-	u8 start_from;
-};
-
-struct th1520_aon_pd_soc {
-	const struct th1520_aon_pd_range *pd_ranges;
-	u8 num_ranges;
-};
-
-static const struct th1520_aon_pd_range th1520_aon_pd_ranges[] = {
-	/* AUDIO SS */
-	{ "audio", TH1520_AON_AUDIO_PD, 1, false, 0 },
-	{ "vdec", TH1520_AON_VDEC_PD, 1, false, 0},
-	{ "npu", TH1520_AON_NPU_PD, 1, false, 0},
-	{ "venc", TH1520_AON_VENC_PD, 1, false, 0},
-	{ "gpu", TH1520_AON_GPU_PD, 1, false, 0},
-	{ "dsp0", TH1520_AON_DSP0_PD, 1, false, 0},
-	{ "dsp1", TH1520_AON_DSP1_PD, 1, false, 0},
-	{},
-};
-
-static const struct th1520_aon_pd_soc th1520_aon_pd = {
-	.pd_ranges = th1520_aon_pd_ranges,
-	.num_ranges = ARRAY_SIZE(th1520_aon_pd_ranges),
-};
-
-static struct th1520_aon_ipc *pm_ipc_handle;
-static struct dentry *pd_debugfs_root;
-struct dentry *pd_pde;
-struct genpd_onecell_data *genpd_data;
-
-static inline struct th1520_aon_pm_domain *to_th1520_aon_pd(struct generic_pm_domain *genpd)
-{
-	return container_of(genpd, struct th1520_aon_pm_domain, pd);
-}
-
-static int th1520_aon_pd_power(struct generic_pm_domain *domain, bool power_on)
-{
-	struct th1520_aon_msg_req_set_resource_power_mode msg;
-	struct th1520_aon_rpc_ack_common  ack_msg;
-	struct th1520_aon_rpc_msg_hdr *hdr = &msg.hdr;
-	struct th1520_aon_pm_domain *pd;
-	int ret;
-
-	pd = to_th1520_aon_pd(domain);
-
-	hdr->svc = TH1520_AON_RPC_SVC_PM;
-	hdr->func = TH1520_AON_PM_FUNC_SET_RESOURCE_POWER_MODE;
-	hdr->size = TH1520_AON_RPC_MSG_NUM;
-
-	RPC_SET_BE16(&msg.resource, 0, pd->rsrc);
-	RPC_SET_BE16(&msg.resource, 2,
-	     (power_on ? TH1520_AON_PM_PW_MODE_ON : TH1520_AON_PM_PW_MODE_OFF));
-
-	ret = th1520_aon_call_rpc(pm_ipc_handle, &msg, &ack_msg, true);
-	if (ret)
-		dev_err(&domain->dev, "failed to power %s resource %d ret %d\n",
-			power_on ? "up" : "off", pd->rsrc, ret);
-
-	return ret;
-}
-
-static int th1520_aon_pd_power_on(struct generic_pm_domain *domain)
-{
-	return th1520_aon_pd_power(domain, true);
-}
-
-static int th1520_aon_pd_power_off(struct generic_pm_domain *domain)
-{
-	return th1520_aon_pd_power(domain, false);
-}
-
-static struct generic_pm_domain *th1520_aon_pd_xlate(struct of_phandle_args *spec,
-						  void *data)
-{
-	struct generic_pm_domain *domain = ERR_PTR(-ENOENT);
-	struct genpd_onecell_data *pd_data = data;
-	unsigned int i;
-
-	for (i = 0; i < pd_data->num_domains; i++) {
-		struct th1520_aon_pm_domain *aon_pd;
-
-		aon_pd = to_th1520_aon_pd(pd_data->domains[i]);
-		if (aon_pd->rsrc == spec->args[0]) {
-			domain = &aon_pd->pd;
-			break;
-		}
-	}
-
-	return domain;
-}
-
-static struct th1520_aon_pm_domain *
-th1520_aon_add_pm_domain(struct device *dev, int idx,
-		      const struct th1520_aon_pd_range *pd_ranges)
-{
-	struct th1520_aon_pm_domain *aon_pd;
-	int ret;
-
-	aon_pd = devm_kzalloc(dev, sizeof(*aon_pd), GFP_KERNEL);
-	if (!aon_pd)
-		return ERR_PTR(-ENOMEM);
-
-	aon_pd->rsrc = pd_ranges->rsrc + idx;
-	aon_pd->pd.power_off = th1520_aon_pd_power_off;
-	aon_pd->pd.power_on = th1520_aon_pd_power_on;
-
-	if (pd_ranges->postfix)
-		snprintf(aon_pd->name, sizeof(aon_pd->name),
-			 "%s%i", pd_ranges->name, pd_ranges->start_from + idx);
-	else
-		snprintf(aon_pd->name, sizeof(aon_pd->name),
-			 "%s", pd_ranges->name);
-
-	aon_pd->pd.name = aon_pd->name;
-
-	if (aon_pd->rsrc >= TH1520_AON_R_LAST) {
-		dev_warn(dev, "invalid pd %s rsrc id %d found",
-			 aon_pd->name, aon_pd->rsrc);
-
-		devm_kfree(dev, aon_pd);
-		return NULL;
-	}
-
-	ret = pm_genpd_init(&aon_pd->pd, NULL, true);
-	if (ret) {
-		dev_warn(dev, "failed to init pd %s rsrc id %d",
-			 aon_pd->name, aon_pd->rsrc);
-		devm_kfree(dev, aon_pd);
-		return NULL;
-	}
-
-	return aon_pd;
-}
-
-static int th1520_aon_init_pm_domains(struct device *dev,
-				    const struct th1520_aon_pd_soc *pd_soc)
-{
-	const struct th1520_aon_pd_range *pd_ranges = pd_soc->pd_ranges;
-	struct generic_pm_domain **domains;
-	struct genpd_onecell_data *pd_data;
-	struct th1520_aon_pm_domain *aon_pd;
-	u32 count = 0;
-	int i, j;
-
-	for (i = 0; i < pd_soc->num_ranges; i++)
-		count += pd_ranges[i].num;
-
-	domains = devm_kcalloc(dev, count, sizeof(*domains), GFP_KERNEL);
-	if (!domains)
-		return -ENOMEM;
-
-	pd_data = devm_kzalloc(dev, sizeof(*pd_data), GFP_KERNEL);
-	if (!pd_data)
-		return -ENOMEM;
-
-	count = 0;
-	for (i = 0; i < pd_soc->num_ranges; i++) {
-		for (j = 0; j < pd_ranges[i].num; j++) {
-			aon_pd = th1520_aon_add_pm_domain(dev, j, &pd_ranges[i]);
-			if (IS_ERR_OR_NULL(aon_pd))
-				continue;
-
-			domains[count++] = &aon_pd->pd;
-			dev_dbg(dev, "added power domain %s\n", aon_pd->pd.name);
-		}
-	}
-
-	pd_data->domains = domains;
-	pd_data->num_domains = count;
-	pd_data->xlate = th1520_aon_pd_xlate;
-	genpd_data = pd_data;
-
-	of_genpd_add_provider_onecell(dev->of_node, pd_data);
-
-	return 0;
-}
-
-static char *pd_get_user_string(const char __user *userbuf, size_t userlen)
-{
-	char *buffer;
-
-	buffer = vmalloc(userlen + 1);
-	if (!buffer)
-		return ERR_PTR(-ENOMEM);
-
-	if (copy_from_user(buffer, userbuf, userlen) != 0) {
-		vfree(buffer);
-		return ERR_PTR(-EFAULT);
-	}
-
-	/* got the string, now strip linefeed. */
-	if (buffer[userlen - 1] == '\n')
-		buffer[userlen - 1] = '\0';
-	else
-		buffer[userlen] = '\0';
-
-	pr_debug("buffer = %s\n", buffer);
-
-	return buffer;
-}
-
-static ssize_t th1520_power_domain_write(struct file *file,
-					const char __user *userbuf,
-					size_t userlen, loff_t *ppos)
-{
-	char *buffer, *start, *end;
-	struct seq_file *m = (struct seq_file *)file->private_data;
-	struct genpd_onecell_data *aon_pds_data = m->private;
-	struct generic_pm_domain *hitted_pm_genpd;
-	struct generic_pm_domain *domain;
-	char pd_name[TH1520_AONU_PD_NAME_SIZE];
-	char pd_state[TH1520_AONU_PD_STATE_NAME_SIZE];
-	int idx, ret;
-	size_t origin_len = userlen;
-
-	buffer = pd_get_user_string(userbuf, userlen);
-	if (IS_ERR(buffer))
-		return PTR_ERR(buffer);
-
-	start = skip_spaces(buffer);
-	end = start;
-	while (!isspace(*end) && *end != '\0')
-		end++;
-
-	*end = '\0';
-	strcpy(pd_name, start);
-	pr_debug("power domain name: %s\n", pd_name);
-
-	/* find the target power domain */
-	for (idx = 0; idx < aon_pds_data->num_domains; idx++) {
-		domain = aon_pds_data->domains[idx];
-		pr_debug("generic pm domain name: %s, pd_name: %s, ret = %d\n",
-				domain->name, pd_name, strcmp(pd_name, domain->name));
-		if (strcmp(pd_name, domain->name))
-			continue;
-		else {
-			hitted_pm_genpd = aon_pds_data->domains[idx];
-			pr_debug("target pm power domain-%s found, index: %d\n",
-					hitted_pm_genpd->name, idx);
-			break;
-		}
-	}
-
-	if (idx >= aon_pds_data->num_domains) {
-		pr_err("no taget power domain-%s found, idx = %d, total pd numbers = %d\n",
-				pd_name, idx, aon_pds_data->num_domains);
-		userlen = -EINVAL;
-		goto out;
-	}
-
-	if (!hitted_pm_genpd->power_on && !hitted_pm_genpd->power_off) {
-		pr_err("no power operations registered for power domain-%s\n", pd_name);
-		userlen = -EINVAL;
-		goto out;
-	}
-
-	end = end + 1;
-	start = skip_spaces(end);
-	end = start;
-	while (!isspace(*end) && *end != '\0')
-		end++;
-
-	*end = '\0';
-	strcpy(pd_state, start);
-	pr_debug("power domain target state: %s\n", pd_state);
-
-	if (!strcmp(pd_state, "on")) {
-		ret = hitted_pm_genpd->power_on(hitted_pm_genpd);
-		if (ret) {
-			userlen = ret;
-			goto out;
-		}
-	} else if (!strcmp(pd_state, "off")) {
-		ret = hitted_pm_genpd->power_off(hitted_pm_genpd);
-		if (ret) {
-			userlen = ret;
-			goto out;
-		}
-	} else {
-		pr_err("invalid power domain target state, not 'on' or 'off'\n");
-		userlen = -EINVAL;
-		goto out;
-	}
-
-out:
-	memset(buffer, 0, origin_len);
-	vfree(buffer);
-
-	return userlen;
-}
-
-static int th1520_power_domain_show(struct seq_file *m, void *v)
-{
-	struct genpd_onecell_data *pd_data = m->private;
-	u32 count = pd_data->num_domains;
-	int idx;
-
-	seq_puts(m, "[Power domain name list]: ");
-	for (idx = 0; idx < count; idx++)
-		seq_printf(m, "%s ", pd_data->domains[idx]->name);
-	seq_puts(m, "\n");
-	seq_puts(m, "[Power on  domain usage]: echo power_name on  > domain\n");
-	seq_puts(m, "[Power off domain usage]: echo power_name off > domain\n");
-
-	return 0;
-}
-
-static int th1520_power_domain_open(struct inode *inode, struct file *file)
-{
-	struct genpd_onecell_data *pd_data = inode->i_private;
-
-	return single_open(file, th1520_power_domain_show, pd_data);
-}
-
-static const struct file_operations th1520_power_domain_fops = {
-	.owner	= THIS_MODULE,
-	.write	= th1520_power_domain_write,
-	.read	= seq_read,
-	.open	= th1520_power_domain_open,
-	.llseek	= generic_file_llseek,
-};
-
-static void pd_debugfs_init(struct genpd_onecell_data *aon_pds_data)
-{
-	pd_debugfs_root = debugfs_create_dir("power_domain", NULL);
-	if (!pd_debugfs_root || IS_ERR(pd_debugfs_root))
-		return;
-
-	pd_pde = debugfs_create_file("domain", 0600, pd_debugfs_root,
-			(void *)aon_pds_data, &th1520_power_domain_fops);
-}
-
-static int th1520_aon_pd_probe(struct platform_device *pdev)
-{
-	const struct th1520_aon_pd_soc *pd_soc;
-	int ret;
-
-	ret = th1520_aon_get_handle(&pm_ipc_handle);
-	if (ret)
-		return ret;
-
-	pd_soc = of_device_get_match_data(&pdev->dev);
-	if (!pd_soc)
-		return -ENODEV;
-
-	ret = th1520_aon_init_pm_domains(&pdev->dev, pd_soc);
-	if (ret)
-		return ret;
-
-	pd_debugfs_init(genpd_data);
-
-	return 0;
-}
-
-static const struct of_device_id th1520_aon_pd_match[] = {
-	{ .compatible = "thead,th1520-aon-pd", &th1520_aon_pd},
-	{ /* sentinel */ }
-};
-
-static struct platform_driver th1520_aon_pd_driver = {
-	.driver = {
-		.name = "th1520-aon-pd",
-		.of_match_table = th1520_aon_pd_match,
-	},
-	.probe = th1520_aon_pd_probe,
-};
-builtin_platform_driver(th1520_aon_pd_driver);
-
-MODULE_AUTHOR("fugang.duan <duanfugang.dfg@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead Light firmware protocol driver");
-MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/firmware/xuantie/th1520_aon_pd.c
@@ -0,0 +1,414 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#include <dt-bindings/firmware/xuantie/rsrc.h>
+#include <linux/ctype.h>
+#include <linux/debugfs.h>
+#include <linux/firmware/xuantie/ipc.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_domain.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+
+struct th1520_aon_msg_req_set_resource_power_mode {
+	struct th1520_aon_rpc_msg_hdr hdr;
+	u16 resource;
+	u16 mode;
+	u16 reserved[10];
+} __packed __aligned(1);
+
+#define TH1520_AONU_PD_NAME_SIZE 20
+#define TH1520_AONU_PD_STATE_NAME_SIZE 10
+
+struct th1520_aon_pm_domain {
+	struct generic_pm_domain pd;
+	char name[TH1520_AONU_PD_NAME_SIZE];
+	u16 rsrc;
+};
+
+struct th1520_aon_pd_range {
+	char *name;
+	u32 rsrc;
+	u8 num;
+
+	/* add domain index */
+	bool postfix;
+	u8 start_from;
+};
+
+struct th1520_aon_pd_soc {
+	const struct th1520_aon_pd_range *pd_ranges;
+	u8 num_ranges;
+};
+
+static const struct th1520_aon_pd_range th1520_aon_pd_ranges[] = {
+	/* AUDIO SS */
+	{ "audio", TH1520_AON_AUDIO_PD, 1, false, 0 },
+	{ "vdec", TH1520_AON_VDEC_PD, 1, false, 0},
+	{ "npu", TH1520_AON_NPU_PD, 1, false, 0},
+	{ "venc", TH1520_AON_VENC_PD, 1, false, 0},
+	{ "gpu", TH1520_AON_GPU_PD, 1, false, 0},
+	{ "dsp0", TH1520_AON_DSP0_PD, 1, false, 0},
+	{ "dsp1", TH1520_AON_DSP1_PD, 1, false, 0},
+	{},
+};
+
+static const struct th1520_aon_pd_soc th1520_aon_pd = {
+	.pd_ranges = th1520_aon_pd_ranges,
+	.num_ranges = ARRAY_SIZE(th1520_aon_pd_ranges),
+};
+
+static struct th1520_aon_ipc *pm_ipc_handle;
+static struct dentry *pd_debugfs_root;
+struct dentry *pd_pde;
+struct genpd_onecell_data *genpd_data;
+
+static inline struct th1520_aon_pm_domain *to_th1520_aon_pd(struct generic_pm_domain *genpd)
+{
+	return container_of(genpd, struct th1520_aon_pm_domain, pd);
+}
+
+static int th1520_aon_pd_power(struct generic_pm_domain *domain, bool power_on)
+{
+	struct th1520_aon_msg_req_set_resource_power_mode msg;
+	struct th1520_aon_rpc_ack_common  ack_msg;
+	struct th1520_aon_rpc_msg_hdr *hdr = &msg.hdr;
+	struct th1520_aon_pm_domain *pd;
+	int ret;
+
+	pd = to_th1520_aon_pd(domain);
+
+	hdr->svc = TH1520_AON_RPC_SVC_PM;
+	hdr->func = TH1520_AON_PM_FUNC_SET_RESOURCE_POWER_MODE;
+	hdr->size = TH1520_AON_RPC_MSG_NUM;
+
+	RPC_SET_BE16(&msg.resource, 0, pd->rsrc);
+	RPC_SET_BE16(&msg.resource, 2,
+	     (power_on ? TH1520_AON_PM_PW_MODE_ON : TH1520_AON_PM_PW_MODE_OFF));
+
+	ret = th1520_aon_call_rpc(pm_ipc_handle, &msg, &ack_msg, true);
+	if (ret)
+		dev_err(&domain->dev, "failed to power %s resource %d ret %d\n",
+			power_on ? "up" : "off", pd->rsrc, ret);
+
+	return ret;
+}
+
+static int th1520_aon_pd_power_on(struct generic_pm_domain *domain)
+{
+	return th1520_aon_pd_power(domain, true);
+}
+
+static int th1520_aon_pd_power_off(struct generic_pm_domain *domain)
+{
+	return th1520_aon_pd_power(domain, false);
+}
+
+static struct generic_pm_domain *th1520_aon_pd_xlate(struct of_phandle_args *spec,
+						  void *data)
+{
+	struct generic_pm_domain *domain = ERR_PTR(-ENOENT);
+	struct genpd_onecell_data *pd_data = data;
+	unsigned int i;
+
+	for (i = 0; i < pd_data->num_domains; i++) {
+		struct th1520_aon_pm_domain *aon_pd;
+
+		aon_pd = to_th1520_aon_pd(pd_data->domains[i]);
+		if (aon_pd->rsrc == spec->args[0]) {
+			domain = &aon_pd->pd;
+			break;
+		}
+	}
+
+	return domain;
+}
+
+static struct th1520_aon_pm_domain *
+th1520_aon_add_pm_domain(struct device *dev, int idx,
+		      const struct th1520_aon_pd_range *pd_ranges)
+{
+	struct th1520_aon_pm_domain *aon_pd;
+	int ret;
+
+	aon_pd = devm_kzalloc(dev, sizeof(*aon_pd), GFP_KERNEL);
+	if (!aon_pd)
+		return ERR_PTR(-ENOMEM);
+
+	aon_pd->rsrc = pd_ranges->rsrc + idx;
+	aon_pd->pd.power_off = th1520_aon_pd_power_off;
+	aon_pd->pd.power_on = th1520_aon_pd_power_on;
+
+	if (pd_ranges->postfix)
+		snprintf(aon_pd->name, sizeof(aon_pd->name),
+			 "%s%i", pd_ranges->name, pd_ranges->start_from + idx);
+	else
+		snprintf(aon_pd->name, sizeof(aon_pd->name),
+			 "%s", pd_ranges->name);
+
+	aon_pd->pd.name = aon_pd->name;
+
+	if (aon_pd->rsrc >= TH1520_AON_R_LAST) {
+		dev_warn(dev, "invalid pd %s rsrc id %d found",
+			 aon_pd->name, aon_pd->rsrc);
+
+		devm_kfree(dev, aon_pd);
+		return NULL;
+	}
+
+	ret = pm_genpd_init(&aon_pd->pd, NULL, true);
+	if (ret) {
+		dev_warn(dev, "failed to init pd %s rsrc id %d",
+			 aon_pd->name, aon_pd->rsrc);
+		devm_kfree(dev, aon_pd);
+		return NULL;
+	}
+
+	return aon_pd;
+}
+
+static int th1520_aon_init_pm_domains(struct device *dev,
+				    const struct th1520_aon_pd_soc *pd_soc)
+{
+	const struct th1520_aon_pd_range *pd_ranges = pd_soc->pd_ranges;
+	struct generic_pm_domain **domains;
+	struct genpd_onecell_data *pd_data;
+	struct th1520_aon_pm_domain *aon_pd;
+	u32 count = 0;
+	int i, j;
+
+	for (i = 0; i < pd_soc->num_ranges; i++)
+		count += pd_ranges[i].num;
+
+	domains = devm_kcalloc(dev, count, sizeof(*domains), GFP_KERNEL);
+	if (!domains)
+		return -ENOMEM;
+
+	pd_data = devm_kzalloc(dev, sizeof(*pd_data), GFP_KERNEL);
+	if (!pd_data)
+		return -ENOMEM;
+
+	count = 0;
+	for (i = 0; i < pd_soc->num_ranges; i++) {
+		for (j = 0; j < pd_ranges[i].num; j++) {
+			aon_pd = th1520_aon_add_pm_domain(dev, j, &pd_ranges[i]);
+			if (IS_ERR_OR_NULL(aon_pd))
+				continue;
+
+			domains[count++] = &aon_pd->pd;
+			dev_dbg(dev, "added power domain %s\n", aon_pd->pd.name);
+		}
+	}
+
+	pd_data->domains = domains;
+	pd_data->num_domains = count;
+	pd_data->xlate = th1520_aon_pd_xlate;
+	genpd_data = pd_data;
+
+	of_genpd_add_provider_onecell(dev->of_node, pd_data);
+
+	return 0;
+}
+
+static char *pd_get_user_string(const char __user *userbuf, size_t userlen)
+{
+	char *buffer;
+
+	buffer = vmalloc(userlen + 1);
+	if (!buffer)
+		return ERR_PTR(-ENOMEM);
+
+	if (copy_from_user(buffer, userbuf, userlen) != 0) {
+		vfree(buffer);
+		return ERR_PTR(-EFAULT);
+	}
+
+	/* got the string, now strip linefeed. */
+	if (buffer[userlen - 1] == '\n')
+		buffer[userlen - 1] = '\0';
+	else
+		buffer[userlen] = '\0';
+
+	pr_debug("buffer = %s\n", buffer);
+
+	return buffer;
+}
+
+static ssize_t th1520_power_domain_write(struct file *file,
+					const char __user *userbuf,
+					size_t userlen, loff_t *ppos)
+{
+	char *buffer, *start, *end;
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct genpd_onecell_data *aon_pds_data = m->private;
+	struct generic_pm_domain *hitted_pm_genpd;
+	struct generic_pm_domain *domain;
+	char pd_name[TH1520_AONU_PD_NAME_SIZE];
+	char pd_state[TH1520_AONU_PD_STATE_NAME_SIZE];
+	int idx, ret;
+	size_t origin_len = userlen;
+
+	buffer = pd_get_user_string(userbuf, userlen);
+	if (IS_ERR(buffer))
+		return PTR_ERR(buffer);
+
+	start = skip_spaces(buffer);
+	end = start;
+	while (!isspace(*end) && *end != '\0')
+		end++;
+
+	*end = '\0';
+	strcpy(pd_name, start);
+	pr_debug("power domain name: %s\n", pd_name);
+
+	/* find the target power domain */
+	for (idx = 0; idx < aon_pds_data->num_domains; idx++) {
+		domain = aon_pds_data->domains[idx];
+		pr_debug("generic pm domain name: %s, pd_name: %s, ret = %d\n",
+				domain->name, pd_name, strcmp(pd_name, domain->name));
+		if (strcmp(pd_name, domain->name))
+			continue;
+		else {
+			hitted_pm_genpd = aon_pds_data->domains[idx];
+			pr_debug("target pm power domain-%s found, index: %d\n",
+					hitted_pm_genpd->name, idx);
+			break;
+		}
+	}
+
+	if (idx >= aon_pds_data->num_domains) {
+		pr_err("no taget power domain-%s found, idx = %d, total pd numbers = %d\n",
+				pd_name, idx, aon_pds_data->num_domains);
+		userlen = -EINVAL;
+		goto out;
+	}
+
+	if (!hitted_pm_genpd->power_on && !hitted_pm_genpd->power_off) {
+		pr_err("no power operations registered for power domain-%s\n", pd_name);
+		userlen = -EINVAL;
+		goto out;
+	}
+
+	end = end + 1;
+	start = skip_spaces(end);
+	end = start;
+	while (!isspace(*end) && *end != '\0')
+		end++;
+
+	*end = '\0';
+	strcpy(pd_state, start);
+	pr_debug("power domain target state: %s\n", pd_state);
+
+	if (!strcmp(pd_state, "on")) {
+		ret = hitted_pm_genpd->power_on(hitted_pm_genpd);
+		if (ret) {
+			userlen = ret;
+			goto out;
+		}
+	} else if (!strcmp(pd_state, "off")) {
+		ret = hitted_pm_genpd->power_off(hitted_pm_genpd);
+		if (ret) {
+			userlen = ret;
+			goto out;
+		}
+	} else {
+		pr_err("invalid power domain target state, not 'on' or 'off'\n");
+		userlen = -EINVAL;
+		goto out;
+	}
+
+out:
+	memset(buffer, 0, origin_len);
+	vfree(buffer);
+
+	return userlen;
+}
+
+static int th1520_power_domain_show(struct seq_file *m, void *v)
+{
+	struct genpd_onecell_data *pd_data = m->private;
+	u32 count = pd_data->num_domains;
+	int idx;
+
+	seq_puts(m, "[Power domain name list]: ");
+	for (idx = 0; idx < count; idx++)
+		seq_printf(m, "%s ", pd_data->domains[idx]->name);
+	seq_puts(m, "\n");
+	seq_puts(m, "[Power on  domain usage]: echo power_name on  > domain\n");
+	seq_puts(m, "[Power off domain usage]: echo power_name off > domain\n");
+
+	return 0;
+}
+
+static int th1520_power_domain_open(struct inode *inode, struct file *file)
+{
+	struct genpd_onecell_data *pd_data = inode->i_private;
+
+	return single_open(file, th1520_power_domain_show, pd_data);
+}
+
+static const struct file_operations th1520_power_domain_fops = {
+	.owner	= THIS_MODULE,
+	.write	= th1520_power_domain_write,
+	.read	= seq_read,
+	.open	= th1520_power_domain_open,
+	.llseek	= generic_file_llseek,
+};
+
+static void pd_debugfs_init(struct genpd_onecell_data *aon_pds_data)
+{
+	pd_debugfs_root = debugfs_create_dir("power_domain", NULL);
+	if (!pd_debugfs_root || IS_ERR(pd_debugfs_root))
+		return;
+
+	pd_pde = debugfs_create_file("domain", 0600, pd_debugfs_root,
+			(void *)aon_pds_data, &th1520_power_domain_fops);
+}
+
+static int th1520_aon_pd_probe(struct platform_device *pdev)
+{
+	const struct th1520_aon_pd_soc *pd_soc;
+	int ret;
+
+	ret = th1520_aon_get_handle(&pm_ipc_handle);
+	if (ret)
+		return ret;
+
+	pd_soc = of_device_get_match_data(&pdev->dev);
+	if (!pd_soc)
+		return -ENODEV;
+
+	ret = th1520_aon_init_pm_domains(&pdev->dev, pd_soc);
+	if (ret)
+		return ret;
+
+	pd_debugfs_init(genpd_data);
+
+	return 0;
+}
+
+static const struct of_device_id th1520_aon_pd_match[] = {
+	{ .compatible = "xuantie,th1520-aon-pd", &th1520_aon_pd},
+	{ /* sentinel */ }
+};
+
+static struct platform_driver th1520_aon_pd_driver = {
+	.driver = {
+		.name = "th1520-aon-pd",
+		.of_match_table = th1520_aon_pd_match,
+	},
+	.probe = th1520_aon_pd_probe,
+};
+builtin_platform_driver(th1520_aon_pd_driver);
+
+MODULE_AUTHOR("fugang.duan <duanfugang.dfg@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie TH1520 firmware protocol driver");
+MODULE_LICENSE("GPL");
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -1441,7 +1441,7 @@ config XILINX_AMS
 	  The driver can also be built as a module. If so, the module will be called
 	  xilinx-ams.
 
-config THEAD_TH1520_ADC
+config XUANTIE_TH1520_ADC
 	tristate "XuanTie TH1520 ADC driver"
 	depends on OF
 	depends on HAS_IOMEM
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -129,4 +129,4 @@ xilinx-xadc-y := xilinx-xadc-core.o xili
 obj-$(CONFIG_XILINX_XADC) += xilinx-xadc.o
 obj-$(CONFIG_XILINX_AMS) += xilinx-ams.o
 obj-$(CONFIG_SD_ADC_MODULATOR) += sd_adc_modulator.o
-obj-$(CONFIG_THEAD_TH1520_ADC) += th1520-adc.o
+obj-$(CONFIG_XUANTIE_TH1520_ADC) += th1520-adc.o
--- a/drivers/iio/adc/th1520-adc.c
+++ b/drivers/iio/adc/th1520-adc.c
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * THEAD TH1520 ADC driver
+ * XuanTie TH1520 ADC driver
  *
  * Copyright (C) 2021-2024 Alibaba Group Holding Limited.
  * Fugang Duan <duanfugang.dfg@linux.alibaba.com>
@@ -349,7 +349,7 @@ static const struct iio_info th1520_adc_
 };
 
 static const struct of_device_id th1520_adc_match[] = {
-	{ .compatible = "thead,th1520-adc", },
+	{ .compatible = "xuantie,th1520-adc", },
 	{ /* end */ }
 };
 MODULE_DEVICE_TABLE(of, th1520_adc_match);
@@ -489,7 +489,7 @@ static int th1520_adc_probe(struct platf
 		goto error_iio_device_register;
 	}
 
-	dev_info(&pdev->dev, "THEAD TH1520 adc registered.\n");
+	dev_info(&pdev->dev, "XuanTie TH1520 adc registered.\n");
 	return 0;
 
 error_iio_device_register:
@@ -569,5 +569,5 @@ static struct platform_driver th1520_adc
 module_platform_driver(th1520_adc_driver);
 
 MODULE_AUTHOR("fugang.duan <duanfugang.dfg@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead TH1520 ADC driver");
+MODULE_DESCRIPTION("XuanTie TH1520 ADC driver");
 MODULE_LICENSE("GPL");
--- a/drivers/iio/adc/th1520-adc.h
+++ b/drivers/iio/adc/th1520-adc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * THEAD TH1520 ADC driver
+ * XuanTie TH1520 ADC driver
  *
  * Copyright (C) 2021-2024 Alibaba Group Holding Limited.
  * Fugang Duan <duanfugang.dfg@linux.alibaba.com>
@@ -10,7 +10,7 @@
 #include <linux/bitops.h>
 
 /* This will be the driver name the kernel reports */
-#define DRIVER_NAME "thead-th1520-adc"
+#define DRIVER_NAME "xuantie-th1520-adc"
 
 /* ADC registers */
 #define TH1520_ADC_PHY_CFG			0x00
--- a/drivers/mmc/host/sdhci-of-dwcmshc.c
+++ b/drivers/mmc/host/sdhci-of-dwcmshc.c
@@ -879,7 +879,7 @@ static const struct of_device_id sdhci_d
 		.data = &sdhci_dwcmshc_pdata,
 	},
 	{
-		.compatible = "thead,th1520-dwcmshc",
+		.compatible = "xuantie,th1520-dwcmshc",
 		.data = &sdhci_dwcmshc_th1520_pdata,
 	},
 	{},
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -216,7 +216,7 @@ config DWMAC_SUN8I
 	  stmmac device driver. This driver is used for H3/A83T/A64
 	  EMAC ethernet controller.
 
-config DWMAC_THEAD
+config DWMAC_XUANTIE
 	tristate "XuanTie dwmac support"
 	depends on OF && (ARCH_XUANTIE || COMPILE_TEST)
 	select MFD_SYSCON
--- a/drivers/net/ethernet/stmicro/stmmac/Makefile
+++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
@@ -27,7 +27,7 @@ obj-$(CONFIG_DWMAC_STI)		+= dwmac-sti.o
 obj-$(CONFIG_DWMAC_STM32)	+= dwmac-stm32.o
 obj-$(CONFIG_DWMAC_SUNXI)	+= dwmac-sunxi.o
 obj-$(CONFIG_DWMAC_SUN8I)	+= dwmac-sun8i.o
-obj-$(CONFIG_DWMAC_THEAD)	+= dwmac-thead.o
+obj-$(CONFIG_DWMAC_XUANTIE)	+= dwmac-xuantie.o
 obj-$(CONFIG_DWMAC_DWC_QOS_ETH)	+= dwmac-dwc-qos-eth.o
 obj-$(CONFIG_DWMAC_INTEL_PLAT)	+= dwmac-intel-plat.o
 obj-$(CONFIG_DWMAC_GENERIC)	+= dwmac-generic.o
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-thead.c
+++ /dev/null
@@ -1,585 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * T-HEAD DWMAC platform driver
- *
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- * Copyright (C) 2023 Jisheng Zhang <jszhang@kernel.org>
- *
- */
-
-#include <linux/bitfield.h>
-#include <linux/mfd/syscon.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/of_net.h>
-#include <linux/platform_device.h>
-#include <linux/regmap.h>
-#include <linux/pm_runtime.h>
-
-#include "stmmac_platform.h"
-
-#define GMAC_CLK_EN			0x00
-#define  GMAC_TX_CLK_EN			BIT(1)
-#define  GMAC_TX_CLK_N_EN		BIT(2)
-#define  GMAC_TX_CLK_OUT_EN		BIT(3)
-#define  GMAC_RX_CLK_EN			BIT(4)
-#define  GMAC_RX_CLK_N_EN		BIT(5)
-#define  GMAC_EPHY_REF_CLK_EN		BIT(6)
-#define GMAC_RXCLK_DELAY_CTRL		0x04
-#define  GMAC_RXCLK_BYPASS		BIT(15)
-#define  GMAC_RXCLK_INVERT		BIT(14)
-#define  GMAC_RXCLK_DELAY_MASK		GENMASK(4, 0)
-#define  GMAC_RXCLK_DELAY_VAL(x)	FIELD_PREP(GMAC_RXCLK_DELAY_MASK, (x))
-#define GMAC_TXCLK_DELAY_CTRL		0x08
-#define  GMAC_TXCLK_BYPASS		BIT(15)
-#define  GMAC_TXCLK_INVERT		BIT(14)
-#define  GMAC_TXCLK_DELAY_MASK		GENMASK(4, 0)
-#define  GMAC_TXCLK_DELAY_VAL(x)	FIELD_PREP(GMAC_RXCLK_DELAY_MASK, (x))
-#define GMAC_PLLCLK_DIV			0x0c
-#define  GMAC_PLLCLK_DIV_EN		BIT(31)
-#define  GMAC_PLLCLK_DIV_MASK		GENMASK(7, 0)
-#define  GMAC_PLLCLK_DIV_NUM(x)		FIELD_PREP(GMAC_PLLCLK_DIV_MASK, (x))
-#define GMAC_CLK_PTP			0x14
-#define  GMAC_CLK_PTP_DIV_EN		BIT(31)
-#define  GMAC_CLK_PTP_DIV_MASK		GENMASK(7, 0)
-#define  GMAC_CLK_PTP_DIV_NUM(x)	FIELD_PREP(GMAC_CLK_PTP_DIV_MASK, (x))
-#define GMAC_GTXCLK_SEL			0x18
-#define  GMAC_GTXCLK_SEL_PLL		BIT(0)
-#define GMAC_INTF_CTRL			0x1c
-#define  PHY_INTF_MASK			BIT(0)
-#define  PHY_INTF_RGMII			FIELD_PREP(PHY_INTF_MASK, 1)
-#define  PHY_INTF_MII_GMII		FIELD_PREP(PHY_INTF_MASK, 0)
-#define GMAC_TXCLK_OEN			0x20
-#define  TXCLK_DIR_MASK			BIT(0)
-#define  TXCLK_DIR_OUTPUT		FIELD_PREP(TXCLK_DIR_MASK, 0)
-#define  TXCLK_DIR_INPUT		FIELD_PREP(TXCLK_DIR_MASK, 1)
-
-#define GMAC_GMII_RGMII_RATE	125000000
-#define GMAC_MII_RATE		25000000
-#define GMAC_PTP_CLK_RATE	50000000 //50MHz
-
-struct thead_dwmac {
-	struct plat_stmmacenet_data *plat;
-	struct regmap *apb_regmap;
-	struct device *dev;
-	u32 rx_delay;
-	u32 tx_delay;
-	struct clk *gmac_axi_aclk;
-	struct clk *gmac_axi_pclk;
-};
-
-#define  pm_debug dev_dbg	/* for suspend/resume interface debug info */
-
-static int thead_dwmac_set_phy_if(struct plat_stmmacenet_data *plat)
-{
-	struct thead_dwmac *dwmac = plat->bsp_priv;
-	u32 phyif;
-
-	switch (plat->mac_interface) {
-	case PHY_INTERFACE_MODE_MII:
-		phyif = PHY_INTF_MII_GMII;
-		break;
-	case PHY_INTERFACE_MODE_RGMII:
-	case PHY_INTERFACE_MODE_RGMII_ID:
-	case PHY_INTERFACE_MODE_RGMII_TXID:
-	case PHY_INTERFACE_MODE_RGMII_RXID:
-		phyif = PHY_INTF_RGMII;
-		break;
-	default:
-		dev_err(dwmac->dev, "unsupported phy interface %d\n",
-			plat->mac_interface);
-		return -EINVAL;
-	};
-
-	regmap_write(dwmac->apb_regmap, GMAC_INTF_CTRL, phyif);
-
-	return 0;
-}
-
-static int thead_dwmac_set_txclk_dir(struct plat_stmmacenet_data *plat)
-{
-	struct thead_dwmac *dwmac = plat->bsp_priv;
-	u32 txclk_dir;
-
-	switch (plat->mac_interface) {
-	case PHY_INTERFACE_MODE_MII:
-		txclk_dir = TXCLK_DIR_INPUT;
-		break;
-	case PHY_INTERFACE_MODE_RGMII:
-	case PHY_INTERFACE_MODE_RGMII_ID:
-	case PHY_INTERFACE_MODE_RGMII_TXID:
-	case PHY_INTERFACE_MODE_RGMII_RXID:
-		txclk_dir = TXCLK_DIR_OUTPUT;
-		break;
-	default:
-		dev_err(dwmac->dev, "unsupported phy interface %d\n",
-			plat->mac_interface);
-		return -EINVAL;
-	};
-
-	regmap_write(dwmac->apb_regmap, GMAC_TXCLK_OEN, txclk_dir);
-
-	return 0;
-}
-
-static void thead_dwmac_fix_speed(void *priv, unsigned int speed, unsigned int mode)
-{
-	struct thead_dwmac *dwmac = priv;
-	struct plat_stmmacenet_data *plat = dwmac->plat;
-	unsigned long rate;
-	u32 div;
-
-	switch (plat->mac_interface) {
-	/* For MII, rxc/txc is provided by phy */
-	case PHY_INTERFACE_MODE_MII:
-		return;
-
-	case PHY_INTERFACE_MODE_RGMII:
-	case PHY_INTERFACE_MODE_RGMII_ID:
-	case PHY_INTERFACE_MODE_RGMII_RXID:
-	case PHY_INTERFACE_MODE_RGMII_TXID:
-		rate = clk_get_rate(plat->stmmac_clk);
-		if (!rate || rate % GMAC_GMII_RGMII_RATE != 0 ||
-		    rate % GMAC_MII_RATE != 0) {
-			dev_err(dwmac->dev, "invalid gmac rate %ld\n", rate);
-			return;
-		}
-
-		regmap_update_bits(dwmac->apb_regmap, GMAC_PLLCLK_DIV, GMAC_PLLCLK_DIV_EN, 0);
-
-		switch (speed) {
-		case SPEED_1000:
-			div = rate / GMAC_GMII_RGMII_RATE;
-			break;
-		case SPEED_100:
-			div = rate / GMAC_MII_RATE;
-			break;
-		case SPEED_10:
-			div = rate * 10 / GMAC_MII_RATE;
-			break;
-		default:
-			dev_err(dwmac->dev, "invalid speed %u\n", speed);
-			return;
-		}
-		regmap_update_bits(dwmac->apb_regmap, GMAC_PLLCLK_DIV,
-				   GMAC_PLLCLK_DIV_MASK, GMAC_PLLCLK_DIV_NUM(div));
-
-		regmap_update_bits(dwmac->apb_regmap, GMAC_PLLCLK_DIV,
-				   GMAC_PLLCLK_DIV_EN, GMAC_PLLCLK_DIV_EN);
-		break;
-	default:
-		dev_err(dwmac->dev, "unsupported phy interface %d\n",
-			plat->mac_interface);
-		return;
-	}
-}
-
-static int thead_dwmac_enable_clk(struct plat_stmmacenet_data *plat)
-{
-	struct thead_dwmac *dwmac = plat->bsp_priv;
-	u32 reg;
-
-	switch (plat->mac_interface) {
-	case PHY_INTERFACE_MODE_MII:
-		reg = GMAC_RX_CLK_EN | GMAC_TX_CLK_EN;
-		break;
-
-	case PHY_INTERFACE_MODE_RGMII:
-	case PHY_INTERFACE_MODE_RGMII_ID:
-	case PHY_INTERFACE_MODE_RGMII_RXID:
-	case PHY_INTERFACE_MODE_RGMII_TXID:
-		/* use pll */
-		regmap_write(dwmac->apb_regmap, GMAC_GTXCLK_SEL, GMAC_GTXCLK_SEL_PLL);
-
-		reg = GMAC_TX_CLK_EN | GMAC_TX_CLK_N_EN | GMAC_TX_CLK_OUT_EN |
-		      GMAC_RX_CLK_EN | GMAC_RX_CLK_N_EN;
-		break;
-
-	default:
-		dev_err(dwmac->dev, "unsupported phy interface %d\n",
-			plat->mac_interface);
-		return -EINVAL;
-	}
-
-	regmap_write(dwmac->apb_regmap, GMAC_CLK_EN, reg);
-
-	return 0;
-}
-static void thead_dwmac_set_ptp_clk(struct plat_stmmacenet_data *plat_dat,unsigned int ptp_clk_rate)
-{
-	unsigned int div;
-	struct thead_dwmac *dwmac = plat_dat->bsp_priv;
-
-	unsigned long src_freq = clk_get_rate(plat_dat->stmmac_clk);
-
-	if(!ptp_clk_rate || !src_freq)
-	{
-		pr_warn("invalid gmac pll freq %lu or ptp_clk_rate %d\n", src_freq,ptp_clk_rate);
-		return;
-	}
-	/* disable clk_div */
-	regmap_update_bits(dwmac->apb_regmap, GMAC_CLK_PTP, GMAC_CLK_PTP_DIV_EN, 0);
-
-	div = src_freq / ptp_clk_rate;
-	regmap_update_bits(dwmac->apb_regmap, GMAC_CLK_PTP,
-			GMAC_CLK_PTP_DIV_MASK, GMAC_CLK_PTP_DIV_NUM(div));
-
-	/* enable clk_div */
-	regmap_update_bits(dwmac->apb_regmap, GMAC_CLK_PTP,
-			GMAC_CLK_PTP_DIV_EN, GMAC_CLK_PTP_DIV_EN);
-	return ;
-}
-
-static int thead_dwmac_init(struct platform_device *pdev,
-			    void *bsp_priv)
-{
-	struct thead_dwmac *dwmac = bsp_priv;
-	int ret;
-
-	ret = thead_dwmac_set_phy_if(dwmac->plat);
-	if (ret)
-		return ret;
-
-	ret = thead_dwmac_set_txclk_dir(dwmac->plat);
-	if (ret)
-		return ret;
-
-	regmap_write(dwmac->apb_regmap, GMAC_RXCLK_DELAY_CTRL,
-		     GMAC_RXCLK_DELAY_VAL(dwmac->rx_delay));
-	regmap_write(dwmac->apb_regmap, GMAC_TXCLK_DELAY_CTRL,
-		     GMAC_TXCLK_DELAY_VAL(dwmac->tx_delay));
-
-	thead_dwmac_fix_speed(dwmac, SPEED_1000, 0);
-
-	thead_dwmac_set_ptp_clk(dwmac->plat,GMAC_PTP_CLK_RATE);
-
-	return thead_dwmac_enable_clk(dwmac->plat);
-}
-
-int thead_dwmac_clk_enable(struct platform_device *pdev, void *bsp_priv)
-{
-	struct thead_dwmac *thead_plat_dat = bsp_priv;
-	struct device *dev = &pdev->dev;
-	int ret;
-	pm_debug(dev,"enter %s()\n",__func__);
-
-	ret = clk_prepare_enable(thead_plat_dat->gmac_axi_aclk);
-	if (ret) {
-		dev_err(dev, "Failed to enable clk 'gmac_axi_aclk'\n");
-		return -EINVAL;
-	}
-	ret = clk_prepare_enable(thead_plat_dat->gmac_axi_pclk);
-	if (ret) {
-		clk_disable_unprepare(thead_plat_dat->gmac_axi_aclk);
-		dev_err(dev, "Failed to enable clk 'gmac_axi_pclk'\n");
-		return -EINVAL;
-	}
-	
-	return ret;
-}
-
-void thead_dwmac_clk_disable(struct platform_device *pdev, void *bsp_priv)
-{
-	struct thead_dwmac *thead_plat_dat = bsp_priv;
-	struct device *dev = &pdev->dev;
-	pm_debug(dev,"enter %s()\n",__func__);
-	
-	clk_disable_unprepare(thead_plat_dat->gmac_axi_aclk);
-	clk_disable_unprepare(thead_plat_dat->gmac_axi_pclk);
-
-	return ;
-}
-
-/**
- * dwmac1000_validate_mcast_bins - validates the number of Multicast filter bins
- * @dev: struct device of the platform device
- * @mcast_bins: Multicast filtering bins
- * Description:
- * this function validates the number of Multicast filtering bins specified
- * by the configuration through the device tree. The Synopsys GMAC supports
- * 64 bins, 128 bins, or 256 bins. "bins" refer to the division of CRC
- * number space. 64 bins correspond to 6 bits of the CRC, 128 corresponds
- * to 7 bits, and 256 refers to 8 bits of the CRC. Any other setting is
- * invalid and will cause the filtering algorithm to use Multicast
- * promiscuous mode.
- */
-static int dwmac1000_validate_mcast_bins(struct device *dev, int mcast_bins)
-{
-	int x = mcast_bins;
-
-	switch (x) {
-	case HASH_TABLE_SIZE:
-	case 128:
-	case 256:
-		break;
-	default:
-		x = 0;
-		dev_info(dev, "Hash table entries set to unexpected value %d\n",
-			 mcast_bins);
-		break;
-	}
-	return x;
-}
-
-/**
- * dwmac1000_validate_ucast_entries - validate the Unicast address entries
- * @dev: struct device of the platform device
- * @ucast_entries: number of Unicast address entries
- * Description:
- * This function validates the number of Unicast address entries supported
- * by a particular Synopsys 10/100/1000 controller. The Synopsys controller
- * supports 1..32, 64, or 128 Unicast filter entries for it's Unicast filter
- * logic. This function validates a valid, supported configuration is
- * selected, and defaults to 1 Unicast address if an unsupported
- * configuration is selected.
- */
-static int dwmac1000_validate_ucast_entries(struct device *dev,
-					    int ucast_entries)
-{
-	int x = ucast_entries;
-
-	switch (x) {
-	case 1 ... 32:
-	case 64:
-	case 128:
-		break;
-	default:
-		x = 1;
-		dev_info(dev, "Unicast table entries set to unexpected value %d\n",
-			 ucast_entries);
-		break;
-	}
-	return x;
-}
-
-static int thead_dwmac_probe(struct platform_device *pdev)
-{
-	struct plat_stmmacenet_data *plat;
-	struct stmmac_resources stmmac_res;
-	struct thead_dwmac *dwmac;
-	struct device_node *np = pdev->dev.of_node;
-	struct device *dev = &pdev->dev;
-	u32 delay_ps;
-	int ret;
-
-	dwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);
-	if (!dwmac)
-		return -ENOMEM;
-
-	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
-	if (ret)
-		return dev_err_probe(&pdev->dev, ret,
-				     "failed to get resources\n");
-
-	plat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
-	if (IS_ERR(plat))
-		return dev_err_probe(&pdev->dev, PTR_ERR(plat),
-				     "dt configuration failed\n");
-
-	of_property_read_u32(np, "max-frame-size", &plat->maxmtu);
-	of_property_read_u32(np, "snps,multicast-filter-bins",
-					&plat->multicast_filter_bins);
-	of_property_read_u32(np, "snps,perfect-filter-entries",
-					&plat->unicast_filter_entries);
-	plat->unicast_filter_entries = dwmac1000_validate_ucast_entries(
-			&pdev->dev, plat->unicast_filter_entries);
-	plat->multicast_filter_bins = dwmac1000_validate_mcast_bins(
-			&pdev->dev, plat->multicast_filter_bins);
-	plat->has_gmac = 1;
-	plat->pmt = 1;
-
-	if (!of_property_read_u32(np, "rx-internal-delay-ps", &delay_ps))
-		dwmac->rx_delay = delay_ps;
-	if (!of_property_read_u32(np, "tx-internal-delay-ps", &delay_ps))
-		dwmac->tx_delay = delay_ps;
-
-	dwmac->apb_regmap = syscon_regmap_lookup_by_phandle(np, "thead,gmacapb");
-	if (IS_ERR(dwmac->apb_regmap)) {
-		ret = dev_err_probe(&pdev->dev, PTR_ERR(dwmac->apb_regmap),
-				     "Failed to get gmac apb syscon\n");
-		goto err_remove_config_dt;
-	}
-	dwmac->gmac_axi_aclk = devm_clk_get(dev, "axi_aclk");
-	if (IS_ERR(dwmac->gmac_axi_aclk)) {
-		dev_err(dev, "gmac axi_aclk not exist, skipped it\n");
-	}
-	dwmac->gmac_axi_pclk = devm_clk_get(dev, "axi_pclk");
-	if (IS_ERR(dwmac->gmac_axi_pclk)) {
-		dev_err(dev, "gmac axi_pclk not exist, skipped it\n");
-	}
-
-	dwmac->dev = &pdev->dev;
-	dwmac->plat = plat;
-	plat->bsp_priv = dwmac;
-	plat->fix_mac_speed = thead_dwmac_fix_speed;
-	plat->init = thead_dwmac_init;
-
-	ret = thead_dwmac_clk_enable(pdev,dwmac);
-	if (ret)
-		goto err_remove_config_dt;
-
-	ret = thead_dwmac_init(pdev, dwmac);
-	if (ret)
-		goto err_exit;
-
-	ret = stmmac_dvr_probe(&pdev->dev, plat, &stmmac_res);
-	if (ret)
-		goto err_exit;
-	
-	return 0;
-
-err_exit:
-	dev_err(dev,"%s: dwmac probe faild,ret%d\n",__func__,ret);
-	thead_dwmac_clk_disable(pdev, dwmac);
-err_remove_config_dt:
-	stmmac_remove_config_dt(pdev, plat);
-	return ret;
-}
-/**
- * thead_dwmac_suspend
- * @dev: device pointer
- * Description: this function is invoked when suspend the driver and it direcly
- * call the main suspend function and then, if required, on some platform, it
- * can call an exit helper.
- */
-static int __maybe_unused thead_dwmac_suspend(struct device *dev)
-{
-	int ret;
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct stmmac_priv *priv = netdev_priv(ndev);
-	struct platform_device *pdev = to_platform_device(dev);
-	pm_debug(dev,"enter %s()\n",__func__);
-	ret = stmmac_suspend(dev);
-	if (priv->plat->exit)
-		priv->plat->exit(pdev, priv->plat->bsp_priv);
-	
-	return ret;
-}
-
-/**
- * thead_dwmac_resume
- * @dev: device pointer
- * Description: this function is invoked when resume the driver before calling
- * the main resume function, on some platforms, it can call own init helper
- * if required.
- */
-static int __maybe_unused thead_dwmac_resume(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct stmmac_priv *priv = netdev_priv(ndev);
-	struct platform_device *pdev = to_platform_device(dev);
-	pm_debug(dev,"enter %s()\n",__func__);
-
-	pm_runtime_get_sync(dev);
-	if (priv->plat->init)
-		priv->plat->init(pdev, priv->plat->bsp_priv);
-	pm_runtime_put(dev);
-
-	return stmmac_resume(dev);
-}
-
-static int __maybe_unused thead_dwmac_runtime_suspend(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct stmmac_priv *priv = netdev_priv(ndev);
-	struct platform_device *pdev = to_platform_device(dev);
-	pm_debug(dev,"enter %s()\n",__func__);
-	stmmac_bus_clks_config(priv, false);
-	thead_dwmac_clk_disable(pdev, priv->plat->bsp_priv);
-	return 0;
-}
-
-static int __maybe_unused thead_dwmac_runtime_resume(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct stmmac_priv *priv = netdev_priv(ndev);
-	struct platform_device *pdev = to_platform_device(dev);
-	int ret;
-	pm_debug(dev,"enter %s()\n",__func__);
-	ret = stmmac_bus_clks_config(priv, true);
-	if(ret)
-		return ret;
-	ret = thead_dwmac_clk_enable(pdev, priv->plat->bsp_priv);
-	if(ret)
-		return ret;
-
-	return 0;
-}
-
-static int __maybe_unused thead_dwmac_noirq_suspend(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct stmmac_priv *priv = netdev_priv(ndev);
-	int ret;
-	pm_debug(dev,"enter %s()\n",__func__);
-	if (!netif_running(ndev))
-		return 0;
-
-	if (!device_may_wakeup(priv->device) || !priv->plat->pmt) {
-		/* Disable clock in case of PWM is off */
-		clk_disable_unprepare(priv->plat->clk_ptp_ref);
-
-		ret = pm_runtime_force_suspend(dev);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int __maybe_unused thead_dwmac_noirq_resume(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-	struct stmmac_priv *priv = netdev_priv(ndev);
-	int ret;
-	pm_debug(dev,"enter %s()\n",__func__);
-	if (!netif_running(ndev))
-		return 0;
-
-	if (!device_may_wakeup(priv->device) || !priv->plat->pmt) {
-		/* enable the clk previously disabled */
-		ret = pm_runtime_force_resume(dev);
-		if (ret)
-			return ret;
-
-		ret = clk_prepare_enable(priv->plat->clk_ptp_ref);
-		if (ret < 0) {
-			netdev_warn(priv->dev,
-				    "failed to enable PTP reference clock: %pe\n",
-				    ERR_PTR(ret));
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-/*similar with stmmac_pltfr_pm_ops,but clks enable/disable add this drv need */
-const struct dev_pm_ops thead_dwmac_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(thead_dwmac_suspend, thead_dwmac_resume)
-	SET_RUNTIME_PM_OPS(thead_dwmac_runtime_suspend, thead_dwmac_runtime_resume, NULL)
-	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(thead_dwmac_noirq_suspend, thead_dwmac_noirq_resume)
-};
-
-static const struct of_device_id thead_dwmac_match[] = {
-	{ .compatible = "thead,th1520-dwmac" },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, thead_dwmac_match);
-
-static struct platform_driver thead_dwmac_driver = {
-	.probe = thead_dwmac_probe,
-	.remove_new = stmmac_pltfr_remove,
-	.driver = {
-		.name = "thead-dwmac",
-		.pm = &thead_dwmac_pm_ops,
-		.of_match_table = thead_dwmac_match,
-	},
-};
-module_platform_driver(thead_dwmac_driver);
-
-MODULE_AUTHOR("T-HEAD");
-MODULE_AUTHOR("Jisheng Zhang <jszhang@kernel.org>");
-MODULE_DESCRIPTION("T-HEAD dwmac platform driver");
-MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-xuantie.c
@@ -0,0 +1,584 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * XuanTie DWMAC platform driver
+ *
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ * Copyright (C) 2023 Jisheng Zhang <jszhang@kernel.org>
+ *
+ */
+
+#include <linux/bitfield.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_net.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/pm_runtime.h>
+
+#include "stmmac_platform.h"
+
+#define GMAC_CLK_EN			0x00
+#define  GMAC_TX_CLK_EN			BIT(1)
+#define  GMAC_TX_CLK_N_EN		BIT(2)
+#define  GMAC_TX_CLK_OUT_EN		BIT(3)
+#define  GMAC_RX_CLK_EN			BIT(4)
+#define  GMAC_RX_CLK_N_EN		BIT(5)
+#define  GMAC_EPHY_REF_CLK_EN		BIT(6)
+#define GMAC_RXCLK_DELAY_CTRL		0x04
+#define  GMAC_RXCLK_BYPASS		BIT(15)
+#define  GMAC_RXCLK_INVERT		BIT(14)
+#define  GMAC_RXCLK_DELAY_MASK		GENMASK(4, 0)
+#define  GMAC_RXCLK_DELAY_VAL(x)	FIELD_PREP(GMAC_RXCLK_DELAY_MASK, (x))
+#define GMAC_TXCLK_DELAY_CTRL		0x08
+#define  GMAC_TXCLK_BYPASS		BIT(15)
+#define  GMAC_TXCLK_INVERT		BIT(14)
+#define  GMAC_TXCLK_DELAY_MASK		GENMASK(4, 0)
+#define  GMAC_TXCLK_DELAY_VAL(x)	FIELD_PREP(GMAC_RXCLK_DELAY_MASK, (x))
+#define GMAC_PLLCLK_DIV			0x0c
+#define  GMAC_PLLCLK_DIV_EN		BIT(31)
+#define  GMAC_PLLCLK_DIV_MASK		GENMASK(7, 0)
+#define  GMAC_PLLCLK_DIV_NUM(x)		FIELD_PREP(GMAC_PLLCLK_DIV_MASK, (x))
+#define GMAC_CLK_PTP			0x14
+#define  GMAC_CLK_PTP_DIV_EN		BIT(31)
+#define  GMAC_CLK_PTP_DIV_MASK		GENMASK(7, 0)
+#define  GMAC_CLK_PTP_DIV_NUM(x)	FIELD_PREP(GMAC_CLK_PTP_DIV_MASK, (x))
+#define GMAC_GTXCLK_SEL			0x18
+#define  GMAC_GTXCLK_SEL_PLL		BIT(0)
+#define GMAC_INTF_CTRL			0x1c
+#define  PHY_INTF_MASK			BIT(0)
+#define  PHY_INTF_RGMII			FIELD_PREP(PHY_INTF_MASK, 1)
+#define  PHY_INTF_MII_GMII		FIELD_PREP(PHY_INTF_MASK, 0)
+#define GMAC_TXCLK_OEN			0x20
+#define  TXCLK_DIR_MASK			BIT(0)
+#define  TXCLK_DIR_OUTPUT		FIELD_PREP(TXCLK_DIR_MASK, 0)
+#define  TXCLK_DIR_INPUT		FIELD_PREP(TXCLK_DIR_MASK, 1)
+
+#define GMAC_GMII_RGMII_RATE	125000000
+#define GMAC_MII_RATE		25000000
+#define GMAC_PTP_CLK_RATE	50000000 //50MHz
+
+struct th1520_dwmac {
+	struct plat_stmmacenet_data *plat;
+	struct regmap *apb_regmap;
+	struct device *dev;
+	u32 rx_delay;
+	u32 tx_delay;
+	struct clk *gmac_axi_aclk;
+	struct clk *gmac_axi_pclk;
+};
+
+#define  pm_debug dev_dbg	/* for suspend/resume interface debug info */
+
+static int th1520_dwmac_set_phy_if(struct plat_stmmacenet_data *plat)
+{
+	struct th1520_dwmac *dwmac = plat->bsp_priv;
+	u32 phyif;
+
+	switch (plat->mac_interface) {
+	case PHY_INTERFACE_MODE_MII:
+		phyif = PHY_INTF_MII_GMII;
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+		phyif = PHY_INTF_RGMII;
+		break;
+	default:
+		dev_err(dwmac->dev, "unsupported phy interface %d\n",
+			plat->mac_interface);
+		return -EINVAL;
+	};
+
+	regmap_write(dwmac->apb_regmap, GMAC_INTF_CTRL, phyif);
+
+	return 0;
+}
+
+static int th1520_dwmac_set_txclk_dir(struct plat_stmmacenet_data *plat)
+{
+	struct th1520_dwmac *dwmac = plat->bsp_priv;
+	u32 txclk_dir;
+
+	switch (plat->mac_interface) {
+	case PHY_INTERFACE_MODE_MII:
+		txclk_dir = TXCLK_DIR_INPUT;
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+		txclk_dir = TXCLK_DIR_OUTPUT;
+		break;
+	default:
+		dev_err(dwmac->dev, "unsupported phy interface %d\n",
+			plat->mac_interface);
+		return -EINVAL;
+	};
+
+	regmap_write(dwmac->apb_regmap, GMAC_TXCLK_OEN, txclk_dir);
+
+	return 0;
+}
+
+static void th1520_dwmac_fix_speed(void *priv, unsigned int speed, unsigned int mode)
+{
+	struct th1520_dwmac *dwmac = priv;
+	struct plat_stmmacenet_data *plat = dwmac->plat;
+	unsigned long rate;
+	u32 div;
+
+	switch (plat->mac_interface) {
+	/* For MII, rxc/txc is provided by phy */
+	case PHY_INTERFACE_MODE_MII:
+		return;
+
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		rate = clk_get_rate(plat->stmmac_clk);
+		if (!rate || rate % GMAC_GMII_RGMII_RATE != 0 ||
+		    rate % GMAC_MII_RATE != 0) {
+			dev_err(dwmac->dev, "invalid gmac rate %ld\n", rate);
+			return;
+		}
+
+		regmap_update_bits(dwmac->apb_regmap, GMAC_PLLCLK_DIV, GMAC_PLLCLK_DIV_EN, 0);
+
+		switch (speed) {
+		case SPEED_1000:
+			div = rate / GMAC_GMII_RGMII_RATE;
+			break;
+		case SPEED_100:
+			div = rate / GMAC_MII_RATE;
+			break;
+		case SPEED_10:
+			div = rate * 10 / GMAC_MII_RATE;
+			break;
+		default:
+			dev_err(dwmac->dev, "invalid speed %u\n", speed);
+			return;
+		}
+		regmap_update_bits(dwmac->apb_regmap, GMAC_PLLCLK_DIV,
+				   GMAC_PLLCLK_DIV_MASK, GMAC_PLLCLK_DIV_NUM(div));
+
+		regmap_update_bits(dwmac->apb_regmap, GMAC_PLLCLK_DIV,
+				   GMAC_PLLCLK_DIV_EN, GMAC_PLLCLK_DIV_EN);
+		break;
+	default:
+		dev_err(dwmac->dev, "unsupported phy interface %d\n",
+			plat->mac_interface);
+		return;
+	}
+}
+
+static int th1520_dwmac_enable_clk(struct plat_stmmacenet_data *plat)
+{
+	struct th1520_dwmac *dwmac = plat->bsp_priv;
+	u32 reg;
+
+	switch (plat->mac_interface) {
+	case PHY_INTERFACE_MODE_MII:
+		reg = GMAC_RX_CLK_EN | GMAC_TX_CLK_EN;
+		break;
+
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		/* use pll */
+		regmap_write(dwmac->apb_regmap, GMAC_GTXCLK_SEL, GMAC_GTXCLK_SEL_PLL);
+
+		reg = GMAC_TX_CLK_EN | GMAC_TX_CLK_N_EN | GMAC_TX_CLK_OUT_EN |
+		      GMAC_RX_CLK_EN | GMAC_RX_CLK_N_EN;
+		break;
+
+	default:
+		dev_err(dwmac->dev, "unsupported phy interface %d\n",
+			plat->mac_interface);
+		return -EINVAL;
+	}
+
+	regmap_write(dwmac->apb_regmap, GMAC_CLK_EN, reg);
+
+	return 0;
+}
+
+static void th1520_dwmac_set_ptp_clk(struct plat_stmmacenet_data *plat_dat, unsigned int ptp_clk_rate)
+{
+	unsigned int div;
+	struct th1520_dwmac *dwmac = plat_dat->bsp_priv;
+
+	unsigned long src_freq = clk_get_rate(plat_dat->stmmac_clk);
+
+	if(!ptp_clk_rate || !src_freq)
+	{
+		pr_warn("invalid gmac pll freq %lu or ptp_clk_rate %d\n", src_freq,ptp_clk_rate);
+		return;
+	}
+	/* disable clk_div */
+	regmap_update_bits(dwmac->apb_regmap, GMAC_CLK_PTP, GMAC_CLK_PTP_DIV_EN, 0);
+
+	div = src_freq / ptp_clk_rate;
+	regmap_update_bits(dwmac->apb_regmap, GMAC_CLK_PTP,
+			GMAC_CLK_PTP_DIV_MASK, GMAC_CLK_PTP_DIV_NUM(div));
+
+	/* enable clk_div */
+	regmap_update_bits(dwmac->apb_regmap, GMAC_CLK_PTP,
+			GMAC_CLK_PTP_DIV_EN, GMAC_CLK_PTP_DIV_EN);
+	return ;
+}
+
+static int th1520_dwmac_init(struct platform_device *pdev, void *bsp_priv)
+{
+	struct th1520_dwmac *dwmac = bsp_priv;
+	int ret;
+
+	ret = th1520_dwmac_set_phy_if(dwmac->plat);
+	if (ret)
+		return ret;
+
+	ret = th1520_dwmac_set_txclk_dir(dwmac->plat);
+	if (ret)
+		return ret;
+
+	regmap_write(dwmac->apb_regmap, GMAC_RXCLK_DELAY_CTRL,
+		     GMAC_RXCLK_DELAY_VAL(dwmac->rx_delay));
+	regmap_write(dwmac->apb_regmap, GMAC_TXCLK_DELAY_CTRL,
+		     GMAC_TXCLK_DELAY_VAL(dwmac->tx_delay));
+
+	th1520_dwmac_fix_speed(dwmac, SPEED_1000, 0);
+
+	th1520_dwmac_set_ptp_clk(dwmac->plat, GMAC_PTP_CLK_RATE);
+
+	return th1520_dwmac_enable_clk(dwmac->plat);
+}
+
+int th1520_dwmac_clk_enable(struct platform_device *pdev, void *bsp_priv)
+{
+	struct th1520_dwmac *th1520_plat_dat = bsp_priv;
+	struct device *dev = &pdev->dev;
+	int ret;
+	pm_debug(dev,"enter %s()\n",__func__);
+
+	ret = clk_prepare_enable(th1520_plat_dat->gmac_axi_aclk);
+	if (ret) {
+		dev_err(dev, "Failed to enable clk 'gmac_axi_aclk'\n");
+		return -EINVAL;
+	}
+	ret = clk_prepare_enable(th1520_plat_dat->gmac_axi_pclk);
+	if (ret) {
+		clk_disable_unprepare(th1520_plat_dat->gmac_axi_aclk);
+		dev_err(dev, "Failed to enable clk 'gmac_axi_pclk'\n");
+		return -EINVAL;
+	}
+	
+	return ret;
+}
+
+void th1520_dwmac_clk_disable(struct platform_device *pdev, void *bsp_priv)
+{
+	struct th1520_dwmac *th1520_plat_dat = bsp_priv;
+	struct device *dev = &pdev->dev;
+	pm_debug(dev,"enter %s()\n",__func__);
+	
+	clk_disable_unprepare(th1520_plat_dat->gmac_axi_aclk);
+	clk_disable_unprepare(th1520_plat_dat->gmac_axi_pclk);
+
+	return ;
+}
+
+/**
+ * dwmac1000_validate_mcast_bins - validates the number of Multicast filter bins
+ * @dev: struct device of the platform device
+ * @mcast_bins: Multicast filtering bins
+ * Description:
+ * this function validates the number of Multicast filtering bins specified
+ * by the configuration through the device tree. The Synopsys GMAC supports
+ * 64 bins, 128 bins, or 256 bins. "bins" refer to the division of CRC
+ * number space. 64 bins correspond to 6 bits of the CRC, 128 corresponds
+ * to 7 bits, and 256 refers to 8 bits of the CRC. Any other setting is
+ * invalid and will cause the filtering algorithm to use Multicast
+ * promiscuous mode.
+ */
+static int dwmac1000_validate_mcast_bins(struct device *dev, int mcast_bins)
+{
+	int x = mcast_bins;
+
+	switch (x) {
+	case HASH_TABLE_SIZE:
+	case 128:
+	case 256:
+		break;
+	default:
+		x = 0;
+		dev_info(dev, "Hash table entries set to unexpected value %d\n",
+			 mcast_bins);
+		break;
+	}
+	return x;
+}
+
+/**
+ * dwmac1000_validate_ucast_entries - validate the Unicast address entries
+ * @dev: struct device of the platform device
+ * @ucast_entries: number of Unicast address entries
+ * Description:
+ * This function validates the number of Unicast address entries supported
+ * by a particular Synopsys 10/100/1000 controller. The Synopsys controller
+ * supports 1..32, 64, or 128 Unicast filter entries for it's Unicast filter
+ * logic. This function validates a valid, supported configuration is
+ * selected, and defaults to 1 Unicast address if an unsupported
+ * configuration is selected.
+ */
+static int dwmac1000_validate_ucast_entries(struct device *dev,
+					    int ucast_entries)
+{
+	int x = ucast_entries;
+
+	switch (x) {
+	case 1 ... 32:
+	case 64:
+	case 128:
+		break;
+	default:
+		x = 1;
+		dev_info(dev, "Unicast table entries set to unexpected value %d\n",
+			 ucast_entries);
+		break;
+	}
+	return x;
+}
+
+static int th1520_dwmac_probe(struct platform_device *pdev)
+{
+	struct plat_stmmacenet_data *plat;
+	struct stmmac_resources stmmac_res;
+	struct th1520_dwmac *dwmac;
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	u32 delay_ps;
+	int ret;
+
+	dwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);
+	if (!dwmac)
+		return -ENOMEM;
+
+	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret,
+				     "failed to get resources\n");
+
+	plat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
+	if (IS_ERR(plat))
+		return dev_err_probe(&pdev->dev, PTR_ERR(plat),
+				     "dt configuration failed\n");
+
+	of_property_read_u32(np, "max-frame-size", &plat->maxmtu);
+	of_property_read_u32(np, "snps,multicast-filter-bins",
+					&plat->multicast_filter_bins);
+	of_property_read_u32(np, "snps,perfect-filter-entries",
+					&plat->unicast_filter_entries);
+	plat->unicast_filter_entries = dwmac1000_validate_ucast_entries(
+			&pdev->dev, plat->unicast_filter_entries);
+	plat->multicast_filter_bins = dwmac1000_validate_mcast_bins(
+			&pdev->dev, plat->multicast_filter_bins);
+	plat->has_gmac = 1;
+	plat->pmt = 1;
+
+	if (!of_property_read_u32(np, "rx-internal-delay-ps", &delay_ps))
+		dwmac->rx_delay = delay_ps;
+	if (!of_property_read_u32(np, "tx-internal-delay-ps", &delay_ps))
+		dwmac->tx_delay = delay_ps;
+
+	dwmac->apb_regmap = syscon_regmap_lookup_by_phandle(np, "th1520,gmacapb");
+	if (IS_ERR(dwmac->apb_regmap)) {
+		ret = dev_err_probe(&pdev->dev, PTR_ERR(dwmac->apb_regmap),
+				     "Failed to get gmac apb syscon\n");
+		goto err_remove_config_dt;
+	}
+	dwmac->gmac_axi_aclk = devm_clk_get(dev, "axi_aclk");
+	if (IS_ERR(dwmac->gmac_axi_aclk)) {
+		dev_err(dev, "gmac axi_aclk not exist, skipped it\n");
+	}
+	dwmac->gmac_axi_pclk = devm_clk_get(dev, "axi_pclk");
+	if (IS_ERR(dwmac->gmac_axi_pclk)) {
+		dev_err(dev, "gmac axi_pclk not exist, skipped it\n");
+	}
+
+	dwmac->dev = &pdev->dev;
+	dwmac->plat = plat;
+	plat->bsp_priv = dwmac;
+	plat->fix_mac_speed = th1520_dwmac_fix_speed;
+	plat->init = th1520_dwmac_init;
+
+	ret = th1520_dwmac_clk_enable(pdev, dwmac);
+	if (ret)
+		goto err_remove_config_dt;
+
+	ret = th1520_dwmac_init(pdev, dwmac);
+	if (ret)
+		goto err_exit;
+
+	ret = stmmac_dvr_probe(&pdev->dev, plat, &stmmac_res);
+	if (ret)
+		goto err_exit;
+	
+	return 0;
+
+err_exit:
+	dev_err(dev,"%s: dwmac probe faild,ret%d\n",__func__,ret);
+	th1520_dwmac_clk_disable(pdev, dwmac);
+err_remove_config_dt:
+	stmmac_remove_config_dt(pdev, plat);
+	return ret;
+}
+/**
+ * th1520_dwmac_suspend
+ * @dev: device pointer
+ * Description: this function is invoked when suspend the driver and it direcly
+ * call the main suspend function and then, if required, on some platform, it
+ * can call an exit helper.
+ */
+static int __maybe_unused th1520_dwmac_suspend(struct device *dev)
+{
+	int ret;
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	struct platform_device *pdev = to_platform_device(dev);
+	pm_debug(dev,"enter %s()\n",__func__);
+	ret = stmmac_suspend(dev);
+	if (priv->plat->exit)
+		priv->plat->exit(pdev, priv->plat->bsp_priv);
+	
+	return ret;
+}
+
+/**
+ * th1520_dwmac_resume
+ * @dev: device pointer
+ * Description: this function is invoked when resume the driver before calling
+ * the main resume function, on some platforms, it can call own init helper
+ * if required.
+ */
+static int __maybe_unused th1520_dwmac_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	struct platform_device *pdev = to_platform_device(dev);
+	pm_debug(dev,"enter %s()\n",__func__);
+
+	pm_runtime_get_sync(dev);
+	if (priv->plat->init)
+		priv->plat->init(pdev, priv->plat->bsp_priv);
+	pm_runtime_put(dev);
+
+	return stmmac_resume(dev);
+}
+
+static int __maybe_unused th1520_dwmac_runtime_suspend(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	struct platform_device *pdev = to_platform_device(dev);
+	pm_debug(dev,"enter %s()\n",__func__);
+	stmmac_bus_clks_config(priv, false);
+	th1520_dwmac_clk_disable(pdev, priv->plat->bsp_priv);
+	return 0;
+}
+
+static int __maybe_unused th1520_dwmac_runtime_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	struct platform_device *pdev = to_platform_device(dev);
+	int ret;
+	pm_debug(dev,"enter %s()\n",__func__);
+	ret = stmmac_bus_clks_config(priv, true);
+	if(ret)
+		return ret;
+	ret = th1520_dwmac_clk_enable(pdev, priv->plat->bsp_priv);
+	if(ret)
+		return ret;
+
+	return 0;
+}
+
+static int __maybe_unused th1520_dwmac_noirq_suspend(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	int ret;
+	pm_debug(dev,"enter %s()\n",__func__);
+	if (!netif_running(ndev))
+		return 0;
+
+	if (!device_may_wakeup(priv->device) || !priv->plat->pmt) {
+		/* Disable clock in case of PWM is off */
+		clk_disable_unprepare(priv->plat->clk_ptp_ref);
+
+		ret = pm_runtime_force_suspend(dev);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int __maybe_unused th1520_dwmac_noirq_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	int ret;
+	pm_debug(dev,"enter %s()\n",__func__);
+	if (!netif_running(ndev))
+		return 0;
+
+	if (!device_may_wakeup(priv->device) || !priv->plat->pmt) {
+		/* enable the clk previously disabled */
+		ret = pm_runtime_force_resume(dev);
+		if (ret)
+			return ret;
+
+		ret = clk_prepare_enable(priv->plat->clk_ptp_ref);
+		if (ret < 0) {
+			netdev_warn(priv->dev,
+				    "failed to enable PTP reference clock: %pe\n",
+				    ERR_PTR(ret));
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/*similar with stmmac_pltfr_pm_ops,but clks enable/disable add this drv need */
+const struct dev_pm_ops th1520_dwmac_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(th1520_dwmac_suspend, th1520_dwmac_resume)
+	SET_RUNTIME_PM_OPS(th1520_dwmac_runtime_suspend, th1520_dwmac_runtime_resume, NULL)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(th1520_dwmac_noirq_suspend, th1520_dwmac_noirq_resume)
+};
+
+static const struct of_device_id th1520_dwmac_match[] = {
+	{ .compatible = "xuantie,th1520-dwmac" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, th1520_dwmac_match);
+
+static struct platform_driver th1520_dwmac_driver = {
+	.probe = th1520_dwmac_probe,
+	.remove_new = stmmac_pltfr_remove,
+	.driver = {
+		.name = "th1520-dwmac",
+		.pm = &th1520_dwmac_pm_ops,
+		.of_match_table = th1520_dwmac_match,
+	},
+};
+module_platform_driver(th1520_dwmac_driver);
+
+MODULE_AUTHOR("Jisheng Zhang <jszhang@kernel.org>");
+MODULE_DESCRIPTION("XuanTie TH1520 dwmac platform driver");
+MODULE_LICENSE("GPL");
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -637,7 +637,7 @@ config PWM_TEGRA
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-tegra.
 
-config PWM_THEAD
+config PWM_XUANTIE
 	tristate "XuanTie PWM support"
 	depends on ARCH_XUANTIE || COMPILE_TEST
 	depends on HAS_IOMEM
@@ -646,7 +646,7 @@ config PWM_THEAD
 	  SoCs.
 
 	  To compile this driver as a module, choose M here: the module
-	  will be called pwm-thead.
+	  will be called pwm-xuantie.
 
 config PWM_TIECAP
 	tristate "ECAP PWM support"
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -59,7 +59,7 @@ obj-$(CONFIG_PWM_STMPE)		+= pwm-stmpe.o
 obj-$(CONFIG_PWM_SUN4I)		+= pwm-sun4i.o
 obj-$(CONFIG_PWM_SUNPLUS)	+= pwm-sunplus.o
 obj-$(CONFIG_PWM_TEGRA)		+= pwm-tegra.o
-obj-$(CONFIG_PWM_THEAD)		+= pwm-thead.o
+obj-$(CONFIG_PWM_XUANTIE)	+= pwm-xuantie.o
 obj-$(CONFIG_PWM_TIECAP)	+= pwm-tiecap.o
 obj-$(CONFIG_PWM_TIEHRPWM)	+= pwm-tiehrpwm.o
 obj-$(CONFIG_PWM_TWL)		+= pwm-twl.o
--- a/drivers/pwm/pwm-thead.c
+++ /dev/null
@@ -1,269 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * T-HEAD PWM driver
- *
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- * Copyright (C) 2023 Jisheng Zhang <jszhang@kernel.org>
- *
- * Limitations:
- * - The THEAD_PWM_CTRL_START bit is only effective when 0 -> 1, which is used
- *   to start the channel, 1 -> 0 doesn't change anything. so 0 % duty cycle
- *   is used to "disable" the channel.
- * - The THEAD_PWM_CTRL_START bit is automatically cleared once PWM channel is
- *   started.
- * - The THEAD_PWM_CFG_UPDATE atomically updates and only updates period and duty.
- * - To update period and duty, THEAD_PWM_CFG_UPDATE needs to go through 0 -> 1
- *   step, I.E if THEAD_PWM_CFG_UPDATE is already 1, it's necessary to clear it
- *   to 0 beforehand.
- * - Polarity can only be changed if never started before.
- */
-
-#include <linux/bitfield.h>
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/mod_devicetable.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/pwm.h>
-#include <linux/slab.h>
-
-#define THEAD_PWM_MAX_NUM		6
-#define THEAD_PWM_MAX_PERIOD		GENMASK(31, 0)
-#define THEAD_PWM_MAX_DUTY		GENMASK(31, 0)
-
-#define THEAD_PWM_CHN_BASE(n)		((n) * 0x20)
-#define THEAD_PWM_CTRL(n)		(THEAD_PWM_CHN_BASE(n) + 0x00)
-#define  THEAD_PWM_CTRL_START		BIT(0)
-#define  THEAD_PWM_CTRL_SOFT_RST		BIT(1)
-#define  THEAD_PWM_CTRL_CFG_UPDATE	BIT(2)
-#define  THEAD_PWM_CTRL_INTEN		BIT(3)
-#define  THEAD_PWM_CTRL_MODE		GENMASK(5, 4)
-#define  THEAD_PWM_CTRL_MODE_CONTINUOUS	FIELD_PREP(THEAD_PWM_CTRL_MODE, 2)
-#define  THEAD_PWM_CTRL_EVTRIG		GENMASK(7, 6)
-#define  THEAD_PWM_CTRL_FPOUT		BIT(8)
-#define  THEAD_PWM_CTRL_INFACTOUT	BIT(9)
-#define THEAD_PWM_RPT(n)		(THEAD_PWM_CHN_BASE(n) + 0x04)
-#define THEAD_PWM_PER(n)		(THEAD_PWM_CHN_BASE(n) + 0x08)
-#define THEAD_PWM_FP(n)			(THEAD_PWM_CHN_BASE(n) + 0x0c)
-#define THEAD_PWM_STATUS(n)		(THEAD_PWM_CHN_BASE(n) + 0x10)
-#define  THEAD_PWM_STATUS_CYCLE		GENMASK(7, 0)
-
-struct thead_pwm_chip {
-	struct pwm_chip chip;
-	void __iomem *mmio_base;
-	struct clk *clk;
-	u8 channel_ever_started;
-};
-
-static inline struct thead_pwm_chip *thead_pwm_from_chip(struct pwm_chip *chip)
-{
-	return container_of(chip, struct thead_pwm_chip, chip);
-}
-
-static int thead_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
-			   const struct pwm_state *state)
-{
-	struct thead_pwm_chip *priv = thead_pwm_from_chip(chip);
-	u32 val = THEAD_PWM_CTRL_INFACTOUT | THEAD_PWM_CTRL_FPOUT | THEAD_PWM_CTRL_MODE_CONTINUOUS;
-	u64 period_cycle, duty_cycle, rate;
-	int ret;
-
-	/* if ever started, can't change the polarity */
-	if ((priv->channel_ever_started & (1 << pwm->hwpwm)) &&
-	    state->polarity != pwm->state.polarity)
-		return -EINVAL;
-
-	if (!state->enabled) {
-		if (pwm->state.enabled) {
-			val = readl(priv->mmio_base + THEAD_PWM_CTRL(pwm->hwpwm));
-			val &= ~THEAD_PWM_CTRL_CFG_UPDATE;
-			writel(val, priv->mmio_base + THEAD_PWM_CTRL(pwm->hwpwm));
-
-			writel(0, priv->mmio_base + THEAD_PWM_FP(pwm->hwpwm));
-
-			val |= THEAD_PWM_CTRL_CFG_UPDATE;
-			writel(val, priv->mmio_base + THEAD_PWM_CTRL(pwm->hwpwm));
-			pm_runtime_put_sync(chip->dev);
-		}
-		return 0;
-	}
-
-	if (!pwm->state.enabled) {
-		ret = pm_runtime_resume_and_get(chip->dev);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (state->polarity == PWM_POLARITY_INVERSED)
-		val &= ~THEAD_PWM_CTRL_FPOUT;
-
-	writel(val, priv->mmio_base + THEAD_PWM_CTRL(pwm->hwpwm));
-
-	rate = clk_get_rate(priv->clk);
-	/*
-	 * The following calculations might overflow if clk is bigger
-	 * than 1 GHz. In practise it's 24MHz, so this limitation
-	 * is only theoretic.
-	 */
-	if (rate > NSEC_PER_SEC)
-		return -EINVAL;
-
-	period_cycle = mul_u64_u64_div_u64(rate, state->period, NSEC_PER_SEC);
-	if (period_cycle > THEAD_PWM_MAX_PERIOD)
-		period_cycle = THEAD_PWM_MAX_PERIOD;
-	/*
-	 * With limitation above we have period_cycle <= THEAD_PWM_MAX_PERIOD,
-	 * so this cannot overflow.
-	 */
-	writel(period_cycle, priv->mmio_base + THEAD_PWM_PER(pwm->hwpwm));
-
-	duty_cycle = mul_u64_u64_div_u64(rate, state->duty_cycle, NSEC_PER_SEC);
-	if (duty_cycle > THEAD_PWM_MAX_DUTY)
-		duty_cycle = THEAD_PWM_MAX_DUTY;
-	/*
-	 * With limitation above we have duty_cycle <= THEAD_PWM_MAX_DUTY,
-	 * so this cannot overflow.
-	 */
-	writel(duty_cycle, priv->mmio_base + THEAD_PWM_FP(pwm->hwpwm));
-
-	val |= THEAD_PWM_CTRL_CFG_UPDATE;
-	writel(val, priv->mmio_base + THEAD_PWM_CTRL(pwm->hwpwm));
-
-	if (!pwm->state.enabled) {
-		val |= THEAD_PWM_CTRL_START;
-		writel(val, priv->mmio_base + THEAD_PWM_CTRL(pwm->hwpwm));
-		priv->channel_ever_started |= 1 << pwm->hwpwm;
-	}
-
-	return 0;
-}
-
-static int thead_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
-			       struct pwm_state *state)
-{
-	struct thead_pwm_chip *priv = thead_pwm_from_chip(chip);
-	u64 rate = clk_get_rate(priv->clk);
-	u32 val;
-	int ret;
-
-	ret = pm_runtime_resume_and_get(chip->dev);
-	if (ret < 0)
-		return ret;
-
-	val = readl(priv->mmio_base + THEAD_PWM_CTRL(pwm->hwpwm));
-	if (val & THEAD_PWM_CTRL_FPOUT)
-		state->polarity = PWM_POLARITY_NORMAL;
-	else
-		state->polarity = PWM_POLARITY_INVERSED;
-
-	val = readl(priv->mmio_base + THEAD_PWM_PER(pwm->hwpwm));
-	/*
-	 * val 32 bits, multiply NSEC_PER_SEC, won't overflow.
-	 */
-	state->period = DIV64_U64_ROUND_UP((u64)val * NSEC_PER_SEC, rate);
-
-	val = readl(priv->mmio_base + THEAD_PWM_FP(pwm->hwpwm));
-	state->enabled = !!val;
-	/*
-	 * val 32 bits, multiply NSEC_PER_SEC, won't overflow.
-	 */
-	state->duty_cycle = DIV64_U64_ROUND_UP((u64)val * NSEC_PER_SEC, rate);
-
-	pm_runtime_put_sync(chip->dev);
-
-	return 0;
-}
-
-static const struct pwm_ops thead_pwm_ops = {
-	.apply = thead_pwm_apply,
-	.get_state = thead_pwm_get_state,
-};
-
-static int __maybe_unused thead_pwm_runtime_suspend(struct device *dev)
-{
-	struct thead_pwm_chip *priv = dev_get_drvdata(dev);
-
-	clk_disable_unprepare(priv->clk);
-
-	return 0;
-}
-
-static int __maybe_unused thead_pwm_runtime_resume(struct device *dev)
-{
-	struct thead_pwm_chip *priv = dev_get_drvdata(dev);
-	int ret;
-
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
-		dev_err(dev, "failed to enable pwm clock(%pe)\n", ERR_PTR(ret));
-
-	return ret;
-}
-
-static int thead_pwm_probe(struct platform_device *pdev)
-{
-	struct thead_pwm_chip *priv;
-	int ret, i;
-	u32 val;
-
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, priv);
-
-	priv->mmio_base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(priv->mmio_base))
-		return PTR_ERR(priv->mmio_base);
-
-	priv->clk = devm_clk_get_enabled(&pdev->dev, NULL);
-	if (IS_ERR(priv->clk))
-		return PTR_ERR(priv->clk);
-
-	priv->chip.ops = &thead_pwm_ops;
-	priv->chip.dev = &pdev->dev;
-	priv->chip.npwm = THEAD_PWM_MAX_NUM;
-
-	/* check whether PWM is ever started or not */
-	for (i = 0; i < priv->chip.npwm; i++) {
-		val = readl(priv->mmio_base + THEAD_PWM_FP(i));
-		if (val)
-			priv->channel_ever_started |= 1 << i;
-	}
-
-	ret = devm_pwmchip_add(&pdev->dev, &priv->chip);
-	if (ret)
-		return ret;
-
-	devm_pm_runtime_enable(&pdev->dev);
-
-	return 0;
-}
-
-static const struct of_device_id thead_pwm_dt_ids[] = {
-	{.compatible = "thead,th1520-pwm",},
-	{/* sentinel */}
-};
-MODULE_DEVICE_TABLE(of, thead_pwm_dt_ids);
-
-static const struct dev_pm_ops thead_pwm_pm_ops = {
-	SET_RUNTIME_PM_OPS(thead_pwm_runtime_suspend, thead_pwm_runtime_resume, NULL)
-};
-
-static struct platform_driver thead_pwm_driver = {
-	.driver = {
-		.name = "thead-pwm",
-		.of_match_table = thead_pwm_dt_ids,
-		.pm = &thead_pwm_pm_ops,
-	},
-	.probe = thead_pwm_probe,
-};
-module_platform_driver(thead_pwm_driver);
-
-MODULE_AUTHOR("Wei Liu <lw312886@linux.alibaba.com>");
-MODULE_AUTHOR("Jisheng Zhang <jszhang@kernel.org>");
-MODULE_DESCRIPTION("T-HEAD pwm driver");
-MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/pwm/pwm-xuantie.c
@@ -0,0 +1,269 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * XuanTie PWM driver
+ *
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ * Copyright (C) 2023 Jisheng Zhang <jszhang@kernel.org>
+ *
+ * Limitations:
+ * - The XUANTIE_PWM_CTRL_START bit is only effective when 0 -> 1, which is used
+ *   to start the channel, 1 -> 0 doesn't change anything. so 0 % duty cycle
+ *   is used to "disable" the channel.
+ * - The XUANTIE_PWM_CTRL_START bit is automatically cleared once PWM channel is
+ *   started.
+ * - The XUANTIE_PWM_CFG_UPDATE atomically updates and only updates period and duty.
+ * - To update period and duty, XUANTIE_PWM_CFG_UPDATE needs to go through 0 -> 1
+ *   step, I.E if XUANTIE_PWM_CFG_UPDATE is already 1, it's necessary to clear it
+ *   to 0 beforehand.
+ * - Polarity can only be changed if never started before.
+ */
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+
+#define XUANTIE_PWM_MAX_NUM		6
+#define XUANTIE_PWM_MAX_PERIOD		GENMASK(31, 0)
+#define XUANTIE_PWM_MAX_DUTY		GENMASK(31, 0)
+
+#define XUANTIE_PWM_CHN_BASE(n)		((n) * 0x20)
+#define XUANTIE_PWM_CTRL(n)		(XUANTIE_PWM_CHN_BASE(n) + 0x00)
+#define  XUANTIE_PWM_CTRL_START		BIT(0)
+#define  XUANTIE_PWM_CTRL_SOFT_RST		BIT(1)
+#define  XUANTIE_PWM_CTRL_CFG_UPDATE	BIT(2)
+#define  XUANTIE_PWM_CTRL_INTEN		BIT(3)
+#define  XUANTIE_PWM_CTRL_MODE		GENMASK(5, 4)
+#define  XUANTIE_PWM_CTRL_MODE_CONTINUOUS	FIELD_PREP(XUANTIE_PWM_CTRL_MODE, 2)
+#define  XUANTIE_PWM_CTRL_EVTRIG		GENMASK(7, 6)
+#define  XUANTIE_PWM_CTRL_FPOUT		BIT(8)
+#define  XUANTIE_PWM_CTRL_INFACTOUT	BIT(9)
+#define XUANTIE_PWM_RPT(n)		(XUANTIE_PWM_CHN_BASE(n) + 0x04)
+#define XUANTIE_PWM_PER(n)		(XUANTIE_PWM_CHN_BASE(n) + 0x08)
+#define XUANTIE_PWM_FP(n)			(XUANTIE_PWM_CHN_BASE(n) + 0x0c)
+#define XUANTIE_PWM_STATUS(n)		(XUANTIE_PWM_CHN_BASE(n) + 0x10)
+#define  XUANTIE_PWM_STATUS_CYCLE		GENMASK(7, 0)
+
+struct xuantie_pwm_chip {
+	struct pwm_chip chip;
+	void __iomem *mmio_base;
+	struct clk *clk;
+	u8 channel_ever_started;
+};
+
+static inline struct xuantie_pwm_chip *xuantie_pwm_from_chip(struct pwm_chip *chip)
+{
+	return container_of(chip, struct xuantie_pwm_chip, chip);
+}
+
+static int xuantie_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+			   const struct pwm_state *state)
+{
+	struct xuantie_pwm_chip *priv = xuantie_pwm_from_chip(chip);
+	u32 val = XUANTIE_PWM_CTRL_INFACTOUT | XUANTIE_PWM_CTRL_FPOUT | XUANTIE_PWM_CTRL_MODE_CONTINUOUS;
+	u64 period_cycle, duty_cycle, rate;
+	int ret;
+
+	/* if ever started, can't change the polarity */
+	if ((priv->channel_ever_started & (1 << pwm->hwpwm)) &&
+	    state->polarity != pwm->state.polarity)
+		return -EINVAL;
+
+	if (!state->enabled) {
+		if (pwm->state.enabled) {
+			val = readl(priv->mmio_base + XUANTIE_PWM_CTRL(pwm->hwpwm));
+			val &= ~XUANTIE_PWM_CTRL_CFG_UPDATE;
+			writel(val, priv->mmio_base + XUANTIE_PWM_CTRL(pwm->hwpwm));
+
+			writel(0, priv->mmio_base + XUANTIE_PWM_FP(pwm->hwpwm));
+
+			val |= XUANTIE_PWM_CTRL_CFG_UPDATE;
+			writel(val, priv->mmio_base + XUANTIE_PWM_CTRL(pwm->hwpwm));
+			pm_runtime_put_sync(chip->dev);
+		}
+		return 0;
+	}
+
+	if (!pwm->state.enabled) {
+		ret = pm_runtime_resume_and_get(chip->dev);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (state->polarity == PWM_POLARITY_INVERSED)
+		val &= ~XUANTIE_PWM_CTRL_FPOUT;
+
+	writel(val, priv->mmio_base + XUANTIE_PWM_CTRL(pwm->hwpwm));
+
+	rate = clk_get_rate(priv->clk);
+	/*
+	 * The following calculations might overflow if clk is bigger
+	 * than 1 GHz. In practise it's 24MHz, so this limitation
+	 * is only theoretic.
+	 */
+	if (rate > NSEC_PER_SEC)
+		return -EINVAL;
+
+	period_cycle = mul_u64_u64_div_u64(rate, state->period, NSEC_PER_SEC);
+	if (period_cycle > XUANTIE_PWM_MAX_PERIOD)
+		period_cycle = XUANTIE_PWM_MAX_PERIOD;
+	/*
+	 * With limitation above we have period_cycle <= XUANTIE_PWM_MAX_PERIOD,
+	 * so this cannot overflow.
+	 */
+	writel(period_cycle, priv->mmio_base + XUANTIE_PWM_PER(pwm->hwpwm));
+
+	duty_cycle = mul_u64_u64_div_u64(rate, state->duty_cycle, NSEC_PER_SEC);
+	if (duty_cycle > XUANTIE_PWM_MAX_DUTY)
+		duty_cycle = XUANTIE_PWM_MAX_DUTY;
+	/*
+	 * With limitation above we have duty_cycle <= XUANTIE_PWM_MAX_DUTY,
+	 * so this cannot overflow.
+	 */
+	writel(duty_cycle, priv->mmio_base + XUANTIE_PWM_FP(pwm->hwpwm));
+
+	val |= XUANTIE_PWM_CTRL_CFG_UPDATE;
+	writel(val, priv->mmio_base + XUANTIE_PWM_CTRL(pwm->hwpwm));
+
+	if (!pwm->state.enabled) {
+		val |= XUANTIE_PWM_CTRL_START;
+		writel(val, priv->mmio_base + XUANTIE_PWM_CTRL(pwm->hwpwm));
+		priv->channel_ever_started |= 1 << pwm->hwpwm;
+	}
+
+	return 0;
+}
+
+static int xuantie_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
+			       struct pwm_state *state)
+{
+	struct xuantie_pwm_chip *priv = xuantie_pwm_from_chip(chip);
+	u64 rate = clk_get_rate(priv->clk);
+	u32 val;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(chip->dev);
+	if (ret < 0)
+		return ret;
+
+	val = readl(priv->mmio_base + XUANTIE_PWM_CTRL(pwm->hwpwm));
+	if (val & XUANTIE_PWM_CTRL_FPOUT)
+		state->polarity = PWM_POLARITY_NORMAL;
+	else
+		state->polarity = PWM_POLARITY_INVERSED;
+
+	val = readl(priv->mmio_base + XUANTIE_PWM_PER(pwm->hwpwm));
+	/*
+	 * val 32 bits, multiply NSEC_PER_SEC, won't overflow.
+	 */
+	state->period = DIV64_U64_ROUND_UP((u64)val * NSEC_PER_SEC, rate);
+
+	val = readl(priv->mmio_base + XUANTIE_PWM_FP(pwm->hwpwm));
+	state->enabled = !!val;
+	/*
+	 * val 32 bits, multiply NSEC_PER_SEC, won't overflow.
+	 */
+	state->duty_cycle = DIV64_U64_ROUND_UP((u64)val * NSEC_PER_SEC, rate);
+
+	pm_runtime_put_sync(chip->dev);
+
+	return 0;
+}
+
+static const struct pwm_ops xuantie_pwm_ops = {
+	.apply = xuantie_pwm_apply,
+	.get_state = xuantie_pwm_get_state,
+};
+
+static int __maybe_unused xuantie_pwm_runtime_suspend(struct device *dev)
+{
+	struct xuantie_pwm_chip *priv = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int __maybe_unused xuantie_pwm_runtime_resume(struct device *dev)
+{
+	struct xuantie_pwm_chip *priv = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		dev_err(dev, "failed to enable pwm clock(%pe)\n", ERR_PTR(ret));
+
+	return ret;
+}
+
+static int xuantie_pwm_probe(struct platform_device *pdev)
+{
+	struct xuantie_pwm_chip *priv;
+	int ret, i;
+	u32 val;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->mmio_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(priv->mmio_base))
+		return PTR_ERR(priv->mmio_base);
+
+	priv->clk = devm_clk_get_enabled(&pdev->dev, NULL);
+	if (IS_ERR(priv->clk))
+		return PTR_ERR(priv->clk);
+
+	priv->chip.ops = &xuantie_pwm_ops;
+	priv->chip.dev = &pdev->dev;
+	priv->chip.npwm = XUANTIE_PWM_MAX_NUM;
+
+	/* check whether PWM is ever started or not */
+	for (i = 0; i < priv->chip.npwm; i++) {
+		val = readl(priv->mmio_base + XUANTIE_PWM_FP(i));
+		if (val)
+			priv->channel_ever_started |= 1 << i;
+	}
+
+	ret = devm_pwmchip_add(&pdev->dev, &priv->chip);
+	if (ret)
+		return ret;
+
+	devm_pm_runtime_enable(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id xuantie_pwm_dt_ids[] = {
+	{.compatible = "xuantie,th1520-pwm",},
+	{/* sentinel */}
+};
+MODULE_DEVICE_TABLE(of, xuantie_pwm_dt_ids);
+
+static const struct dev_pm_ops xuantie_pwm_pm_ops = {
+	SET_RUNTIME_PM_OPS(xuantie_pwm_runtime_suspend, xuantie_pwm_runtime_resume, NULL)
+};
+
+static struct platform_driver xuantie_pwm_driver = {
+	.driver = {
+		.name = "xuantie-pwm",
+		.of_match_table = xuantie_pwm_dt_ids,
+		.pm = &xuantie_pwm_pm_ops,
+	},
+	.probe = xuantie_pwm_probe,
+};
+module_platform_driver(xuantie_pwm_driver);
+
+MODULE_AUTHOR("Wei Liu <lw312886@linux.alibaba.com>");
+MODULE_AUTHOR("Jisheng Zhang <jszhang@kernel.org>");
+MODULE_DESCRIPTION("XuanTie pwm driver");
+MODULE_LICENSE("GPL");
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -1664,7 +1664,7 @@ config REGULATOR_QCOM_LABIBB
 	  for LCD display panel.
 
 config REGULATOR_TH1520_AON
-        tristate "Thead Th1520 Aon regulator"
+        tristate "XuanTie Th1520 Aon regulator"
         depends on TH1520_AON
         default y
         help
--- a/drivers/regulator/th1520-aon-regulator.c
+++ b/drivers/regulator/th1520-aon-regulator.c
@@ -17,7 +17,7 @@
 #include <linux/regulator/machine.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
-#include <linux/firmware/thead/ipc.h>
+#include <linux/firmware/xuantie/ipc.h>
 
 #define MBOX_MAX_MSG_LEN	28
 
@@ -738,7 +738,7 @@ static int th1520_aon_regulator_probe(st
 }
 
 static const struct of_device_id th1520_pmic_dev_id[] = {
-	{ .compatible = "thead,th1520-aon-pmic", .data = &th1520_aon_regus},
+	{ .compatible = "xuantie,th1520-aon-pmic", .data = &th1520_aon_regus},
 	{},
 };
 MODULE_DEVICE_TABLE(of, th1520_pmic_dev_id);
@@ -766,5 +766,5 @@ module_exit(th1520_aon_regulator_exit);
 
 MODULE_AUTHOR("fugang.duan <duanfugang.dfg@linux.alibaba.com>");
 MODULE_AUTHOR("linghui.zlh <linghui.zlh@linux.alibaba.com>");
-MODULE_DESCRIPTION("Thead TH1520 Aon regulator virtual driver");
+MODULE_DESCRIPTION("XuanTie TH1520 Aon regulator virtual driver");
 MODULE_LICENSE("GPL");
--- a/drivers/reset/reset-th1520.c
+++ b/drivers/reset/reset-th1520.c
@@ -13,7 +13,7 @@
 #include <linux/platform_device.h>
 #include <linux/reset-controller.h>
 #include <linux/regmap.h>
-#include <dt-bindings/reset/thead,th1520-reset.h>
+#include <dt-bindings/reset/xuantie,th1520-reset.h>
 
 struct th1520_rst_signal {
 	unsigned int offset, bit;
--- a/drivers/rpmsg/th1520_rpmsg.c
+++ b/drivers/rpmsg/th1520_rpmsg.c
@@ -47,8 +47,7 @@
 #include <linux/th1520_rpmsg.h>
 #include <linux/th1520_proc_debug.h>
 #ifdef CONFIG_PM_SLEEP
-#include <linux/firmware/thead/ipc.h>
-//#include <linux/firmware/thead/light_event.h>
+#include <linux/firmware/xuantie/ipc.h>
 #endif
 #define MBOX_MAX_MSG_LEN 28
 #define WJ_MBOX_SEND_MAX_MESSAGE_LENGTH 28
@@ -940,13 +939,13 @@ static int mbox_client_th1520_remove(str
 }
 
 static const struct of_device_id mbox_client_th1520_match[] = {
-	{ .compatible = "thead,th1520-mbox-client" },
+	{ .compatible = "xuantie,th1520-mbox-client" },
 	{},
 };
 
 static struct platform_driver mbox_client_th1520_driver = {
 	.driver = {
-		.name = "thead,th1520-mbox-client",
+		.name = "xuantie,th1520-mbox-client",
 		.of_match_table = mbox_client_th1520_match,
 	},
 	.probe  = mbox_client_th1520_probe,
@@ -955,5 +954,5 @@ static struct platform_driver mbox_clien
 module_platform_driver(mbox_client_th1520_driver);
 
 MODULE_AUTHOR("Alibaba Group Holding Limited");
-MODULE_DESCRIPTION("Thead Light mailbox IPC client driver");
+MODULE_DESCRIPTION("XuanTie TH1520 mailbox IPC client driver");
 MODULE_LICENSE("GPL v2");
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -31,6 +31,6 @@ source "drivers/soc/ti/Kconfig"
 source "drivers/soc/ux500/Kconfig"
 source "drivers/soc/versatile/Kconfig"
 source "drivers/soc/xilinx/Kconfig"
-source "drivers/soc/thead/Kconfig"
+source "drivers/soc/xuantie/Kconfig"
 
 endmenu
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -35,4 +35,4 @@ obj-y				+= ti/
 obj-$(CONFIG_ARCH_U8500)	+= ux500/
 obj-$(CONFIG_PLAT_VERSATILE)	+= versatile/
 obj-y				+= xilinx/
-obj-y				+= thead/
+obj-y				+= xuantie/
--- a/drivers/soc/thead/Kconfig
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-menu "Thead SoC drivers"
-
-config TH1520_REBOOTMODE
-	bool "XuanTie th1520 rebootmode support"
-	depends on TH1520_AON
-	default y
-	help
-	 This driver supports check rebootmode feature in TH1520 FM platform
-
-endmenu
--- /dev/null
+++ b/drivers/soc/xuantie/Kconfig
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0-only
+menu "XuanTie SoC drivers"
+
+config TH1520_REBOOTMODE
+	bool "XuanTie th1520 rebootmode support"
+	depends on TH1520_AON
+	default y
+	help
+	 This driver supports check rebootmode feature in TH1520 FM platform
+
+endmenu
--- a/drivers/soc/thead/th1520_event.c
+++ /dev/null
@@ -1,280 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-#include <linux/kernel.h>
-#include <linux/of.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/mfd/syscon.h>
-#include <linux/regmap.h>
-#include <linux/platform_device.h>
-#include <linux/firmware/thead/ipc.h>
-#include <linux/firmware/thead/th1520_event.h>
-
-/*
- * AON SRAM total size is 0x10000, reserve 0x100 for event.
- * Notice: c902 *.ld also need resize.
- * -------------- 0xff_ffef8000
- * |		|
- * |		|
- * |		|
- * |  c902	|
- * |		|
- * |		|
- * |		|
- * -------------- 0xff_fff07f00
- * |   reserve	|
- * |		|
- * --------------
- */
-#define TH1520_AON_SRAM_LEN	0x10000
-#define TH1520_AON_SRAM_RESERV	(TH1520_AON_SRAM_LEN - 0x100)
-#define TH1520_EVENT_OFFSET	(TH1520_AON_SRAM_RESERV + 0x10)
-#define TH1520_EVENT_CHECK	(TH1520_EVENT_OFFSET + 0x4)
-
-#define TH1520_EVENT_MAGIC	0x5A5A5A5A
-
-struct th1520_aon_msg_event_ctrl {
-	struct th1520_aon_rpc_msg_hdr hdr;
-	u32 reserve_offset;
-	u32 reserved[5];
-} __packed __aligned(1);
-
-struct th1520_event {
-	struct device *dev;
-
-	struct th1520_aon_ipc *ipc_handle;
-	struct th1520_aon_msg_event_ctrl msg;
-
-	struct regmap *aon_iram;
-	bool init;
-};
-
-struct th1520_event *th1520_event;
-
-static void th1520_event_msg_hdr_fill(struct th1520_aon_rpc_msg_hdr *hdr, enum th1520_aon_sys_func func)
-{
-	hdr->svc = (uint8_t)TH1520_AON_RPC_SVC_SYS;
-	hdr->func = (uint8_t)func;
-	hdr->size = TH1520_AON_RPC_MSG_NUM;
-}
-
-static int th1520_event_aon_reservemem(struct th1520_event *event)
-{
-	struct th1520_aon_ipc *ipc = event->ipc_handle;
-	struct th1520_aon_rpc_ack_common ack_msg;
-	int ret = 0;
-
-	dev_dbg(event->dev, "aon reservemem...\n");
-
-	th1520_event_msg_hdr_fill(&event->msg.hdr, TH1520_AON_SYS_FUNC_AON_RESERVE_MEM);
-
-	RPC_SET_BE32(&event->msg.reserve_offset, 0, TH1520_EVENT_OFFSET);
-
-	ret = th1520_aon_call_rpc(ipc, &event->msg, &ack_msg, true);
-	if (ret)
-		dev_err(event->dev, "failed to set aon reservemem\n");
-
-	return ret;
-}
-
-int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode)
-{
-	int ret;
-
-	if (!th1520_event || !th1520_event->init)
-		return -EINVAL;
-
-	ret = regmap_write(th1520_event->aon_iram, TH1520_EVENT_OFFSET, mode);
-	if (ret) {
-		dev_err(th1520_event->dev, "set rebootmode failed,ret:%d\n", ret);
-		return ret;
-	}
-
-	dev_info(th1520_event->dev, "set rebootmode:0x%x\n", mode);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(th1520_event_set_rebootmode);
-
-int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode)
-{
-	int ret;
-
-	if (!th1520_event || !th1520_event->init)
-		return -EINVAL;
-
-	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_OFFSET, mode);
-	if (ret) {
-		dev_err(th1520_event->dev, "get rebootmode failed,ret:%d\n", ret);
-		return ret;
-	}
-	dev_dbg(th1520_event->dev, "%s get rebootmode:0x%x\n", __func__, *mode);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(th1520_event_get_rebootmode);
-
-static int th1520_event_check_powerup(void)
-{
-	enum th1520_rebootmode_index mode;
-	unsigned int val;
-	int ret;
-
-	if (!th1520_event->init)
-		return -EINVAL;
-
-	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_CHECK, &val);
-	if (ret) {
-		dev_err(th1520_event->dev, "get magicnum failed,ret:%d\n", ret);
-		return ret;
-	}
-	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_OFFSET, &mode);
-	if (ret) {
-		dev_err(th1520_event->dev, "get rebootmode failed,ret:%d\n", ret);
-		return ret;
-	}
-	dev_info(th1520_event->dev, "magicnum:0x%x mode:0x%x\n", val, mode);
-
-	/* powerup means SRAM data is randam */
-	if (val != TH1520_EVENT_MAGIC && mode != TH1520_EVENT_PMIC_ONKEY)
-		th1520_event_set_rebootmode(TH1520_EVENT_PMIC_POWERUP);
-
-	ret = regmap_write(th1520_event->aon_iram, TH1520_EVENT_CHECK, TH1520_EVENT_MAGIC);
-	if (ret) {
-		dev_err(th1520_event->dev, "set magicnum failed,ret:%d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static ssize_t rebootmode_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
-{
-	enum th1520_rebootmode_index mode;
-
-	if (kstrtouint(buf, 0, &mode) < 0)
-		return -EINVAL;
-	th1520_event_set_rebootmode(mode);
-
-	return count;
-}
-
-static ssize_t
-rebootmode_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	enum th1520_rebootmode_index mode;
-
-	th1520_event_get_rebootmode(&mode);
-
-	return sprintf(buf, "0x%x\n", mode);
-}
-static DEVICE_ATTR_RW(rebootmode);
-
-static struct attribute *event_attrs[] = {
-	&dev_attr_rebootmode.attr,
-	NULL
-};
-ATTRIBUTE_GROUPS(event);
-
-static int th1520_event_open(struct inode *inode, struct file *f)
-{
-	return 0;
-}
-
-static int th1520_event_release(struct inode *inode, struct file *f)
-{
-	return 0;
-}
-
-static long th1520_event_ioctl(struct file *f, unsigned int ioctl,
-			    unsigned long arg)
-{
-	return 0;
-}
-
-static const struct file_operations th1520_event_fops = {
-	.owner          = THIS_MODULE,
-	.release        = th1520_event_release,
-	.open           = th1520_event_open,
-	.unlocked_ioctl = th1520_event_ioctl,
-};
-
-static struct miscdevice th1520_event_misc = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "th1520-event",
-	.fops = &th1520_event_fops,
-};
-
-static int th1520_event_probe(struct platform_device *pdev)
-{
-	struct device		*dev = &pdev->dev;
-	struct device_node	*np = dev->of_node;
-	struct th1520_event	*thead;
-	int			ret;
-
-	thead = devm_kzalloc(&pdev->dev, sizeof(*thead), GFP_KERNEL);
-	if (!thead)
-		return -ENOMEM;
-
-	ret = th1520_aon_get_handle(&(thead->ipc_handle));
-	if (ret == -EPROBE_DEFER)
-		return ret;
-
-	platform_set_drvdata(pdev, thead);
-	thead->dev = &pdev->dev;
-
-	thead->aon_iram = syscon_regmap_lookup_by_phandle(np, "aon-iram-regmap");
-	if (IS_ERR(thead->aon_iram))
-		return PTR_ERR(thead->aon_iram);
-
-	ret = misc_register(&th1520_event_misc);
-	if (ret < 0)
-		return ret;
-
-	ret = th1520_event_aon_reservemem(thead);
-	if (ret) {
-		dev_err(dev, "set aon reservemem failed!\n");
-		return -EPERM;
-	}
-	thead->init = true;
-	th1520_event = thead;
-
-	ret = th1520_event_check_powerup();
-	if (ret) {
-		dev_err(dev, "check powerup failed!\n");
-		th1520_event = NULL;
-		return -EPERM;
-	}
-	dev_info(dev, "th1520-event driver init successfully\n");
-
-	return 0;
-}
-
-static int th1520_event_remove(struct platform_device *pdev)
-{
-	misc_deregister(&th1520_event_misc);
-
-	return 0;
-}
-
-static const struct of_device_id th1520_event_of_match[] = {
-	{ .compatible = "thead,th1520-event" },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, th1520_event_of_match);
-
-static struct platform_driver th1520_event_driver = {
-	.probe		= th1520_event_probe,
-	.remove		= th1520_event_remove,
-	.driver		= {
-		.name	= "th1520-event",
-		.dev_groups	= event_groups,
-		.of_match_table	= th1520_event_of_match,
-	},
-};
-
-module_platform_driver(th1520_event_driver);
-
-MODULE_DESCRIPTION("th1520-event driver");
-MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/drivers/soc/xuantie/th1520_event.c
@@ -0,0 +1,280 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+#include <linux/firmware/xuantie/ipc.h>
+#include <linux/firmware/xuantie/th1520_event.h>
+
+/*
+ * AON SRAM total size is 0x10000, reserve 0x100 for event.
+ * Notice: c902 *.ld also need resize.
+ * -------------- 0xff_ffef8000
+ * |		|
+ * |		|
+ * |		|
+ * |  c902	|
+ * |		|
+ * |		|
+ * |		|
+ * -------------- 0xff_fff07f00
+ * |   reserve	|
+ * |		|
+ * --------------
+ */
+#define TH1520_AON_SRAM_LEN	0x10000
+#define TH1520_AON_SRAM_RESERV	(TH1520_AON_SRAM_LEN - 0x100)
+#define TH1520_EVENT_OFFSET	(TH1520_AON_SRAM_RESERV + 0x10)
+#define TH1520_EVENT_CHECK	(TH1520_EVENT_OFFSET + 0x4)
+
+#define TH1520_EVENT_MAGIC	0x5A5A5A5A
+
+struct th1520_aon_msg_event_ctrl {
+	struct th1520_aon_rpc_msg_hdr hdr;
+	u32 reserve_offset;
+	u32 reserved[5];
+} __packed __aligned(1);
+
+struct th1520_event {
+	struct device *dev;
+
+	struct th1520_aon_ipc *ipc_handle;
+	struct th1520_aon_msg_event_ctrl msg;
+
+	struct regmap *aon_iram;
+	bool init;
+};
+
+struct th1520_event *th1520_event;
+
+static void th1520_event_msg_hdr_fill(struct th1520_aon_rpc_msg_hdr *hdr, enum th1520_aon_sys_func func)
+{
+	hdr->svc = (uint8_t)TH1520_AON_RPC_SVC_SYS;
+	hdr->func = (uint8_t)func;
+	hdr->size = TH1520_AON_RPC_MSG_NUM;
+}
+
+static int th1520_event_aon_reservemem(struct th1520_event *event)
+{
+	struct th1520_aon_ipc *ipc = event->ipc_handle;
+	struct th1520_aon_rpc_ack_common ack_msg;
+	int ret = 0;
+
+	dev_dbg(event->dev, "aon reservemem...\n");
+
+	th1520_event_msg_hdr_fill(&event->msg.hdr, TH1520_AON_SYS_FUNC_AON_RESERVE_MEM);
+
+	RPC_SET_BE32(&event->msg.reserve_offset, 0, TH1520_EVENT_OFFSET);
+
+	ret = th1520_aon_call_rpc(ipc, &event->msg, &ack_msg, true);
+	if (ret)
+		dev_err(event->dev, "failed to set aon reservemem\n");
+
+	return ret;
+}
+
+int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode)
+{
+	int ret;
+
+	if (!th1520_event || !th1520_event->init)
+		return -EINVAL;
+
+	ret = regmap_write(th1520_event->aon_iram, TH1520_EVENT_OFFSET, mode);
+	if (ret) {
+		dev_err(th1520_event->dev, "set rebootmode failed,ret:%d\n", ret);
+		return ret;
+	}
+
+	dev_info(th1520_event->dev, "set rebootmode:0x%x\n", mode);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(th1520_event_set_rebootmode);
+
+int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode)
+{
+	int ret;
+
+	if (!th1520_event || !th1520_event->init)
+		return -EINVAL;
+
+	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_OFFSET, mode);
+	if (ret) {
+		dev_err(th1520_event->dev, "get rebootmode failed,ret:%d\n", ret);
+		return ret;
+	}
+	dev_dbg(th1520_event->dev, "%s get rebootmode:0x%x\n", __func__, *mode);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(th1520_event_get_rebootmode);
+
+static int th1520_event_check_powerup(void)
+{
+	enum th1520_rebootmode_index mode;
+	unsigned int val;
+	int ret;
+
+	if (!th1520_event->init)
+		return -EINVAL;
+
+	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_CHECK, &val);
+	if (ret) {
+		dev_err(th1520_event->dev, "get magicnum failed,ret:%d\n", ret);
+		return ret;
+	}
+	ret = regmap_read(th1520_event->aon_iram, TH1520_EVENT_OFFSET, &mode);
+	if (ret) {
+		dev_err(th1520_event->dev, "get rebootmode failed,ret:%d\n", ret);
+		return ret;
+	}
+	dev_info(th1520_event->dev, "magicnum:0x%x mode:0x%x\n", val, mode);
+
+	/* powerup means SRAM data is randam */
+	if (val != TH1520_EVENT_MAGIC && mode != TH1520_EVENT_PMIC_ONKEY)
+		th1520_event_set_rebootmode(TH1520_EVENT_PMIC_POWERUP);
+
+	ret = regmap_write(th1520_event->aon_iram, TH1520_EVENT_CHECK, TH1520_EVENT_MAGIC);
+	if (ret) {
+		dev_err(th1520_event->dev, "set magicnum failed,ret:%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static ssize_t rebootmode_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	enum th1520_rebootmode_index mode;
+
+	if (kstrtouint(buf, 0, &mode) < 0)
+		return -EINVAL;
+	th1520_event_set_rebootmode(mode);
+
+	return count;
+}
+
+static ssize_t
+rebootmode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	enum th1520_rebootmode_index mode;
+
+	th1520_event_get_rebootmode(&mode);
+
+	return sprintf(buf, "0x%x\n", mode);
+}
+static DEVICE_ATTR_RW(rebootmode);
+
+static struct attribute *event_attrs[] = {
+	&dev_attr_rebootmode.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(event);
+
+static int th1520_event_open(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static int th1520_event_release(struct inode *inode, struct file *f)
+{
+	return 0;
+}
+
+static long th1520_event_ioctl(struct file *f, unsigned int ioctl,
+			    unsigned long arg)
+{
+	return 0;
+}
+
+static const struct file_operations th1520_event_fops = {
+	.owner          = THIS_MODULE,
+	.release        = th1520_event_release,
+	.open           = th1520_event_open,
+	.unlocked_ioctl = th1520_event_ioctl,
+};
+
+static struct miscdevice th1520_event_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "th1520-event",
+	.fops = &th1520_event_fops,
+};
+
+static int th1520_event_probe(struct platform_device *pdev)
+{
+	struct device		*dev = &pdev->dev;
+	struct device_node	*np = dev->of_node;
+	struct th1520_event	*event;
+	int			ret;
+
+	event = devm_kzalloc(&pdev->dev, sizeof(*event), GFP_KERNEL);
+	if (!event)
+		return -ENOMEM;
+
+	ret = th1520_aon_get_handle(&(event->ipc_handle));
+	if (ret == -EPROBE_DEFER)
+		return ret;
+
+	platform_set_drvdata(pdev, event);
+	event->dev = &pdev->dev;
+
+	event->aon_iram = syscon_regmap_lookup_by_phandle(np, "aon-iram-regmap");
+	if (IS_ERR(event->aon_iram))
+		return PTR_ERR(event->aon_iram);
+
+	ret = misc_register(&th1520_event_misc);
+	if (ret < 0)
+		return ret;
+
+	ret = th1520_event_aon_reservemem(event);
+	if (ret) {
+		dev_err(dev, "set aon reservemem failed!\n");
+		return -EPERM;
+	}
+	event->init = true;
+	th1520_event = event;
+
+	ret = th1520_event_check_powerup();
+	if (ret) {
+		dev_err(dev, "check powerup failed!\n");
+		th1520_event = NULL;
+		return -EPERM;
+	}
+	dev_info(dev, "th1520-event driver init successfully\n");
+
+	return 0;
+}
+
+static int th1520_event_remove(struct platform_device *pdev)
+{
+	misc_deregister(&th1520_event_misc);
+
+	return 0;
+}
+
+static const struct of_device_id th1520_event_of_match[] = {
+	{ .compatible = "xuantie,th1520-event" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, th1520_event_of_match);
+
+static struct platform_driver th1520_event_driver = {
+	.probe		= th1520_event_probe,
+	.remove		= th1520_event_remove,
+	.driver		= {
+		.name	= "th1520-event",
+		.dev_groups	= event_groups,
+		.of_match_table	= th1520_event_of_match,
+	},
+};
+
+module_platform_driver(th1520_event_driver);
+
+MODULE_DESCRIPTION("th1520-event driver");
+MODULE_LICENSE("GPL v2");
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -189,7 +189,7 @@ config USB_DWC3_RTK
 	  or dual-role mode.
 	  Say 'Y' or 'M' if you have such device.
 
-config USB_DWC3_THEAD
+config USB_DWC3_XUANTIE
 	tristate "XuanTie Platform"
 	depends on ARCH_XUANTIE || COMPILE_TEST
 	default USB_DWC3
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -56,4 +56,4 @@ obj-$(CONFIG_USB_DWC3_IMX8MP)		+= dwc3-i
 obj-$(CONFIG_USB_DWC3_XILINX)		+= dwc3-xilinx.o
 obj-$(CONFIG_USB_DWC3_OCTEON)		+= dwc3-octeon.o
 obj-$(CONFIG_USB_DWC3_RTK)		+= dwc3-rtk.o
-obj-$(CONFIG_USB_DWC3_THEAD)		+= dwc3-thead.o
+obj-$(CONFIG_USB_DWC3_XUANTIE)		+= dwc3-xuantie.o
--- a/drivers/usb/dwc3/dwc3-thead.c
+++ /dev/null
@@ -1,270 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * dwc3-thead.c - THEAD platform specific glue layer
- *
- * Inspired by dwc3-of-simple.c
- *
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- * Copyright (C) 2023 Jisheng Zhang <jszhang@kernel.org>
- * Copyright (c) 2018, The Linux Foundation. All rights reserved.
- */
-
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <linux/kernel.h>
-#include <linux/of_platform.h>
-#include <linux/mfd/syscon.h>
-#include <linux/regmap.h>
-#include <linux/platform_device.h>
-
-#include "core.h"
-
-/* USB3_DRD registers */
-#define USB_CLK_GATE_STS		0x0
-#define USB_LOGIC_ANALYZER_TRACE_STS0	0x4
-#define USB_LOGIC_ANALYZER_TRACE_STS1	0x8
-#define USB_GPIO				0xc
-#define USB_DEBUG_STS0			0x10
-#define USB_DEBUG_STS1			0x14
-#define USB_DEBUG_STS2			0x18
-#define USBCTL_CLK_CTRL0		0x1c
-#define USBPHY_CLK_CTRL1		0x20
-#define USBPHY_TEST_CTRL0		0x24
-#define USBPHY_TEST_CTRL1		0x28
-#define USBPHY_TEST_CTRL2		0x2c
-#define USBPHY_TEST_CTRL3		0x30
-#define USB_SSP_EN				0x34
-#define USB_HADDR_SEL			0x38
-#define USB_SYS					0x3c
-#define USB_HOST_STATUS			0x40
-#define USB_HOST_CTRL			0x44
-#define USBPHY_HOST_CTRL		0x48
-#define USBPHY_HOST_STATUS		0x4c
-#define USB_TEST_REG0			0x50
-#define USB_TEST_REG1			0x54
-#define USB_TEST_REG2			0x58
-#define USB_TEST_REG3			0x5c
-
-/* Bit fields */
-/* USB_SYS */
-#define TEST_POWERDOWN_SSP	BIT(2)
-#define TEST_POWERDOWN_HSP	BIT(1)
-#define COMMONONN			BIT(0)
-
-/* USB_SSP_EN */
-#define REF_SSP_EN			BIT(0)
-
-/* USBPHY_HOST_CTRL */
-#define HOST_U2_PORT_DISABLE	BIT(6)
-#define HOST_U3_PORT_DISABLE	BIT(5)
-
-/* MISC_SYSREG registers */
-#define USB3_DRD_SWRST			0x14
-
-/* Bit fields */
-/* USB3_DRD_SWRST */
-#define USB3_DRD_VCCRST		BIT(2)
-#define USB3_DRD_PHYRST		BIT(1)
-#define USB3_DRD_PRST		BIT(0)
-#define USB3_DRD_MASK		GENMASK(2, 0)
-
-/* USB as host or device*/
-#define USB_AS_HOST         (true)
-#define USB_AS_DEVICE       (false)
-
-static bool usb_role = USB_AS_HOST;
-module_param(usb_role, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(usb_role, "USB role");
-
-struct dwc3_thead {
-	struct device			*dev;
-	struct clk_bulk_data	*clks;
-	int						num_clocks;
-
-	void __iomem			*usb3_drd_base;
-	struct regmap			*misc_sysreg;
-
-	struct gpio_desc		*hubswitch;
-	struct regulator		*hub1v2;
-	struct regulator		*hub5v;
-	struct regulator		*vbus;
-};
-
-static void dwc3_thead_deassert(struct dwc3_thead *thead)
-{
-	/* 1. reset assert */
-	regmap_update_bits(thead->misc_sysreg, USB3_DRD_SWRST,
-				USB3_DRD_MASK, USB3_DRD_PRST);
-
-	/*
-	 *	2. Common Block Power-Down Control.
-	 *	Controls the power-down signals in the PLL block
-	 *	when the USB 3.0 femtoPHY is in Suspend or Sleep mode.
-	 */
-	writel(COMMONONN, thead->usb3_drd_base + USB_SYS);
-
-	/*
-	 *	3. Reference Clock Enable for SS function.
-	 *	Enables the reference clock to the prescaler.
-	 *	The ref_ssp_en signal must remain de-asserted until
-	 *	the reference clock is running at the appropriate frequency,
-	 *	at which point ref_ssp_en can be asserted.
-	 *	For lower power states, ref_ssp_en can also be de-asserted.
-	 */
-	writel(REF_SSP_EN, thead->usb3_drd_base + USB_SSP_EN);
-
-	/* 4. set host ctrl */
-	writel(0x1101, thead->usb3_drd_base + USB_HOST_CTRL);
-
-	/* 5. reset deassert */
-	regmap_update_bits(thead->misc_sysreg, USB3_DRD_SWRST,
-				USB3_DRD_MASK, USB3_DRD_MASK);
-
-	/* 6. wait deassert complete */
-	udelay(10);
-}
-
-static void dwc3_thead_assert(struct dwc3_thead *thead)
-{
-	/* close ssp */
-	writel(0, thead->usb3_drd_base + USB_SSP_EN);
-
-	/* reset assert usb */
-	regmap_update_bits(thead->misc_sysreg, USB3_DRD_SWRST,
-				USB3_DRD_MASK, 0);
-
-}
-
-static int dwc3_thead_probe(struct platform_device *pdev)
-{
-	struct device		*dev = &pdev->dev;
-	struct device_node	*np  = dev->of_node;
-	struct dwc3_thead	*thead;
-	int					ret;
-
-	thead = devm_kzalloc(&pdev->dev, sizeof(*thead), GFP_KERNEL);
-	if (!thead)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, thead);
-	thead->dev = &pdev->dev;
-
-	thead->misc_sysreg = syscon_regmap_lookup_by_phandle(np, "usb3-misc-regmap");
-	if (IS_ERR(thead->misc_sysreg)) {
-		dev_err(dev, "failed to get regmap - %ld\n", PTR_ERR(thead->misc_sysreg));
-
-
-		return PTR_ERR(thead->misc_sysreg);
-	}
-
-	thead->usb3_drd_base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(thead->usb3_drd_base)) {
-		dev_err(dev, "failed to get resource - %ld\n", PTR_ERR(thead->usb3_drd_base));
-		return PTR_ERR(thead->usb3_drd_base);
-	}
-
-	ret = clk_bulk_get_all(thead->dev, &thead->clks);
-	if (ret < 0) {
-		dev_err(dev, "failed to get clk - %d\n", ret);
-		goto err;
-	}
-
-	thead->num_clocks = ret;
-
-	ret = clk_bulk_prepare_enable(thead->num_clocks, thead->clks);
-	if (ret)
-		goto err;
-
-	dwc3_thead_deassert(thead);
-
-	ret = of_platform_populate(np, NULL, NULL, dev);
-	if (ret) {
-		dev_err(dev, "failed to register dwc3 core - %d\n", ret);
-		goto err_clk_put;
-	}
-
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-	pm_runtime_get_sync(dev);
-
-	device_enable_async_suspend(dev);
-
-	dev_info(dev,"th1520 dwc3 probe ok!\n");
-
-	return 0;
-
-err_clk_put:
-	clk_bulk_disable_unprepare(thead->num_clocks, thead->clks);
-	clk_bulk_put_all(thead->num_clocks, thead->clks);
-err:
-	return ret;
-}
-
-static int dwc3_thead_remove(struct platform_device *pdev)
-{
-	struct dwc3_thead	*thead = platform_get_drvdata(pdev);
-
-	dwc3_thead_assert(thead);
-
-	of_platform_depopulate(thead->dev);
-
-	clk_bulk_disable_unprepare(thead->num_clocks, thead->clks);
-	clk_bulk_put_all(thead->num_clocks, thead->clks);
-
-	pm_runtime_disable(thead->dev);
-	pm_runtime_set_suspended(thead->dev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int dwc3_thead_pm_suspend(struct device *dev)
-{
-	struct dwc3_thead *thead = dev_get_drvdata(dev);
-
-	dwc3_thead_assert(thead);
-
-	clk_bulk_disable(thead->num_clocks, thead->clks);
-
-	return 0;
-}
-
-
-static int dwc3_thead_pm_resume(struct device *dev)
-{
-	struct dwc3_thead *thead = dev_get_drvdata(dev);
-
-	dwc3_thead_deassert(thead);
-
-	return 0;
-}
-
-static const struct dev_pm_ops dwc3_thead_dev_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(dwc3_thead_pm_suspend, dwc3_thead_pm_resume)
-};
-#define DEV_PM_OPS	(&dwc3_thead_dev_pm_ops)
-#else
-#define DEV_PM_OPS	NULL
-#endif /* CONFIG_PM_SLEEP */
-
-static const struct of_device_id dwc3_thead_of_match[] = {
-	{ .compatible = "thead,th1520-usb" },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, dwc3_thead_of_match);
-
-static struct platform_driver dwc3_thead_driver = {
-	.probe		= dwc3_thead_probe,
-	.remove		= dwc3_thead_remove,
-	.driver		= {
-		.name	= "dwc3-thead",
-		.pm	= DEV_PM_OPS,
-		.of_match_table	= dwc3_thead_of_match,
-	},
-};
-
-module_platform_driver(dwc3_thead_driver);
-
-MODULE_LICENSE("GPL v2");
-MODULE_DESCRIPTION("DesignWare DWC3 T-HEAD Glue Driver");
-MODULE_AUTHOR("Jisheng Zhang <jszhang@kernel.org>");
\ No newline at end of file
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-xuantie.c
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * dwc3-xuantie.c - XuanTie platform specific glue layer
+ *
+ * Inspired by dwc3-of-simple.c
+ *
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ * Copyright (C) 2023 Jisheng Zhang <jszhang@kernel.org>
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ */
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/of_platform.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+
+#include "core.h"
+
+/* USB3_DRD registers */
+#define USB_CLK_GATE_STS		0x0
+#define USB_LOGIC_ANALYZER_TRACE_STS0	0x4
+#define USB_LOGIC_ANALYZER_TRACE_STS1	0x8
+#define USB_GPIO				0xc
+#define USB_DEBUG_STS0			0x10
+#define USB_DEBUG_STS1			0x14
+#define USB_DEBUG_STS2			0x18
+#define USBCTL_CLK_CTRL0		0x1c
+#define USBPHY_CLK_CTRL1		0x20
+#define USBPHY_TEST_CTRL0		0x24
+#define USBPHY_TEST_CTRL1		0x28
+#define USBPHY_TEST_CTRL2		0x2c
+#define USBPHY_TEST_CTRL3		0x30
+#define USB_SSP_EN				0x34
+#define USB_HADDR_SEL			0x38
+#define USB_SYS					0x3c
+#define USB_HOST_STATUS			0x40
+#define USB_HOST_CTRL			0x44
+#define USBPHY_HOST_CTRL		0x48
+#define USBPHY_HOST_STATUS		0x4c
+#define USB_TEST_REG0			0x50
+#define USB_TEST_REG1			0x54
+#define USB_TEST_REG2			0x58
+#define USB_TEST_REG3			0x5c
+
+/* Bit fields */
+/* USB_SYS */
+#define TEST_POWERDOWN_SSP	BIT(2)
+#define TEST_POWERDOWN_HSP	BIT(1)
+#define COMMONONN			BIT(0)
+
+/* USB_SSP_EN */
+#define REF_SSP_EN			BIT(0)
+
+/* USBPHY_HOST_CTRL */
+#define HOST_U2_PORT_DISABLE	BIT(6)
+#define HOST_U3_PORT_DISABLE	BIT(5)
+
+/* MISC_SYSREG registers */
+#define USB3_DRD_SWRST			0x14
+
+/* Bit fields */
+/* USB3_DRD_SWRST */
+#define USB3_DRD_VCCRST		BIT(2)
+#define USB3_DRD_PHYRST		BIT(1)
+#define USB3_DRD_PRST		BIT(0)
+#define USB3_DRD_MASK		GENMASK(2, 0)
+
+/* USB as host or device*/
+#define USB_AS_HOST         (true)
+#define USB_AS_DEVICE       (false)
+
+static bool usb_role = USB_AS_HOST;
+module_param(usb_role, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(usb_role, "USB role");
+
+struct dwc3_xuantie {
+	struct device			*dev;
+	struct clk_bulk_data	*clks;
+	int						num_clocks;
+
+	void __iomem			*usb3_drd_base;
+	struct regmap			*misc_sysreg;
+
+	struct gpio_desc		*hubswitch;
+	struct regulator		*hub1v2;
+	struct regulator		*hub5v;
+	struct regulator		*vbus;
+};
+
+static void dwc3_xuantie_deassert(struct dwc3_xuantie *xuantie)
+{
+	/* 1. reset assert */
+	regmap_update_bits(xuantie->misc_sysreg, USB3_DRD_SWRST,
+				USB3_DRD_MASK, USB3_DRD_PRST);
+
+	/*
+	 *	2. Common Block Power-Down Control.
+	 *	Controls the power-down signals in the PLL block
+	 *	when the USB 3.0 femtoPHY is in Suspend or Sleep mode.
+	 */
+	writel(COMMONONN, xuantie->usb3_drd_base + USB_SYS);
+
+	/*
+	 *	3. Reference Clock Enable for SS function.
+	 *	Enables the reference clock to the prescaler.
+	 *	The ref_ssp_en signal must remain de-asserted until
+	 *	the reference clock is running at the appropriate frequency,
+	 *	at which point ref_ssp_en can be asserted.
+	 *	For lower power states, ref_ssp_en can also be de-asserted.
+	 */
+	writel(REF_SSP_EN, xuantie->usb3_drd_base + USB_SSP_EN);
+
+	/* 4. set host ctrl */
+	writel(0x1101, xuantie->usb3_drd_base + USB_HOST_CTRL);
+
+	/* 5. reset deassert */
+	regmap_update_bits(xuantie->misc_sysreg, USB3_DRD_SWRST,
+				USB3_DRD_MASK, USB3_DRD_MASK);
+
+	/* 6. wait deassert complete */
+	udelay(10);
+}
+
+static void dwc3_xuantie_assert(struct dwc3_xuantie *xuantie)
+{
+	/* close ssp */
+	writel(0, xuantie->usb3_drd_base + USB_SSP_EN);
+
+	/* reset assert usb */
+	regmap_update_bits(xuantie->misc_sysreg, USB3_DRD_SWRST,
+				USB3_DRD_MASK, 0);
+
+}
+
+static int dwc3_xuantie_probe(struct platform_device *pdev)
+{
+	struct device		*dev = &pdev->dev;
+	struct device_node	*np  = dev->of_node;
+	struct dwc3_xuantie	*xuantie;
+	int					ret;
+
+	xuantie = devm_kzalloc(&pdev->dev, sizeof(*xuantie), GFP_KERNEL);
+	if (!xuantie)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, xuantie);
+	xuantie->dev = &pdev->dev;
+
+	xuantie->misc_sysreg = syscon_regmap_lookup_by_phandle(np, "usb3-misc-regmap");
+	if (IS_ERR(xuantie->misc_sysreg)) {
+		dev_err(dev, "failed to get regmap - %ld\n", PTR_ERR(xuantie->misc_sysreg));
+
+
+		return PTR_ERR(xuantie->misc_sysreg);
+	}
+
+	xuantie->usb3_drd_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(xuantie->usb3_drd_base)) {
+		dev_err(dev, "failed to get resource - %ld\n", PTR_ERR(xuantie->usb3_drd_base));
+		return PTR_ERR(xuantie->usb3_drd_base);
+	}
+
+	ret = clk_bulk_get_all(xuantie->dev, &xuantie->clks);
+	if (ret < 0) {
+		dev_err(dev, "failed to get clk - %d\n", ret);
+		goto err;
+	}
+
+	xuantie->num_clocks = ret;
+
+	ret = clk_bulk_prepare_enable(xuantie->num_clocks, xuantie->clks);
+	if (ret)
+		goto err;
+
+	dwc3_xuantie_deassert(xuantie);
+
+	ret = of_platform_populate(np, NULL, NULL, dev);
+	if (ret) {
+		dev_err(dev, "failed to register dwc3 core - %d\n", ret);
+		goto err_clk_put;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
+	device_enable_async_suspend(dev);
+
+	dev_info(dev,"th1520 dwc3 probe ok!\n");
+
+	return 0;
+
+err_clk_put:
+	clk_bulk_disable_unprepare(xuantie->num_clocks, xuantie->clks);
+	clk_bulk_put_all(xuantie->num_clocks, xuantie->clks);
+err:
+	return ret;
+}
+
+static int dwc3_xuantie_remove(struct platform_device *pdev)
+{
+	struct dwc3_xuantie	*xuantie = platform_get_drvdata(pdev);
+
+	dwc3_xuantie_assert(xuantie);
+
+	of_platform_depopulate(xuantie->dev);
+
+	clk_bulk_disable_unprepare(xuantie->num_clocks, xuantie->clks);
+	clk_bulk_put_all(xuantie->num_clocks, xuantie->clks);
+
+	pm_runtime_disable(xuantie->dev);
+	pm_runtime_set_suspended(xuantie->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int dwc3_xuantie_pm_suspend(struct device *dev)
+{
+	struct dwc3_xuantie *xuantie = dev_get_drvdata(dev);
+
+	dwc3_xuantie_assert(xuantie);
+
+	clk_bulk_disable(xuantie->num_clocks, xuantie->clks);
+
+	return 0;
+}
+
+
+static int dwc3_xuantie_pm_resume(struct device *dev)
+{
+	struct dwc3_xuantie *xuantie = dev_get_drvdata(dev);
+
+	dwc3_xuantie_deassert(xuantie);
+
+	return 0;
+}
+
+static const struct dev_pm_ops dwc3_xuantie_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dwc3_xuantie_pm_suspend, dwc3_xuantie_pm_resume)
+};
+#define DEV_PM_OPS	(&dwc3_xuantie_dev_pm_ops)
+#else
+#define DEV_PM_OPS	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct of_device_id dwc3_xuantie_of_match[] = {
+	{ .compatible = "xuantie,th1520-usb" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, dwc3_xuantie_of_match);
+
+static struct platform_driver dwc3_xuantie_driver = {
+	.probe		= dwc3_xuantie_probe,
+	.remove		= dwc3_xuantie_remove,
+	.driver		= {
+		.name	= "dwc3-xuantie",
+		.pm	= DEV_PM_OPS,
+		.of_match_table	= dwc3_xuantie_of_match,
+	},
+};
+
+module_platform_driver(dwc3_xuantie_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("DesignWare DWC3 XuanTie Glue Driver");
+MODULE_AUTHOR("Jisheng Zhang <jszhang@kernel.org>");
--- a/drivers/watchdog/dw_wdt.c
+++ b/drivers/watchdog/dw_wdt.c
@@ -28,7 +28,7 @@
 #include <linux/pm.h>
 #include <linux/reset.h>
 #include <linux/watchdog.h>
-#include <linux/firmware/thead/th1520_event.h>
+#include <linux/firmware/xuantie/th1520_event.h>
 
 #define WDOG_CONTROL_REG_OFFSET		    0x00
 #define WDOG_CONTROL_REG_WDT_EN_MASK	    0x01
--- a/drivers/watchdog/th1520_wdt.c
+++ b/drivers/watchdog/th1520_wdt.c
@@ -16,8 +16,8 @@
 #include <linux/regmap.h>
 #include <linux/device.h>
 #include <linux/watchdog.h>
-#include <linux/firmware/thead/ipc.h>
-#include <linux/firmware/thead/th1520_event.h>
+#include <linux/firmware/xuantie/ipc.h>
+#include <linux/firmware/xuantie/th1520_event.h>
 
 #define DRV_NAME	"th1520-wdt"
 
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -37,7 +37,7 @@
 #include <linux/context_tracking.h>
 #include <trace/events/error_report.h>
 #include <asm/sections.h>
-#include <linux/firmware/thead/th1520_event.h>
+#include <linux/firmware/xuantie/th1520_event.h>
 
 #define PANIC_TIMER_STEP 100
 #define PANIC_BLINK_SPD 18
--- a/drivers/firmware/thead/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_TH1520_AON)	+= th1520_aon.o 
-obj-$(CONFIG_TH1520_AON_PD)	+= th1520_aon_pd.o
-obj-y += th1520_proc_debug.o
--- a/drivers/firmware/thead/th1520_proc_debug.c
+++ /dev/null
@@ -1,173 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * sys log sys for th1520 c906 and e902
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- */
-
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_device.h>
-#include <linux/platform_device.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <asm/cacheflush.h>
-
-#define GET_PAGE_NUM(size, offset) \
-	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
-
-struct th1520_log_ring_buffer {
-	__u32 read;
-	__u32 write;
-	__u32 size;
-	__u32 reserved[1];
-	__u8 data[0];
-};
-
-struct th1520_hw_log {
-	__u32 panic;
-	__u32 reserved[2];
-	struct th1520_log_ring_buffer rb;
-};
-
-struct th1520_proc_log_ctrl {
-	struct th1520_hw_log __iomem *log;
-	struct proc_dir_entry *log_proc_file;
-	phys_addr_t log_phy;
-};
-
-static void dump_regs(const char *fn, void *hw_arg)
-{
-	struct th1520_proc_log_ctrl *log_ctrl = hw_arg;
-
-	if (!log_ctrl->log)
-		return;
-
-	pr_debug("%s: panic = 0x%08x\n", fn,
-		 __raw_readl(&log_ctrl->log->panic));
-	pr_debug("%s: read = 0x%08x, write = 0x%08x, size = 0x%08x\n", fn,
-		 __raw_readl(&log_ctrl->log->rb.read),
-		 __raw_readl(&log_ctrl->log->rb.write),
-		 __raw_readl(&log_ctrl->log->rb.size));
-}
-
-static int log_proc_show(struct seq_file *file, void *v)
-{
-	struct th1520_proc_log_ctrl *log_ctrl = file->private;
-	char *buf;
-	size_t i;
-	/*dcache clean and invalid*/
-	ALT_CMO_OP(flush, (phys_to_virt(log_ctrl->log_phy)),
-		   sizeof(struct th1520_hw_log),
-		   riscv_cbom_block_size);
-
-	uint32_t write = __raw_readl(&log_ctrl->log->rb.write);
-	uint32_t read = __raw_readl(&log_ctrl->log->rb.read);
-	uint32_t size = __raw_readl(&log_ctrl->log->rb.size);
-	size_t log_size = write >= read ? write - read : size + write - read;
-
-	seq_printf(file, "****************** device log >>>>>>>>>>>>>>>>>\n");
-	dump_regs(__func__, log_ctrl);
-	if (!log_size) {
-		seq_printf(
-			file,
-			"****************** end device log <<<<<<<<<<<<<<<<<\n");
-		return 0;
-	}
-
-	int page_num = GET_PAGE_NUM(log_size, 0);
-
-	int log_patch_1 = -1, log_patch_2 = -1;
-
-	buf = kmalloc(PAGE_SIZE * page_num, GFP_KERNEL);
-	if (buf) {
-		if (read + log_size >= size) {
-			log_patch_2 = read + log_size - size + 1;
-			log_patch_1 = log_size - log_patch_2;
-
-		} else {
-			log_patch_1 = log_size;
-		}
-
-		memcpy_fromio(buf, &log_ctrl->log->rb.data[read], log_patch_1);
-		if (log_patch_2 > 0) {
-			memcpy_fromio(buf, &log_ctrl->log->rb.data[0],
-				      log_patch_2);
-		}
-
-		uint8_t last_fame_size = log_size % 64;
-
-		for (i = 0; i < log_size - last_fame_size; i += 64) {
-			seq_printf(file, " %*pEp", 64, buf + i);
-		}
-		if (last_fame_size) {
-			seq_printf(file, " %*pEp", last_fame_size,
-				   buf + log_size - last_fame_size);
-		}
-
-		__raw_writel(write, &log_ctrl->log->rb.read);
-		kfree(buf);
-		/*dcahce clean*/
-		ALT_CMO_OP(clean, (phys_to_virt(log_ctrl->log_phy)),
-			   sizeof(struct th1520_hw_log), riscv_cbom_block_size);
-		//seq_printf(file,"\n%d %d %d %d %d\n",log_patch_1, log_patch_2, log_size ,last_fame_size, read);
-		seq_printf(
-			file,
-			"\n****************** end device log <<<<<<<<<<<<<<<<<\n");
-		return 0;
-	} else {
-		pr_debug("Fail to alloc buf\n");
-		return -1;
-	}
-	return 0;
-}
-
-static bool th1520_panic_init(struct th1520_hw_log *hw_log, size_t size)
-{
-	if (size < sizeof(struct th1520_hw_log)) {
-		return false;
-	}
-	hw_log->rb.read = 0;
-	hw_log->rb.size = size - sizeof(struct th1520_hw_log);
-	return true;
-}
-
-void *th1520_create_panic_log_proc(phys_addr_t log_phy, void *dir,
-				   void *log_info_addr, size_t size)
-{
-	struct th1520_proc_log_ctrl *log_ctrl =
-		kmalloc(sizeof(struct th1520_proc_log_ctrl), GFP_KERNEL);
-
-	if (log_ctrl == NULL)
-		return NULL;
-
-	log_ctrl->log = log_info_addr;
-
-	th1520_panic_init(log_ctrl->log, size);
-
-	log_ctrl->log_proc_file = proc_create_single_data(
-		"proc_log", 0644, dir, &log_proc_show, log_ctrl);
-	if (log_ctrl->log_proc_file == NULL) {
-		pr_debug("Error: Could not initialize %s\n", "dsp_log");
-		kfree(log_ctrl);
-		log_ctrl = NULL;
-	} else {
-		pr_debug("%s create Success!\n", "dsp_log");
-	}
-	log_ctrl->log_phy = log_phy;
-	return log_ctrl;
-}
-
-void th1520_remove_panic_log_proc(void *arg)
-{
-	struct th1520_proc_log_ctrl *log_ctrl =
-		(struct th1520_proc_log_ctrl *)arg;
-
-	proc_remove(log_ctrl->log_proc_file);
-	kfree(log_ctrl);
-	pr_debug("th1520 proc log removed\n");
-}
\ No newline at end of file
--- /dev/null
+++ b/drivers/firmware/xuantie/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_TH1520_AON)	+= th1520_aon.o 
+obj-$(CONFIG_TH1520_AON_PD)	+= th1520_aon_pd.o
+obj-y += th1520_proc_debug.o
--- /dev/null
+++ b/drivers/firmware/xuantie/th1520_proc_debug.c
@@ -0,0 +1,173 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * sys log sys for th1520 c906 and e902
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+
+#define GET_PAGE_NUM(size, offset) \
+	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
+
+struct th1520_log_ring_buffer {
+	__u32 read;
+	__u32 write;
+	__u32 size;
+	__u32 reserved[1];
+	__u8 data[0];
+};
+
+struct th1520_hw_log {
+	__u32 panic;
+	__u32 reserved[2];
+	struct th1520_log_ring_buffer rb;
+};
+
+struct th1520_proc_log_ctrl {
+	struct th1520_hw_log __iomem *log;
+	struct proc_dir_entry *log_proc_file;
+	phys_addr_t log_phy;
+};
+
+static void dump_regs(const char *fn, void *hw_arg)
+{
+	struct th1520_proc_log_ctrl *log_ctrl = hw_arg;
+
+	if (!log_ctrl->log)
+		return;
+
+	pr_debug("%s: panic = 0x%08x\n", fn,
+		 __raw_readl(&log_ctrl->log->panic));
+	pr_debug("%s: read = 0x%08x, write = 0x%08x, size = 0x%08x\n", fn,
+		 __raw_readl(&log_ctrl->log->rb.read),
+		 __raw_readl(&log_ctrl->log->rb.write),
+		 __raw_readl(&log_ctrl->log->rb.size));
+}
+
+static int log_proc_show(struct seq_file *file, void *v)
+{
+	struct th1520_proc_log_ctrl *log_ctrl = file->private;
+	char *buf;
+	size_t i;
+	/*dcache clean and invalid*/
+	ALT_CMO_OP(flush, (phys_to_virt(log_ctrl->log_phy)),
+		   sizeof(struct th1520_hw_log),
+		   riscv_cbom_block_size);
+
+	uint32_t write = __raw_readl(&log_ctrl->log->rb.write);
+	uint32_t read = __raw_readl(&log_ctrl->log->rb.read);
+	uint32_t size = __raw_readl(&log_ctrl->log->rb.size);
+	size_t log_size = write >= read ? write - read : size + write - read;
+
+	seq_printf(file, "****************** device log >>>>>>>>>>>>>>>>>\n");
+	dump_regs(__func__, log_ctrl);
+	if (!log_size) {
+		seq_printf(
+			file,
+			"****************** end device log <<<<<<<<<<<<<<<<<\n");
+		return 0;
+	}
+
+	int page_num = GET_PAGE_NUM(log_size, 0);
+
+	int log_patch_1 = -1, log_patch_2 = -1;
+
+	buf = kmalloc(PAGE_SIZE * page_num, GFP_KERNEL);
+	if (buf) {
+		if (read + log_size >= size) {
+			log_patch_2 = read + log_size - size + 1;
+			log_patch_1 = log_size - log_patch_2;
+
+		} else {
+			log_patch_1 = log_size;
+		}
+
+		memcpy_fromio(buf, &log_ctrl->log->rb.data[read], log_patch_1);
+		if (log_patch_2 > 0) {
+			memcpy_fromio(buf, &log_ctrl->log->rb.data[0],
+				      log_patch_2);
+		}
+
+		uint8_t last_fame_size = log_size % 64;
+
+		for (i = 0; i < log_size - last_fame_size; i += 64) {
+			seq_printf(file, " %*pEp", 64, buf + i);
+		}
+		if (last_fame_size) {
+			seq_printf(file, " %*pEp", last_fame_size,
+				   buf + log_size - last_fame_size);
+		}
+
+		__raw_writel(write, &log_ctrl->log->rb.read);
+		kfree(buf);
+		/*dcahce clean*/
+		ALT_CMO_OP(clean, (phys_to_virt(log_ctrl->log_phy)),
+			   sizeof(struct th1520_hw_log), riscv_cbom_block_size);
+		//seq_printf(file,"\n%d %d %d %d %d\n",log_patch_1, log_patch_2, log_size ,last_fame_size, read);
+		seq_printf(
+			file,
+			"\n****************** end device log <<<<<<<<<<<<<<<<<\n");
+		return 0;
+	} else {
+		pr_debug("Fail to alloc buf\n");
+		return -1;
+	}
+	return 0;
+}
+
+static bool th1520_panic_init(struct th1520_hw_log *hw_log, size_t size)
+{
+	if (size < sizeof(struct th1520_hw_log)) {
+		return false;
+	}
+	hw_log->rb.read = 0;
+	hw_log->rb.size = size - sizeof(struct th1520_hw_log);
+	return true;
+}
+
+void *th1520_create_panic_log_proc(phys_addr_t log_phy, void *dir,
+				   void *log_info_addr, size_t size)
+{
+	struct th1520_proc_log_ctrl *log_ctrl =
+		kmalloc(sizeof(struct th1520_proc_log_ctrl), GFP_KERNEL);
+
+	if (log_ctrl == NULL)
+		return NULL;
+
+	log_ctrl->log = log_info_addr;
+
+	th1520_panic_init(log_ctrl->log, size);
+
+	log_ctrl->log_proc_file = proc_create_single_data(
+		"proc_log", 0644, dir, &log_proc_show, log_ctrl);
+	if (log_ctrl->log_proc_file == NULL) {
+		pr_debug("Error: Could not initialize %s\n", "dsp_log");
+		kfree(log_ctrl);
+		log_ctrl = NULL;
+	} else {
+		pr_debug("%s create Success!\n", "dsp_log");
+	}
+	log_ctrl->log_phy = log_phy;
+	return log_ctrl;
+}
+
+void th1520_remove_panic_log_proc(void *arg)
+{
+	struct th1520_proc_log_ctrl *log_ctrl =
+		(struct th1520_proc_log_ctrl *)arg;
+
+	proc_remove(log_ctrl->log_proc_file);
+	kfree(log_ctrl);
+	pr_debug("th1520 proc log removed\n");
+}
\ No newline at end of file
--- a/drivers/soc/thead/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_TH1520_REBOOTMODE)	+= th1520_event.o
--- /dev/null
+++ b/drivers/soc/xuantie/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_TH1520_REBOOTMODE)	+= th1520_event.o
--- a/include/dt-bindings/firmware/thead/rsrc.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2022 Alibaba Group Holding Limited.
- */
-
-#ifndef __DT_BINDINGS_RSCRC_TH1520_H
-#define __DT_BINDINGS_RSCRC_TH1520_H
-
-#define TH1520_AON_AUDIO_PD	0
-#define TH1520_AON_VDEC_PD	1
-#define TH1520_AON_NPU_PD	2
-#define TH1520_AON_VENC_PD	3
-#define TH1520_AON_GPU_PD	4
-#define TH1520_AON_DSP0_PD	5
-#define TH1520_AON_DSP1_PD	6
-#define TH1520_AON_R_LAST	7
-
-#endif
--- /dev/null
+++ b/include/dt-bindings/firmware/xuantie/rsrc.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2022 Alibaba Group Holding Limited.
+ */
+
+#ifndef __DT_BINDINGS_RSCRC_TH1520_H
+#define __DT_BINDINGS_RSCRC_TH1520_H
+
+#define TH1520_AON_AUDIO_PD	0
+#define TH1520_AON_VDEC_PD	1
+#define TH1520_AON_NPU_PD	2
+#define TH1520_AON_VENC_PD	3
+#define TH1520_AON_GPU_PD	4
+#define TH1520_AON_DSP0_PD	5
+#define TH1520_AON_DSP1_PD	6
+#define TH1520_AON_R_LAST	7
+
+#endif
--- a/include/dt-bindings/reset/thead,th1520-reset.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
-/*
- * Copyright (C) 2021 Alibaba, Inc.
- *
- * Author: zenglinghui  <zenglinghui.zlh@linux.alibaba.com>
- */
-
-#ifndef DT_BINDING_RESET_TH1520_H
-#define DT_BINDING_RESET_TH1520_H
-
-#define TH1520_RESET_WDT0 0
-#define TH1520_RESET_WDT1 1
-#define TH1520_RESET_HDMI_I2S 2
-#define TH1520_RESET_NPU 3
-
-// vpsys reset
-#define TH1520_RESET_FCE 20
-
-// audiosys reset
-#define TH1520_RESET_AUD_I2S0 30
-#define TH1520_RESET_AUD_I2S1 31
-#define TH1520_RESET_AUD_I2S2 32
-#define TH1520_RESET_AUD_I2S8CH 33
-#define TH1520_RESET_AUD_TDM 34
-#define TH1520_RESET_AUD_SPDIF0 35
-#define TH1520_RESET_AUD_SPDIF1 36
-
-#endif
--- /dev/null
+++ b/include/dt-bindings/reset/xuantie,th1520-reset.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) 2021 Alibaba, Inc.
+ *
+ * Author: zenglinghui  <zenglinghui.zlh@linux.alibaba.com>
+ */
+
+#ifndef DT_BINDING_RESET_TH1520_H
+#define DT_BINDING_RESET_TH1520_H
+
+#define TH1520_RESET_WDT0 0
+#define TH1520_RESET_WDT1 1
+#define TH1520_RESET_HDMI_I2S 2
+#define TH1520_RESET_NPU 3
+
+// vpsys reset
+#define TH1520_RESET_FCE 20
+
+// audiosys reset
+#define TH1520_RESET_AUD_I2S0 30
+#define TH1520_RESET_AUD_I2S1 31
+#define TH1520_RESET_AUD_I2S2 32
+#define TH1520_RESET_AUD_I2S8CH 33
+#define TH1520_RESET_AUD_TDM 34
+#define TH1520_RESET_AUD_SPDIF0 35
+#define TH1520_RESET_AUD_SPDIF1 36
+
+#endif
--- a/include/linux/firmware/thead/ipc.h
+++ /dev/null
@@ -1,167 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright (C) 2021 Alibaba Group Holding Limited.
- */
-
-#ifndef _SC_IPC_H
-#define _SC_IPC_H
-
-#include <linux/device.h>
-#include <linux/types.h>
-
-#define AON_RPC_MSG_MAGIC	       (0xef)
-#define TH1520_AON_RPC_VERSION		2
-#define TH1520_AON_RPC_MSG_NUM		7
-
-struct th1520_aon_ipc;
-
-enum th1520_aon_rpc_svc {
-	TH1520_AON_RPC_SVC_UNKNOWN = 0,
-	TH1520_AON_RPC_SVC_PM =	1,
-	TH1520_AON_RPC_SVC_MISC = 2,
-	TH1520_AON_RPC_SVC_AVFS = 3,
-	TH1520_AON_RPC_SVC_SYS = 4,
-	TH1520_AON_RPC_SVC_WDG = 5,
-	TH1520_AON_RPC_SVC_LPM = 6,
-	TH1520_AON_RPC_SVC_MAX = 0x3F,
-};
-
-enum th1520_aon_misc_func {
-	TH1520_AON_MISC_FUNC_UNKNOWN = 0,
-	TH1520_AON_MISC_FUNC_SET_CONTROL = 1,
-	TH1520_AON_MISC_FUNC_GET_CONTROL = 2,
-	TH1520_AON_MISC_FUNC_REGDUMP_CFG = 3,
-};
-
-enum th1520_aon_wdg_func {
-	TH1520_AON_WDG_FUNC_UNKNOWN = 0,
-	TH1520_AON_WDG_FUNC_START = 1,
-	TH1520_AON_WDG_FUNC_STOP = 2,
-	TH1520_AON_WDG_FUNC_PING = 3,
-	TH1520_AON_WDG_FUNC_TIMEOUTSET = 4,
-	TH1520_AON_WDG_FUNC_RESTART = 5,
-	TH1520_AON_WDG_FUNC_GET_STATE = 6,
-	TH1520_AON_WDG_FUNC_POWER_OFF = 7,
-	TH1520_AON_WDG_FUNC_AON_WDT_ON  = 8,
-	TH1520_AON_WDG_FUNC_AON_WDT_OFF = 9,
-};
-
-enum th1520_aon_sys_func {
-	TH1520_AON_SYS_FUNC_UNKNOWN = 0,
-	TH1520_AON_SYS_FUNC_AON_RESERVE_MEM = 1,
-};
-
-enum th1520_aon_lpm_func {
-	TH1520_AON_LPM_FUNC_UNKNOWN = 0,
-	TH1520_AON_LPM_FUNC_REQUIRE_STR = 1,
-	TH1520_AON_LPM_FUNC_RESUME_STR = 2,
-	TH1520_AON_LPM_FUNC_REQUIRE_STD = 3,
-	TH1520_AON_LPM_FUNC_CPUHP = 4,
-	TH1520_AON_LPM_FUNC_REGDUMP_CFG = 5,
-};
-
-enum th1520_aon_pm_func {
-	TH1520_AON_PM_FUNC_UNKNOWN = 0,
-	TH1520_AON_PM_FUNC_SET_RESOURCE_REGULATOR = 1,
-	TH1520_AON_PM_FUNC_GET_RESOURCE_REGULATOR = 2,
-	TH1520_AON_PM_FUNC_SET_RESOURCE_POWER_MODE = 3,
-	TH1520_AON_PM_FUNC_PWR_SET = 4,
-	TH1520_AON_PM_FUNC_PWR_GET = 5,
-	TH1520_AON_PM_FUNC_CHECK_FAULT = 6,
-	TH1520_AON_PM_FUNC_GET_TEMPERATURE = 7,
-};
-
-struct th1520_aon_rpc_msg_hdr {
-	uint8_t ver;    ///< version of msg hdr
-	uint8_t size;   ///< msg size ,uinit in bytes,the size includes rpc msg header self.
-	uint8_t svc;    ///< rpc main service id
-	uint8_t func;   ///< rpc sub func id of specific service, sent by caller
-} __packed __aligned(1);
-
-struct th1520_aon_rpc_ack_common {
-    struct th1520_aon_rpc_msg_hdr hdr;
-	u8   err_code;
-} __packed __aligned(1);
-
-#define RPC_SVC_MSG_TYPE_DATA     0
-#define RPC_SVC_MSG_TYPE_ACK      1
-#define RPC_SVC_MSG_NEED_ACK      0
-#define RPC_SVC_MSG_NO_NEED_ACK   1
-
-#define RPC_GET_VER(MESG)			((MESG)->ver)
-#define RPC_SET_VER(MESG, VER)			((MESG)->ver = (VER))
-#define RPC_GET_SVC_ID(MESG)			((MESG)->svc & 0x3F)
-#define RPC_SET_SVC_ID(MESG, ID)	        ((MESG)->svc |= 0x3F & (ID))
-#define RPC_GET_SVC_FLAG_MSG_TYPE(MESG)	        (((MESG)->svc & 0x80) >> 7)
-#define RPC_SET_SVC_FLAG_MSG_TYPE(MESG, TYPE)	((MESG)->svc |= (TYPE) << 7)
-#define RPC_GET_SVC_FLAG_ACK_TYPE(MESG)		(((MESG)->svc & 0x40) >> 6)
-#define RPC_SET_SVC_FLAG_ACK_TYPE(MESG, ACK)    ((MESG)->svc |= (ACK) << 6)
-
-#define RPC_SET_BE64(MESG, OFFSET, SET_DATA)                                                                                  do {uint8_t* data = (uint8_t*)(MESG);       \
-                                                                                                                               data[OFFSET + 7]  =     (SET_DATA) & 0xFF;  \
-                                                                                                                               data[OFFSET + 6]  = ((SET_DATA) & 0xFF00) >> 8; \
-                                                                                                                               data[OFFSET + 5]  = ((SET_DATA) & 0xFF0000) >> 16; \
-                                                                                                                               data[OFFSET + 4]  = ((SET_DATA) & 0xFF000000) >> 24; \
-                                                                                                                               data[OFFSET + 3]  = ((SET_DATA) & 0xFF00000000) >> 32; \
-                                                                                                                               data[OFFSET + 2]  = ((SET_DATA) & 0xFF0000000000) >> 40; \
-                                                                                                                               data[OFFSET + 1]  = ((SET_DATA) & 0xFF000000000000) >> 48; \
-                                                                                                                               data[OFFSET + 0]  = ((SET_DATA) & 0xFF00000000000000) >> 56; \
-                                                                                                                              } while(0)
-
-#define RPC_SET_BE32(MESG, OFFSET, SET_DATA)                                                                          do { uint8_t* data = (uint8_t*)(MESG);    \
-                                                                                                                               data[OFFSET +  3]  =     (SET_DATA) & 0xFF;  \
-                                                                                                                               data[OFFSET + 2]  = ((SET_DATA) & 0xFF00) >> 8; \
-                                                                                                                               data[OFFSET + 1]  = ((SET_DATA) & 0xFF0000) >> 16; \
-                                                                                                                               data[OFFSET + 0]  = ((SET_DATA) & 0xFF000000) >> 24; \
-                                                                                                                              } while(0)
-#define RPC_SET_BE16(MESG, OFFSET, SET_DATA)                                                                          do { uint8_t* data = (uint8_t*)(MESG);   \
-                                                                                                                               data[OFFSET  + 1]  = (SET_DATA) & 0xFF; \
-                                                                                                                               data[OFFSET + 0]  = ((SET_DATA) & 0xFF00) >> 8; \
-                                                                                                                              } while(0)
-#define RPC_SET_U8(MESG, OFFSET, SET_DATA)                                                                          do { uint8_t* data = (uint8_t*)(MESG);  \
-                                                                                                                         data[OFFSET]  = (SET_DATA) & 0xFF; \
-																														} while(0)
-#define RPC_GET_BE64(MESG, OFFSET, PTR) \
-			    do {uint8_t* data = (uint8_t*)(MESG); \
-                                *(uint32_t*)(PTR) = (data[OFFSET + 7] \
-						    | data[OFFSET + 6] << 8 \
-						    | data[OFFSET  + 5] << 16 \
-						    | data[OFFSET + 4] << 24 \
-						    | data[OFFSET + 3] << 32 \
-						    | data[OFFSET + 2] << 40 \
-						    | data[OFFSET + 1] << 48 \
-						    | data[OFFSET + 0] << 56); \
-				} while(0)
-#define RPC_GET_BE32(MESG, OFFSET, PTR) \
-			    do {uint8_t* data = (uint8_t*)(MESG); \
-                                *(uint32_t*)(PTR) = (data[OFFSET + 3] \
-						| data[OFFSET + 2] << 8 \
-						| data[OFFSET  + 1] << 16 \
-						| data[OFFSET + 0] << 24); \
-				} while(0)
-#define RPC_GET_BE16(MESG, OFFSET, PTR) \
-			    do {uint8_t* data = (uint8_t*)(MESG); \
-                                *(uint16_t*)(PTR) = (data[OFFSET  + 1] \
-						| data[OFFSET + 0] << 8); \
-				} while(0)
-#define RPC_GET_U8(MESG, OFFSET, PTR) \
-			    do {uint8_t* data = (uint8_t*)(MESG); \
-                                *(uint8_t*)(PTR) = (data[OFFSET]);  \
-                                } while(0)
-
-/*
- * Defines for SC PM Power Mode
- */
-#define TH1520_AON_PM_PW_MODE_OFF		0	/* Power off */
-#define TH1520_AON_PM_PW_MODE_STBY		1	/* Power in standby */
-#define TH1520_AON_PM_PW_MODE_LP		2	/* Power in low-power */
-#define TH1520_AON_PM_PW_MODE_ON		3	/* Power on */
-
-int th1520_aon_call_rpc(struct th1520_aon_ipc *ipc,
-			void *msg, void *ack_msg, bool have_resp);
-int th1520_aon_get_handle(struct th1520_aon_ipc **ipc);
-int th1520_aon_misc_set_control(struct th1520_aon_ipc *ipc,
-				u16 resource, u32 ctrl, u32 val);
-int th1520_aon_misc_get_control(struct th1520_aon_ipc *ipc,
-				u16 resource, u32 ctrl, u32 *val);
-#endif /* _SC_IPC_H */
--- a/include/linux/firmware/thead/th1520_event.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef _TH1520_EVENT_H
-#define _TH1520_EVENT_H
-
-enum th1520_rebootmode_index {
-	/* C902 event rebootmode */
-        TH1520_EVENT_PMIC_RESET = 0x0,
-        TH1520_EVENT_PMIC_ONKEY,
-        TH1520_EVENT_PMIC_POWERUP,
-
-	/* C910 event rebootmode */
-        TH1520_EVENT_SW_REBOOT = 0x20,
-        TH1520_EVENT_SW_WATCHDOG,
-        TH1520_EVENT_SW_PANIC,
-        TH1520_EVENT_SW_HANG,
-        TH1520_EVENT_MAX,
-};
-
-#if IS_ENABLED(CONFIG_TH1520_REBOOTMODE)
-extern int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode);
-extern int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode);
-#else
-static int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode)
-{
-	return 0;
-}
-static int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode)
-{
-	*mode = TH1520_EVENT_MAX;
-
-	return 0;
-}
-#endif
-
-#endif
--- /dev/null
+++ b/include/linux/firmware/xuantie/ipc.h
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+
+#ifndef _SC_IPC_H
+#define _SC_IPC_H
+
+#include <linux/device.h>
+#include <linux/types.h>
+
+#define AON_RPC_MSG_MAGIC	       (0xef)
+#define TH1520_AON_RPC_VERSION		2
+#define TH1520_AON_RPC_MSG_NUM		7
+
+struct th1520_aon_ipc;
+
+enum th1520_aon_rpc_svc {
+	TH1520_AON_RPC_SVC_UNKNOWN = 0,
+	TH1520_AON_RPC_SVC_PM =	1,
+	TH1520_AON_RPC_SVC_MISC = 2,
+	TH1520_AON_RPC_SVC_AVFS = 3,
+	TH1520_AON_RPC_SVC_SYS = 4,
+	TH1520_AON_RPC_SVC_WDG = 5,
+	TH1520_AON_RPC_SVC_LPM = 6,
+	TH1520_AON_RPC_SVC_MAX = 0x3F,
+};
+
+enum th1520_aon_misc_func {
+	TH1520_AON_MISC_FUNC_UNKNOWN = 0,
+	TH1520_AON_MISC_FUNC_SET_CONTROL = 1,
+	TH1520_AON_MISC_FUNC_GET_CONTROL = 2,
+	TH1520_AON_MISC_FUNC_REGDUMP_CFG = 3,
+};
+
+enum th1520_aon_wdg_func {
+	TH1520_AON_WDG_FUNC_UNKNOWN = 0,
+	TH1520_AON_WDG_FUNC_START = 1,
+	TH1520_AON_WDG_FUNC_STOP = 2,
+	TH1520_AON_WDG_FUNC_PING = 3,
+	TH1520_AON_WDG_FUNC_TIMEOUTSET = 4,
+	TH1520_AON_WDG_FUNC_RESTART = 5,
+	TH1520_AON_WDG_FUNC_GET_STATE = 6,
+	TH1520_AON_WDG_FUNC_POWER_OFF = 7,
+	TH1520_AON_WDG_FUNC_AON_WDT_ON  = 8,
+	TH1520_AON_WDG_FUNC_AON_WDT_OFF = 9,
+};
+
+enum th1520_aon_sys_func {
+	TH1520_AON_SYS_FUNC_UNKNOWN = 0,
+	TH1520_AON_SYS_FUNC_AON_RESERVE_MEM = 1,
+};
+
+enum th1520_aon_lpm_func {
+	TH1520_AON_LPM_FUNC_UNKNOWN = 0,
+	TH1520_AON_LPM_FUNC_REQUIRE_STR = 1,
+	TH1520_AON_LPM_FUNC_RESUME_STR = 2,
+	TH1520_AON_LPM_FUNC_REQUIRE_STD = 3,
+	TH1520_AON_LPM_FUNC_CPUHP = 4,
+	TH1520_AON_LPM_FUNC_REGDUMP_CFG = 5,
+};
+
+enum th1520_aon_pm_func {
+	TH1520_AON_PM_FUNC_UNKNOWN = 0,
+	TH1520_AON_PM_FUNC_SET_RESOURCE_REGULATOR = 1,
+	TH1520_AON_PM_FUNC_GET_RESOURCE_REGULATOR = 2,
+	TH1520_AON_PM_FUNC_SET_RESOURCE_POWER_MODE = 3,
+	TH1520_AON_PM_FUNC_PWR_SET = 4,
+	TH1520_AON_PM_FUNC_PWR_GET = 5,
+	TH1520_AON_PM_FUNC_CHECK_FAULT = 6,
+	TH1520_AON_PM_FUNC_GET_TEMPERATURE = 7,
+};
+
+struct th1520_aon_rpc_msg_hdr {
+	uint8_t ver;    ///< version of msg hdr
+	uint8_t size;   ///< msg size ,uinit in bytes,the size includes rpc msg header self.
+	uint8_t svc;    ///< rpc main service id
+	uint8_t func;   ///< rpc sub func id of specific service, sent by caller
+} __packed __aligned(1);
+
+struct th1520_aon_rpc_ack_common {
+    struct th1520_aon_rpc_msg_hdr hdr;
+	u8   err_code;
+} __packed __aligned(1);
+
+#define RPC_SVC_MSG_TYPE_DATA     0
+#define RPC_SVC_MSG_TYPE_ACK      1
+#define RPC_SVC_MSG_NEED_ACK      0
+#define RPC_SVC_MSG_NO_NEED_ACK   1
+
+#define RPC_GET_VER(MESG)			((MESG)->ver)
+#define RPC_SET_VER(MESG, VER)			((MESG)->ver = (VER))
+#define RPC_GET_SVC_ID(MESG)			((MESG)->svc & 0x3F)
+#define RPC_SET_SVC_ID(MESG, ID)	        ((MESG)->svc |= 0x3F & (ID))
+#define RPC_GET_SVC_FLAG_MSG_TYPE(MESG)	        (((MESG)->svc & 0x80) >> 7)
+#define RPC_SET_SVC_FLAG_MSG_TYPE(MESG, TYPE)	((MESG)->svc |= (TYPE) << 7)
+#define RPC_GET_SVC_FLAG_ACK_TYPE(MESG)		(((MESG)->svc & 0x40) >> 6)
+#define RPC_SET_SVC_FLAG_ACK_TYPE(MESG, ACK)    ((MESG)->svc |= (ACK) << 6)
+
+#define RPC_SET_BE64(MESG, OFFSET, SET_DATA)                                                                                  do {uint8_t* data = (uint8_t*)(MESG);       \
+                                                                                                                               data[OFFSET + 7]  =     (SET_DATA) & 0xFF;  \
+                                                                                                                               data[OFFSET + 6]  = ((SET_DATA) & 0xFF00) >> 8; \
+                                                                                                                               data[OFFSET + 5]  = ((SET_DATA) & 0xFF0000) >> 16; \
+                                                                                                                               data[OFFSET + 4]  = ((SET_DATA) & 0xFF000000) >> 24; \
+                                                                                                                               data[OFFSET + 3]  = ((SET_DATA) & 0xFF00000000) >> 32; \
+                                                                                                                               data[OFFSET + 2]  = ((SET_DATA) & 0xFF0000000000) >> 40; \
+                                                                                                                               data[OFFSET + 1]  = ((SET_DATA) & 0xFF000000000000) >> 48; \
+                                                                                                                               data[OFFSET + 0]  = ((SET_DATA) & 0xFF00000000000000) >> 56; \
+                                                                                                                              } while(0)
+
+#define RPC_SET_BE32(MESG, OFFSET, SET_DATA)                                                                          do { uint8_t* data = (uint8_t*)(MESG);    \
+                                                                                                                               data[OFFSET +  3]  =     (SET_DATA) & 0xFF;  \
+                                                                                                                               data[OFFSET + 2]  = ((SET_DATA) & 0xFF00) >> 8; \
+                                                                                                                               data[OFFSET + 1]  = ((SET_DATA) & 0xFF0000) >> 16; \
+                                                                                                                               data[OFFSET + 0]  = ((SET_DATA) & 0xFF000000) >> 24; \
+                                                                                                                              } while(0)
+#define RPC_SET_BE16(MESG, OFFSET, SET_DATA)                                                                          do { uint8_t* data = (uint8_t*)(MESG);   \
+                                                                                                                               data[OFFSET  + 1]  = (SET_DATA) & 0xFF; \
+                                                                                                                               data[OFFSET + 0]  = ((SET_DATA) & 0xFF00) >> 8; \
+                                                                                                                              } while(0)
+#define RPC_SET_U8(MESG, OFFSET, SET_DATA)                                                                          do { uint8_t* data = (uint8_t*)(MESG);  \
+                                                                                                                         data[OFFSET]  = (SET_DATA) & 0xFF; \
+																														} while(0)
+#define RPC_GET_BE64(MESG, OFFSET, PTR) \
+			    do {uint8_t* data = (uint8_t*)(MESG); \
+                                *(uint32_t*)(PTR) = (data[OFFSET + 7] \
+						    | data[OFFSET + 6] << 8 \
+						    | data[OFFSET  + 5] << 16 \
+						    | data[OFFSET + 4] << 24 \
+						    | data[OFFSET + 3] << 32 \
+						    | data[OFFSET + 2] << 40 \
+						    | data[OFFSET + 1] << 48 \
+						    | data[OFFSET + 0] << 56); \
+				} while(0)
+#define RPC_GET_BE32(MESG, OFFSET, PTR) \
+			    do {uint8_t* data = (uint8_t*)(MESG); \
+                                *(uint32_t*)(PTR) = (data[OFFSET + 3] \
+						| data[OFFSET + 2] << 8 \
+						| data[OFFSET  + 1] << 16 \
+						| data[OFFSET + 0] << 24); \
+				} while(0)
+#define RPC_GET_BE16(MESG, OFFSET, PTR) \
+			    do {uint8_t* data = (uint8_t*)(MESG); \
+                                *(uint16_t*)(PTR) = (data[OFFSET  + 1] \
+						| data[OFFSET + 0] << 8); \
+				} while(0)
+#define RPC_GET_U8(MESG, OFFSET, PTR) \
+			    do {uint8_t* data = (uint8_t*)(MESG); \
+                                *(uint8_t*)(PTR) = (data[OFFSET]);  \
+                                } while(0)
+
+/*
+ * Defines for SC PM Power Mode
+ */
+#define TH1520_AON_PM_PW_MODE_OFF		0	/* Power off */
+#define TH1520_AON_PM_PW_MODE_STBY		1	/* Power in standby */
+#define TH1520_AON_PM_PW_MODE_LP		2	/* Power in low-power */
+#define TH1520_AON_PM_PW_MODE_ON		3	/* Power on */
+
+int th1520_aon_call_rpc(struct th1520_aon_ipc *ipc,
+			void *msg, void *ack_msg, bool have_resp);
+int th1520_aon_get_handle(struct th1520_aon_ipc **ipc);
+int th1520_aon_misc_set_control(struct th1520_aon_ipc *ipc,
+				u16 resource, u32 ctrl, u32 val);
+int th1520_aon_misc_get_control(struct th1520_aon_ipc *ipc,
+				u16 resource, u32 ctrl, u32 *val);
+#endif /* _SC_IPC_H */
--- /dev/null
+++ b/include/linux/firmware/xuantie/th1520_event.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _TH1520_EVENT_H
+#define _TH1520_EVENT_H
+
+enum th1520_rebootmode_index {
+	/* C902 event rebootmode */
+        TH1520_EVENT_PMIC_RESET = 0x0,
+        TH1520_EVENT_PMIC_ONKEY,
+        TH1520_EVENT_PMIC_POWERUP,
+
+	/* C910 event rebootmode */
+        TH1520_EVENT_SW_REBOOT = 0x20,
+        TH1520_EVENT_SW_WATCHDOG,
+        TH1520_EVENT_SW_PANIC,
+        TH1520_EVENT_SW_HANG,
+        TH1520_EVENT_MAX,
+};
+
+#if IS_ENABLED(CONFIG_TH1520_REBOOTMODE)
+extern int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode);
+extern int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode);
+#else
+static int th1520_event_set_rebootmode(enum th1520_rebootmode_index mode)
+{
+	return 0;
+}
+static int th1520_event_get_rebootmode(enum th1520_rebootmode_index *mode)
+{
+	*mode = TH1520_EVENT_MAX;
+
+	return 0;
+}
+#endif
+
+#endif
